<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Flowpad - Dashboard</title>
<style>
  :root {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --bg-tertiary: rgba(0,0,0,0.9);
    --bg-sidebar: rgba(0,0,0,0.8);
    --bg-tile: #fff;
    --bg-tile-hover: #f8f9fa;
    --text-primary: #fff;
    --text-secondary: #ccc;
    --text-tile: #000;
    --border-primary: #333;
    --border-secondary: #555;
    --accent-primary: #007AFF;
    --accent-secondary: #0056CC;
    --shadow-primary: rgba(0,0,0,0.3);
    --shadow-secondary: rgba(0,0,0,0.2);
    --grid-color: rgba(255,255,255,0.03);
    --tab-active: #007AFF;
    --tab-inactive: #444;
    --tab-hover: #555;
    --inbox-pending: #FF9500;
    --inbox-accepted: #34C759;
    --inbox-rejected: #FF3B30;
  }
  :root[data-theme="light"] {
    --bg-primary: #ffffff;
    --bg-secondary: #f8f9fa;
    --bg-tertiary: rgba(255,255,255,0.95);
    --bg-sidebar: rgba(255,255,255,0.95);
    --bg-tile: #ffffff;
    --bg-tile-hover: #f8f9fa;
    --text-primary: #2d3748;
    --text-secondary: #4a5568;
    --text-tile: #000000;
    --border-primary: #e2e8f0;
    --border-secondary: #cbd5e0;
    --shadow-primary: rgba(0,0,0,0.1);
    --shadow-secondary: rgba(0,0,0,0.05);
    --grid-color: rgba(0,0,0,0.03);
    --tab-active: #007AFF;
    --tab-inactive: #ddd;
    --tab-hover: #e2e8f0;
    --inbox-pending: #FF9500;
    --inbox-accepted: #34C759;
    --inbox-rejected: #FF3B30;
  }
  *{margin:0;padding:0;box-sizing:border-box}
  body{font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;background:#ffffff;color:var(--text-primary);overflow:hidden;transition:all 0.3s ease}
  .header{position:fixed;inset:0 0 auto 0;height:60px;background:var(--bg-tertiary);backdrop-filter:blur(20px);
    border-bottom:1px solid var(--border-primary);display:flex;align-items:center;justify-content:space-between;padding:0 20px;z-index:1000;
    transition:all 0.3s ease;box-shadow:0 4px 20px var(--shadow-primary)}
  .logo{font-size:1.5rem;font-weight:400;background:linear-gradient(45deg,var(--text-primary),var(--text-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
  .user-info{display:flex;align-items:center;gap:15px}
  .signout-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 16px;border-radius:6px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
  .signout-btn:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
  .theme-toggle{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 12px;border-radius:6px;cursor:pointer;margin-right:10px;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
  .theme-toggle:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}

  .sidebar{position:fixed;left:0;top:60px;bottom:0;width:300px;background:var(--bg-sidebar);backdrop-filter:blur(20px);border-right:1px solid var(--border-primary);overflow-y:auto;transition:all 0.3s ease;box-shadow:4px 0 20px var(--shadow-primary)}
  .sidebar-content{padding:20px}
  .section-title{font-size:1.1rem;font-weight:400;margin-bottom:15px;color:var(--text-primary);text-shadow:0 1px 2px var(--shadow-primary)}
  .new-graph-btn{background:var(--accent-primary);color:#fff;border:none;padding:12px 20px;border-radius:8px;cursor:pointer;width:100%;font-size:1rem;margin-bottom:20px;transition:all 0.3s ease;box-shadow:0 4px 12px var(--shadow-primary)}
  .new-graph-btn:hover{background:var(--accent-secondary);box-shadow:0 6px 16px var(--shadow-secondary)}

  .folder-section{margin-bottom:25px;border:1px solid var(--border-secondary);border-radius:8px;overflow:hidden;box-shadow:0 2px 8px var(--shadow-primary)}
  .folder-header{background:var(--bg-secondary);padding:12px 15px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border-secondary);transition:all 0.3s ease}
  .folder-header:hover{background:var(--border-primary)}
  .folder-header.active{background:var(--accent-primary);color:#fff}
  .folder-header.drag-over{background:var(--accent-primary);color:#fff;transform:scale(1.02)}
  .graph-item.dragging{opacity:0.5;transform:scale(0.95)}
  .folder-icon{margin-right:8px;font-size:1.1rem}
  .folder-arrow{transition:transform 0.3s ease}
  .folder-arrow.expanded{transform:rotate(90deg)}
  .folder-content{padding:10px;background:var(--bg-tertiary);display:none}
  .folder-content.expanded{display:block}

  .graph-item{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:12px;margin-bottom:8px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary);position:relative}
  .graph-item:hover{background:var(--border-primary);box-shadow:0 4px 12px var(--shadow-secondary);transform:translateX(5px)}
  .graph-item.active{background:var(--accent-primary);color:#fff;border-color:var(--accent-primary)}
  .graph-title{font-weight:400;margin-bottom:5px;color:inherit;font-size:0.95rem}
  .graph-meta{font-size:.75rem;color:inherit;opacity:0.8}
  .graph-delete{position:absolute;top:8px;right:8px;background:rgba(255,0,0,0.8);color:#fff;border:none;border-radius:4px;width:20px;height:20px;cursor:pointer;font-size:12px;opacity:0;transition:opacity 0.3s ease}
  .graph-item:hover .graph-delete{opacity:1}
  .graph-delete:hover{background:rgba(255,0,0,1)}

  .inbox-item{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:12px;margin-bottom:8px;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary);position:relative}
  .inbox-item.pending{border-left:4px solid var(--inbox-pending)}
  .inbox-item.accepted{border-left:4px solid var(--inbox-accepted)}
  .inbox-item.rejected{border-left:4px solid var(--inbox-rejected)}
  .inbox-title{font-weight:400;margin-bottom:5px;color:var(--text-primary);font-size:0.95rem}
  .inbox-meta{font-size:.75rem;color:var(--text-secondary);margin-bottom:10px}
  .inbox-actions{display:flex;gap:8px}
  .inbox-btn{flex:1;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;font-size:0.8rem;transition:all 0.3s ease;box-shadow:0 2px 4px var(--shadow-primary)}
  .inbox-btn.accept{background:var(--inbox-accepted);color:#fff}
  .inbox-btn.accept:hover{box-shadow:0 4px 8px var(--shadow-secondary)}
  .inbox-btn.reject{background:var(--inbox-rejected);color:#fff}
  .inbox-btn.reject:hover{box-shadow:0 4px 8px var(--shadow-secondary)}

  .canvas-container{position:fixed;left:300px;top:60px;right:0;bottom:0;overflow:hidden}
  .canvas{position:relative;width:100%;height:100%;background:#ffffff;cursor:grab}
  .canvas-content{position:absolute;left:0;top:0;transform-origin:0 0;}

  .tile{position:absolute;background:var(--bg-tile);color:var(--text-tile);border:2px solid var(--border-primary);border-radius:12px;padding:20px;min-width:150px;min-height:100px;cursor:move;user-select:none;box-shadow:0 8px 25px var(--shadow-primary);transition:all 0.1s ease;overflow:hidden}
.tile:hover{background:var(--bg-tile-hover);box-shadow:0 12px 35px var(--shadow-secondary)}
.tile.selected{border-color:var(--accent-primary);box-shadow:0 0 0 3px rgba(0, 122, 255, 0.3)}
.tile-title,.tile-content{border:none;background:transparent;width:100%;outline:none;font-family:inherit;resize:none;font-weight:400}
.tile-title{font-weight:400;margin-bottom:12px;font-size:1rem;color:var(--text-tile)}
.tile-content{font-size:0.9rem;line-height:1.5;min-height:50px;color:var(--text-tile);font-weight:400}

/* Resize outline for selected tiles - always rectangular */
.tile.selected::after{content:'';position:absolute;top:-4px;left:-4px;right:-4px;bottom:-4px;border:2px solid var(--accent-primary);border-radius:8px;pointer-events:none;z-index:1;background:rgba(0,122,255,0.05)}

/* Resize handles for each edge and corner - 4 dots on each side, positioned farther from tile */
.tile.selected .resize-handle{position:absolute;width:8px;height:8px;background:var(--accent-primary);border:2px solid #fff;border-radius:50%;cursor:pointer;z-index:2;box-shadow:0 2px 4px rgba(0,0,0,0.3)}
.tile.selected .resize-handle.n1{top:-12px;left:25%;cursor:n-resize}
.tile.selected .resize-handle.n2{top:-12px;left:50%;transform:translateX(-50%);cursor:n-resize}
.tile.selected .resize-handle.n3{top:-12px;left:75%;cursor:n-resize}
.tile.selected .resize-handle.s1{bottom:-12px;left:25%;cursor:s-resize}
.tile.selected .resize-handle.s2{bottom:-12px;left:50%;transform:translateX(-50%);cursor:s-resize}
.tile.selected .resize-handle.s3{bottom:-12px;left:75%;cursor:s-resize}
.tile.selected .resize-handle.e1{right:-12px;top:25%;cursor:e-resize}
.tile.selected .resize-handle.e2{right:-12px;top:50%;transform:translateY(-50%);cursor:e-resize}
.tile.selected .resize-handle.e3{right:-12px;top:75%;cursor:e-resize}
.tile.selected .resize-handle.w1{left:-12px;top:25%;cursor:w-resize}
.tile.selected .resize-handle.w2{left:-12px;top:50%;transform:translateY(-50%);cursor:w-resize}
.tile.selected .resize-handle.w3{left:-12px;top:75%;cursor:w-resize}
.tile.selected .resize-handle.nw{top:-12px;left:-12px;cursor:nw-resize}
.tile.selected .resize-handle.ne{top:-12px;right:-12px;cursor:ne-resize}
.tile.selected .resize-handle.sw{bottom:-12px;left:-12px;cursor:sw-resize}
.tile.selected .resize-handle.se{bottom:-12px;right:-12px;cursor:se-resize}

  /* quick picker hover areas */
  .shape-palette{position:absolute;top:10px;left:10px;display:grid;grid-template-columns:repeat(3,1fr);gap:4px;opacity:0;transition:opacity 0.3s ease;z-index:1000}
  .tile:hover .shape-palette{opacity:1}
  .shape-option{width:24px;height:24px;border:2px solid var(--border-primary);border-radius:4px;cursor:pointer;transition:all 0.3s ease;background:var(--bg-secondary);display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--text-secondary)}
  .shape-option:hover{transform:scale(1.1);border-color:var(--accent-primary)}

  /* Color palette removed from tiles - now in tile menu */

  .connection-dot{position:absolute;width:20px;height:20px;background:var(--accent-primary);border:3px solid #fff;border-radius:50%;cursor:crosshair;z-index:10;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
  .connection-dot:hover{transform:scale(1.2);background:var(--accent-secondary)}
  .connection-dot.input{left:-10px;top:50%;transform:translateY(-50%)}
  .connection-dot.output{right:-10px;top:50%;transform:translateY(-50%)}
  .connection-dot.top{top:-10px;left:50%;transform:translateX(-50%)}
  .connection-dot.bottom{bottom:-10px;left:50%;transform:translateX(-50%)}

  .connection{position:absolute;pointer-events:none;z-index:5}
  .connection-line{stroke:var(--accent-primary);stroke-width:3;fill:none;marker-end:url(#arrowhead);filter:drop-shadow(0 2px 4px var(--shadow-primary))}
  .connection-line:hover{stroke:var(--accent-secondary);stroke-width:4}
  .connection-line.selected{stroke-width:5;filter:drop-shadow(0 0 8px currentColor)}

  .toolbar{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:12px;z-index:1000;min-width:230px;transition:all 0.3s ease;box-shadow:0 8px 25px var(--shadow-primary)}
  .tool-label{color:var(--text-secondary);font-size:.8rem;margin-bottom:8px;text-align:center;font-weight:400}
  .tool-row{display:flex;flex-wrap:wrap;gap:6px}
  .tool-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px;border-radius:6px;cursor:pointer;width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;font-size:.95rem;transition:all 0.2s ease;box-shadow:0 2px 6px var(--shadow-primary)}
  .tool-btn:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
  .tool-btn.active{background:var(--accent-primary);color:#fff}
  .tool-btn.cache-status-btn{background:var(--accent-primary);color:#fff}
  .tool-btn.force-save-btn{background:var(--inbox-pending);color:#fff}
  .tool-btn.share-btn{background:var(--inbox-accepted);color:#fff}
  .tool-btn.new-graph-btn{background:var(--accent-primary);color:#fff;font-weight:bold}
  .tool-btn.snap-grid-btn.active,.tool-btn.snap-tiles-btn.active{background:var(--accent-primary);color:#fff}
  .tool-btn.snap-tiles-btn:not(.active){background:var(--border-primary);color:var(--text-primary)}

  .ai-panel{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:20px;z-index:1000;width:300px;display:none;transition:all 0.3s ease;box-shadow:0 8px 25px var(--shadow-primary)}
  .ai-panel.show{display:block}
  .ai-title{font-size:1.1rem;font-weight:400;margin-bottom:15px;color:var(--text-primary)}
  .ai-input{width:100%;padding:10px;border:1px solid var(--border-secondary);border-radius:6px;background:var(--bg-secondary);color:var(--text-primary);margin-bottom:15px;resize:vertical;min-height:80px;font-weight:400}
  .ai-btn{background:var(--accent-primary);color:#fff;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;width:100%;transition:all 0.3s ease;box-shadow:0 4px 12px var(--shadow-primary)}
  .ai-btn:hover{background:var(--accent-secondary);box-shadow:0 6px 16px var(--shadow-secondary)}
  .ai-btn:disabled{background:var(--border-secondary);cursor:not-allowed;box-shadow:none}
  .ai-suggestions{margin-top:15px;max-height:200px;overflow-y:auto}
  .ai-suggestion{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:10px;margin-bottom:8px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary);font-weight:400}
  .ai-suggestion:hover{background:var(--border-primary);box-shadow:0 4px 12px var(--shadow-secondary)}

  .notification{position:fixed;top:80px;right:20px;background:var(--accent-primary);color:#fff;padding:12px 20px;border-radius:8px;box-shadow:0 8px 25px var(--shadow-primary);z-index:10000;transform:translateX(400px);transition:.3s transform;max-width:300px}
  .notification.show{transform:translateX(0)}
  .notification.error{background:#f44336}
  .notification.warn{background:#FF9500}
  .notification .small{opacity:.9;font-size:.85em}

  .connection-mode{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:15px;z-index:1000;margin-bottom:10px;box-shadow:0 8px 25px var(--shadow-primary)}
  .connection-mode-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 16px;border-radius:6px;cursor:pointer;margin:2px;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
  .connection-mode-btn:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
  .connection-mode-btn.active{background:var(--accent-primary);color:#fff}

  .loading{display:inline-block;width:16px;height:16px;border:2px solid transparent;border-top:2px solid currentColor;border-radius:50%;animation:spin 1s linear infinite;margin-right:8px}
  @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}

  .modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);backdrop-filter:blur(5px);z-index:10000;display:none;align-items:center;justify-content:center}
  .modal-overlay.show{display:flex}
  .modal{background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:12px;padding:30px;min-width:400px;max-width:600px;box-shadow:0 20px 40px var(--shadow-primary)}
  .modal-title{font-size:1.3rem;font-weight:400;margin-bottom:20px;color:var(--text-primary)}
  .modal-input{width:100%;padding:15px;border:1px solid var(--border-secondary);border-radius:8px;background:var(--bg-secondary);color:var(--text-primary);font-size:1rem;margin-bottom:20px;outline:none;transition:border-color 0.3s ease;font-weight:400}
  .modal-input:focus{border-color:var(--accent-primary)}
  .modal-buttons{display:flex;gap:10px;justify-content:flex-end}
  .modal-btn{padding:12px 24px;border:none;border-radius:8px;cursor:pointer;font-size:1rem;transition:all 0.3s ease;box-shadow:0 4px 12px var(--shadow-primary)}
  .modal-btn.primary{background:var(--accent-primary);color:#fff}
  .modal-btn.primary:hover{background:var(--accent-secondary);box-shadow:0 6px 16px var(--shadow-secondary)}
  .modal-btn.secondary{background:var(--border-primary);color:var(--text-primary)}
  .modal-btn.secondary:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}

  .recent-colors-popup{position:absolute;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:10px;box-shadow:0 10px 25px var(--shadow-primary);z-index:1000;display:grid;grid-template-columns:repeat(5,1fr);gap:5px;min-width:200px}
  .recent-colors-popup .color-option{width:25px;height:25px;border-radius:4px;cursor:pointer;border:2px solid transparent;transition:all 0.2s ease}
  .recent-colors-popup .color-option:hover{border-color:var(--accent-primary);transform:scale(1.1)}

  .share-section{display:none;margin-top:20px;padding:15px;background:var(--bg-secondary);border-radius:8px;border:1px solid var(--border-secondary);box-shadow:0 2px 8px var(--shadow-primary)}
  .share-section.show{display:block}
  .share-toggle{background:var(--accent-primary);color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:0.9rem;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
  .share-toggle:hover{background:var(--accent-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
  .share-toggle.off{background:var(--border-primary);color:var(--text-primary)}
  .share-toggle.off:hover{background:var(--border-secondary)}
  .share-email{width:100%;padding:8px;border-radius:6px;border:1px solid var(--border-secondary);background:var(--bg-tertiary);color:var(--text-primary);margin-top:10px;font-weight:400}
  .share-btn{margin-top:8px;background:var(--accent-primary);color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;width:100%;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
  .share-btn:hover{background:var(--accent-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}

  .tile-updating{transition:all 0.1s ease-out}
  .connection-updating{transition:all 0.1s ease-out}

  .tab-container{display:flex;background:var(--bg-secondary);border-bottom:1px solid var(--border-primary);overflow-x:auto;padding:0 20px}
  .tab{background:var(--tab-inactive);color:var(--text-secondary);border:none;padding:12px 20px;cursor:pointer;transition:all 0.3s ease;border-radius:8px 8px 0 0;margin-right:2px;font-weight:400;position:relative;min-width:120px;text-align:center}
  .tab:hover{background:var(--tab-hover);color:var(--text-primary)}
  .tab.active{background:var(--tab-active);color:#fff}
  .tab-close{position:absolute;top:8px;right:8px;background:rgba(255,255,255,0.2);color:inherit;border:none;border-radius:50%;width:16px;height:16px;cursor:pointer;font-size:10px;opacity:0;transition:opacity 0.3s ease}
  .tab:hover .tab-close{opacity:1}
  .tab-close:hover{background:rgba(255,255,255,0.3)}

  .auto-save-indicator{position:fixed;bottom:20px;left:320px;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:8px 12px;box-shadow:0 4px 12px var(--shadow-primary);z-index:1000;font-size:0.8rem;color:var(--text-secondary);transition:all 0.3s ease;opacity:0;transform:translateY(20px)}
  .auto-save-indicator.show{opacity:1;transform:translateY(0)}
  .auto-save-indicator.saving{color:var(--inbox-pending)}
  .auto-save-indicator.saved{color:var(--inbox-accepted)}
  .auto-save-indicator.error{color:var(--inbox-rejected)}

  .snap-indicator{position:absolute;width:2px;height:2px;background:var(--accent-primary);border-radius:50%;pointer-events:none;z-index:1000;opacity:0;transition:opacity 0.2s ease}
  .snap-indicator.show{opacity:1}
  .snap-indicator.grid{background:var(--accent-primary)}
  .snap-indicator.tile{background:var(--inbox-accepted)}

  .shape-palette{position:absolute;top:10px;left:10px;display:grid;grid-template-columns:repeat(3,1fr);gap:4px;opacity:0;transition:opacity 0.3s ease;z-index:1000}
  .tile:hover .shape-palette{opacity:1}
  .shape-option{width:24px;height:24px;border:2px solid var(--border-primary);border-radius:4px;cursor:pointer;transition:all 0.3s ease;background:var(--bg-secondary);display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--text-secondary)}
  .shape-option:hover{transform:scale(1.1);border-color:var(--accent-primary)}
  .shape-option.selected{border-color:var(--accent-primary);background:var(--accent-primary);color:#fff}

  .tile.rounded{border-radius:20px}
  .tile.circular{border-radius:50%;min-width:120px;min-height:120px}
  .tile.hexagon{clip-path:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)}
  .tile.diamond{clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)}
  .tile.triangle{clip-path:polygon(50% 0%, 0% 100%, 100% 100%)}
  .tile.parallelogram{clip-path:polygon(25% 0%, 100% 0%, 75% 100%, 0% 100%)}

  .grid-snap-line{position:absolute;background:var(--accent-primary);opacity:0.3;pointer-events:none;z-index:999;transition:opacity 0.2s ease}
  .grid-snap-line.show{opacity:0.6}
  .grid-snap-line.vertical{width:1px}
  .grid-snap-line.horizontal{height:1px}

  .grid-overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:50;opacity:0.1;transition:opacity 0.3s ease}
  .grid-overlay.show{opacity:0.2}
  .grid-line{position:absolute;background:var(--accent-primary);opacity:0.3}
  .grid-line.vertical{width:1px;height:100%}
  .grid-line.horizontal{height:1px;width:100%}

  .tool-btn.grid-toggle-btn{background:var(--accent-primary);color:#fff}
  .tool-btn.grid-toggle-btn:hover{background:var(--accent-secondary)}
  .tool-btn.grid-toggle-btn:not(.active){background:var(--border-primary);color:var(--text-primary)}

  .floating-toolbar{position:fixed;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.15);padding:8px;display:none;z-index:99999;pointer-events:auto;min-width:200px;transform:translateY(-50%)}
  .floating-toolbar.show{display:block}
  .floating-toolbar.tile-toolbar{min-width:180px;transform:translateY(-50%)}
  .floating-toolbar.connection-toolbar{min-width:160px;transform:translateY(-50%)}

  .toolbar-section{display:flex;flex-direction:column;gap:4px;margin-bottom:8px}
  .toolbar-section:last-child{margin-bottom:0}
  .toolbar-section-title{font-size:11px;color:var(--text-secondary);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px;font-weight:500}

  .toolbar-row{display:flex;gap:4px;align-items:center}
  .toolbar-button{width:32px;height:32px;border:1px solid var(--border-primary);border-radius:6px;background:var(--bg-primary);color:var(--text-primary);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px;transition:all 0.2s ease}
  .toolbar-button:hover{background:var(--bg-tertiary);border-color:var(--accent-primary)}
  .toolbar-button.active{background:var(--accent-primary);color:#fff;border-color:var(--accent-primary)}
  .toolbar-button.small{width:28px;height:28px;font-size:12px}

  /* Color options in toolbar */
  .color-options{display:flex;flex-wrap:wrap;gap:4px}
  .toolbar .color-option{width:20px;height:20px;border-radius:50%;border:2px solid var(--border-primary);cursor:pointer;transition:all 0.2s ease}
  .toolbar .color-option:hover{transform:scale(1.2);border-color:var(--accent-primary)}
  .toolbar .color-option.selected{border-color:var(--accent-primary);box-shadow:0 0 0 2px var(--accent-primary)}

  /* Dropdown styles */
  .toolbar-dropdown{position:relative}
  .toolbar-dropdown-btn{width:100%;padding:8px 12px;border:1px solid var(--border-primary);border-radius:6px;background:var(--bg-primary);color:var(--text-primary);cursor:pointer;text-align:left;font-size:14px}
  .toolbar-dropdown-btn:hover{background:var(--bg-tertiary);border-color:var(--accent-primary)}
  .toolbar-dropdown-content{position:absolute;top:100%;left:0;right:0;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:6px;box-shadow:0 4px 12px var(--shadow-primary);z-index:1001;display:none;max-height:200px;overflow-y:auto}
  .toolbar-dropdown-content.show{display:block}
  .dropdown-item{padding:8px 12px;cursor:pointer;transition:all 0.2s ease;border-bottom:1px solid var(--border-secondary)}
  .dropdown-item:last-child{border-bottom:none}
  .dropdown-item:hover{background:var(--bg-secondary)}
  .dropdown-item.active{background:var(--accent-primary);color:#fff}

  .toolbar-color-picker{width:32px;height:32px;border:1px solid var(--border-primary);border-radius:6px;cursor:pointer;position:relative;overflow:hidden}
  .toolbar-color-picker::before{content:'';position:absolute;top:2px;left:2px;right:2px;bottom:2px;background:var(--tile-color, #ffffff);border-radius:4px}

  .secondary-popup{position:absolute;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.15);padding:12px;display:none;z-index:1001;pointer-events:auto;min-width:240px}
  .secondary-popup.show{display:block}

  .popup-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border-primary)}
  .popup-title{font-size:14px;font-weight:500;color:var(--text-primary)}
  .popup-close{width:24px;height:24px;border:none;background:none;color:var(--text-secondary);cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;border-radius:4px;transition:all 0.2s ease}
  .popup-close:hover{background:var(--bg-tertiary);color:var(--text-primary)}

  .popup-content{display:grid;grid-template-columns:repeat(auto-fit, minmax(40px, 1fr));gap:8px}
  .popup-option{width:40px;height:40px;border:2px solid var(--border-primary);border-radius:6px;cursor:pointer;transition:all 0.2s ease;display:flex;align-items:center;justify-content:center;font-size:16px;background:var(--bg-primary)}
  .popup-option:hover{transform:scale(1.05);border-color:var(--accent-primary)}
  .popup-option.selected{border-color:var(--accent-primary);background:var(--accent-primary);color:#fff}

  .line-style-solid{stroke-dasharray: none}
  .line-style-dashed{stroke-dasharray: 5,5}
  .line-style-dotted{stroke-dasharray: 2,2}
  .line-style-dash-dot{stroke-dasharray: 10,2,2,2}

  .connection-type-arrow{marker-end: url(#arrowhead)}
  .connection-type-line{marker-end: none}
  .connection-type-dot{marker-end: url(#dotmarker)}
  .connection-type-diamond{marker-end: url(#diamondmarker)}

  .tile .color-picker-trigger{display:none}
  .tile .shape-palette{display:none}
  .tile .connection-dot{display:none}

  .preset-tile{position:relative;cursor:pointer;transition:all 0.3s ease}
  .preset-tile:hover{transform:scale(1.05)}
  .preset-tile.selected{transform:scale(1.1);box-shadow:0 0 20px var(--accent-primary)}

  .preset-tile.title{background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:#fff;border-radius:12px}
  .preset-tile.notes{background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%);color:#fff;border-radius:12px}
  .preset-tile.component{background:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);color:#fff;border-radius:12px}
  .preset-tile.custom{background:linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);color:#fff;border-radius:12px}
  .preset-tile-icon{font-size:24px;margin-bottom:8px}
  .preset-tile-label{font-size:12px;font-weight:500;text-align:center}

  .tool-btn.preset-btn { background: var(--accent-primary); color: #fff; transition: all 0.3s ease; }
  .tool-btn.preset-btn:hover { transform: scale(1.1); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }

  .share-permission-selector{display:flex;gap:8px;margin-bottom:12px;align-items:center}
  .permission-option{display:flex;align-items:center;gap:6px;padding:8px 12px;border:2px solid var(--border-primary);border-radius:6px;cursor:pointer;transition:all 0.3s ease;background:var(--bg-primary)}
  .permission-option:hover{border-color:var(--accent-primary);background:var(--bg-tertiary)}
  .permission-option.selected{border-color:var(--accent-primary);background:var(--accent-primary);color:#fff}
  .permission-option input[type="radio"]{display:none}
  .permission-icon{font-size:16px}
  .permission-label{font-size:14px;font-weight:500}
  .permission-description{font-size:11px;color:var(--text-secondary);margin-top:2px}

  .share-section{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:8px;padding:16px;margin-top:16px;display:none}
  .share-section.show{display:block}
  .share-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
  .share-title{font-size:16px;font-weight:500;color:var(--text-primary)}
  .share-toggle{background:var(--accent-primary);color:#fff;border:none;border-radius:6px;padding:8px 16px;cursor:pointer;font-size:14px;transition:all 0.3s ease}
  .share-toggle:hover{background:var(--accent-secondary)}
  .share-toggle.active{background:var(--inbox-pending)}

  .share-email-section{display:flex;gap:8px;margin-bottom:12px}
  .share-email{flex:1;padding:8px 12px;border:1px solid var(--border-primary);border-radius:6px;background:var(--bg-primary);color:var(--text-primary);font-size:14px}
  .share-email:focus{outline:none;border-color:var(--accent-primary)}
  .share-btn{background:var(--accent-primary);color:#fff;border:none;border-radius:6px;padding:8px 16px;cursor:pointer;font-size:14px;transition:all 0.3s ease}
  .share-btn:hover{background:var(--accent-secondary)}
  .share-btn:disabled{background:var(--border-primary);color:var(--text-secondary);cursor:not-allowed}

  /* Share Form Styles */
  .share-form{margin-bottom:20px}
  .form-group{margin-bottom:15px}
  .form-group label{display:block;margin-bottom:5px;color:var(--text-primary);font-weight:500}
  .permission-options{display:flex;flex-direction:column;gap:8px}
  .permission-option{display:flex;align-items:center;gap:8px;padding:8px 12px;border:2px solid var(--border-primary);border-radius:6px;cursor:pointer;transition:all 0.3s ease;background:var(--bg-primary)}
  .permission-option:hover{border-color:var(--accent-primary);background:var(--bg-tertiary)}
  .permission-option input[type="radio"]{margin:0}
  .permission-option input[type="radio"]:checked + .permission-label{color:var(--accent-primary);font-weight:500}
  .permission-label{font-size:14px;font-weight:400}

  .shared-users-list{margin-top:16px}
  .shared-user-item{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:6px;margin-bottom:8px}
  .shared-user-info{display:flex;flex-direction:column}
  .shared-user-email{font-size:14px;color:var(--text-primary);font-weight:500}
  .shared-user-permission{font-size:12px;color:var(--text-secondary)}
  .shared-user-actions{display:flex;gap:4px}
  .remove-user-btn{background:var(--inbox-rejected);color:#fff;border:none;border-radius:4px;padding:4px 8px;cursor:pointer;font-size:12px;transition:all 0.3s ease}
  .remove-user-btn:hover{background:var(--accent-secondary)}
  .change-permission-btn{background:var(--accent-primary);color:#fff;border:none;border-radius:4px;padding:4px 8px;cursor:pointer;font-size:12px;transition:all 0.3s ease}
  .change-permission-btn:hover{background:var(--accent-secondary)}

  .modal.danger .modal-title { color: #dc3545; }
  .modal.danger .modal-btn.danger { background: #dc3545; color: white; border-color: #dc3545; }
  .modal.danger .modal-btn.danger:hover { background: #c82333; border-color: #bd2130; }
  .warning-text { color: #dc3545; font-weight: 500; margin-top: 8px; }

  #connections-svg{ z-index:5 }
  .tile{ z-index:10 }

  .modal-overlay{ z-index:120000 }
  .notification{ z-index:130000 }

  .canvas-container{ z-index:1 }
  .canvas{ z-index:1 }
  .tab-container{ z-index:2 }

  .popover{ position:fixed; z-index:99999; background:var(--bg-tertiary);
    border:1px solid var(--border-primary); border-radius:10px; box-shadow:0 12px 30px var(--shadow-primary);
    padding:10px; pointer-events:auto; backdrop-filter:blur(20px); min-width:200px; max-width:90vw; max-height:90vh; overflow:auto }
  .color-picker-popout { z-index: 99999 !important; position: fixed !important; }
  .floating-toolbar { z-index: 99999 !important; position: fixed !important; }
  .modal, .modal-overlay, .notification { z-index: 99999 !important; position: fixed !important; }
  .color-picker-grid, .color-picker-recent-grid { z-index: 99999 !important; }
  .popup-option, .popup-content { z-index: 99999 !important; }
  .popover * { z-index: inherit !important; }
  .color-picker-option { z-index: 99999 !important; position: relative !important; }

  /* Preset Tile Selector */
  .preset-tiles-grid{
    display:grid; grid-template-columns:repeat(4,1fr); gap:10px; margin-bottom:20px;
  }
  .preset-tile{
    border:1px solid var(--border-primary); border-radius:6px; padding:10px; cursor:pointer; transition:.15s transform;
  }
  .preset-tile:hover{ transform:translateY(-2px); }
  .preset-tile .preset-tile-icon{
    font-size:24px; margin-bottom:6px; color:var(--text-secondary);
  }
  .preset-tile .preset-tile-label{
    font-size:12px; color:var(--text-primary);
  }

  /* Cache Status Modal */
  .cache-status-item{
    display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;
  }
  .cache-label{ font-size:.8rem; color:var(--text-secondary); }
  .cache-status{ font-size:.8rem; color:var(--text-primary); }

  /* Collaborators List */
  .collaborators-list{position:fixed;bottom:20px;right:20px;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:12px;box-shadow:0 8px 25px var(--shadow-primary);z-index:1000;min-width:180px;backdrop-filter:blur(20px);display:none}
  .collaborators-list.show{display:block}
  .collaborators-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--border-secondary)}
  .collaborators-title{font-size:0.8rem;font-weight:500;color:var(--text-primary)}
  .collaborators-count{background:var(--accent-primary);color:#fff;border-radius:10px;padding:2px 8px;font-size:0.7rem;font-weight:500}
  .collaborator-item{display:flex;align-items:center;gap:8px;padding:6px 0;border-bottom:1px solid var(--border-secondary);font-size:0.8rem}
  .collaborator-item:last-child{border-bottom:none}
  .collaborator-avatar{width:24px;height:24px;border-radius:50%;background:var(--accent-primary);color:#fff;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:500}
  .collaborator-name{color:var(--text-primary);flex:1}
  .collaborator-status{width:8px;height:8px;border-radius:50%;background:var(--inbox-accepted)}
  .collaborator-status.away{background:var(--inbox-pending)}
  .collaborator-status.offline{background:var(--inbox-rejected)}

  /* Connection Dots */

  /* Color Picker Popout */
  .color-picker-popout{position:absolute;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:15px;box-shadow:0 10px 25px var(--shadow-primary);z-index:1001;display:none;min-width:200px;backdrop-filter:blur(20px)}
  .color-picker-popout.show{display:block}
  .color-picker-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid var(--border-secondary)}
  .color-picker-title{font-weight:500;color:var(--text-primary);font-size:0.9rem}
  .color-picker-close{background:none;border:none;color:var(--text-secondary);cursor:pointer;font-size:16px;padding:2px;border-radius:4px;transition:all 0.3s ease}
  .color-picker-close:hover{color:var(--text-primary);background:var(--border-primary)}
  .color-picker-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;margin-bottom:15px}
  .color-picker-option{width:30px;height:30px;border-radius:50%;border:2px solid var(--border-primary);cursor:pointer;transition:all 0.3s ease;position:relative}
  .color-picker-option:hover{transform:scale(1.1);border-color:var(--accent-primary)}
  .color-picker-option.selected{border-color:var(--accent-primary);box-shadow:0 0 0 3px var(--accent-primary)}
  .color-picker-option.selected::after{content:'✓';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:12px;font-weight:bold;text-shadow:0 1px 2px rgba(0,0,0,0.5)}
</style>
</head>
<body>
  <div class="header">
    <div class="logo">Flowpad</div>
    <div class="user-info">
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme"><span id="theme-icon">Moon</span></button>
      <span id="userName">User</span>
      <button class="signout-btn" onclick="signOut()">Sign Out</button>
    </div>
  </div>

  <div class="sidebar">
    <div class="sidebar-content">
      <!-- Graph creation moved to toolbar to prevent duplicates -->

      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('myGraphs')" 
             ondragover="handleDragOver(event)" 
             ondrop="handleDrop(event, 'myGraphs')" 
             ondragleave="handleDragLeave(event)">
          <span><span class="folder-icon">Folder</span>My Graphs</span>
          <span class="folder-arrow">▶</span>
        </div>
        <div class="folder-content expanded" id="myGraphs">
          <div id="ownGraphs"></div>
        </div>
      </div>

      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('sharedGraphs')" 
             ondragover="handleDragOver(event)" 
             ondrop="handleDrop(event, 'sharedGraphs')" 
             ondragleave="handleDragLeave(event)">
          <span><span class="folder-icon">Group</span>Shared With Me</span>
          <span class="folder-arrow">▶</span>
        </div>
        <div class="folder-content" id="sharedGraphs">
          <div id="sharedGraphsContent"></div>
        </div>
      </div>

      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('inbox')" 
             ondragover="handleDragOver(event)" 
             ondrop="handleDrop(event, 'inbox')" 
             ondragleave="handleDragLeave(event)">
          <span><span class="folder-icon">Inbox</span>Inbox</span>
          <span class="folder-arrow">▶</span>
        </div>
        <div class="folder-content" id="inbox">
          <div id="inboxContent"></div>
        </div>
      </div>

      <div class="share-section" id="shareSection" style="display:none;">
        <div class="share-header">
          <div class="share-title">Share Graph</div>
          <button class="share-toggle" onclick="toggleShareSection()">Hide</button>
        </div>

        <div class="share-permission-selector">
          <label class="permission-option selected" data-permission="viewer">
            <input type="radio" name="permission" value="viewer" checked>
            <div class="permission-icon">View</div>
            <div class="permission-info">
              <div class="permission-label">Viewer</div>
              <div class="permission-description">Can view only</div>
            </div>
          </label>
          <label class="permission-option" data-permission="editor">
            <input type="radio" name="permission" value="editor">
            <div class="permission-icon">Edit</div>
            <div class="permission-info">
              <div class="permission-label">Editor</div>
              <div class="permission-description">View & edit</div>
            </div>
          </label>
        </div>

        <div class="share-email-section">
          <input type="email" class="share-email" id="shareEmail" placeholder="Enter email address" />
          <button class="share-btn" onclick="shareGraph()">Share</button>
        </div>

        <div class="shared-users-list" id="sharedUsersList"></div>
      </div>
    </div>
  </div>

  <div class="canvas-container">
    <div class="tab-container" id="tabContainer"></div>
    <div class="canvas" id="canvas">
      <div class="canvas-content" id="canvasContent"></div>
    </div>
  </div>

  <!-- Connection mode toggle -->
  <div class="connection-mode" id="connectionMode">
    <div style="color:var(--text-secondary);font-size:0.8rem;margin-bottom:8px;text-align:center;">Connection Mode</div>
    <button class="connection-mode-btn active" onclick="toggleConnectMode(true)" id="modeConnect">Connect</button>
    <button class="connection-mode-btn" onclick="toggleConnectMode(false)" id="modeNone">Select</button>
  </div>

  <!-- Main toolbar -->
  <div class="toolbar" id="toolbar">
    <div class="tool-label">Tools</div>
    <button class="tool-btn" onclick="addTile()" title="Add Tile">+</button>
    <button class="tool-btn" onclick="deleteSelected()" title="Delete Selected">DEL</button>
    <button class="tool-btn" onclick="centerCanvas()" title="Center Canvas">⌂</button>
    <button class="tool-btn" onclick="toggleAIPanel()" title="AI Suggestions">AI</button>
    <button class="tool-btn grid-toggle-btn" onclick="toggleGrid()" title="Show Grid (OFF)">▦</button>
    <button class="tool-btn preset-btn" onclick="showPresetTileSelector()" title="Preset Tiles">Preset</button>
    <button class="tool-btn snap-grid-btn" onclick="toggleSnapToGrid()" title="Snap to Grid (ON)">⊞</button>
    <button class="tool-btn snap-tiles-btn" onclick="toggleSnapToTiles()" title="Snap to Tiles (ON)">Link</button>
    <button class="tool-btn force-save-btn" onclick="forceSave()" title="Force Save">Save</button>
    <button class="tool-btn cache-status-btn" onclick="showCacheStatus()" title="Cache Status">Cache</button>
    <button class="tool-btn share-btn" onclick="openShareGraphModal()" title="Share Graph">Share</button>
    <button class="tool-btn new-graph-btn" onclick="createNewGraph()" title="New Graph">+</button>
  </div>

  <!-- AI panel -->
  <div class="ai-panel" id="aiPanel">
    <div class="ai-title">AI Suggestions</div>
    <textarea class="ai-input" id="aiInput" placeholder="Describe what you want to add or connect..."></textarea>
    <button class="ai-btn" onclick="getAISuggestions()" id="aiBtn"><span id="aiBtnText">Get Suggestions</span></button>
    <div class="ai-suggestions" id="aiSuggestions"></div>
  </div>

  <!-- Notifications -->
  <div id="notification" class="notification"></div>

  <!-- Collaborators -->
  <div class="collaborators-list" id="collaboratorsList">
    <div class="collaborators-header">
      <span class="collaborators-title">Collaborators</span>
      <span class="collaborators-count" id="collaboratorsCount">0</span>
    </div>
    <div id="collaboratorsContent"></div>
  </div>

  <!-- Autosave indicator -->
  <div class="auto-save-indicator" id="autoSaveIndicator"><span id="autoSaveText">Ready</span></div>

  <!-- New graph modal -->
  <div class="modal-overlay" id="newGraphModal">
    <div class="modal">
      <div class="modal-title">Create New Graph</div>
      <input type="text" class="modal-input" id="newGraphTitle" placeholder="Enter graph title..." maxlength="100">
      <div class="modal-buttons">
        <button class="modal-btn secondary" onclick="closeNewGraphModal()">Cancel</button>
        <button class="modal-btn primary" onclick="confirmNewGraph()">Create</button>
      </div>
    </div>
  </div>

  <!-- Preset Tile Selector -->
  <div class="modal-overlay" id="presetTileModal">
    <div class="modal">
      <div class="modal-title">Choose Preset Tile</div>
      <div class="preset-tiles-grid">
        <div class="preset-tile title" onclick="createPresetTile('title')">
          <div class="preset-tile-icon">Title</div>
          <div class="preset-tile-label">Title</div>
        </div>
        <div class="preset-tile notes" onclick="createPresetTile('notes')">
          <div class="preset-tile-icon">Notes</div>
          <div class="preset-tile-label">Notes</div>
        </div>
        <div class="preset-tile component" onclick="createPresetTile('component')">
          <div class="preset-tile-icon">Component</div>
          <div class="preset-tile-label">Component</div>
        </div>
        <div class="preset-tile custom" onclick="createPresetTile('custom')">
          <div class="preset-tile-icon">Custom</div>
          <div class="preset-tile-label">Custom</div>
        </div>
      </div>
      <!-- Cancel button removed for cleaner UX -->
    </div>
  </div>

  <!-- Cache Status Modal -->
  <div class="modal-overlay" id="cacheStatusModal">
    <div class="modal">
      <div class="modal-title">Cache & Sync Status</div>
      <div id="cacheStatusContent">
        <div class="cache-status-item">
          <span class="cache-label">Last Save:</span>
          <span id="lastSaveTime">Never</span>
        </div>
        <div class="cache-status-item">
          <span class="cache-label">Auto-save:</span>
          <span id="autoSaveStatus">Enabled</span>
        </div>
        <div class="cache-status-item">
          <span class="cache-label">Pending Updates:</span>
          <span id="pendingUpdatesCount">0</span>
        </div>
        <div class="cache-status-item">
          <span class="cache-label">Connection:</span>
          <span id="connectionStatus">Online</span>
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-btn secondary" onclick="closeCacheStatusModal()">Close</button>
        <button class="modal-btn primary" onclick="forceSave()">Force Save Now</button>
      </div>
    </div>
  </div>

  <!-- Share Graph Modal -->
  <div class="modal-overlay" id="shareGraphModal">
    <div class="modal">
      <div class="modal-title">Share Graph</div>
      <div class="share-form">
        <div class="form-group">
          <label for="shareEmail">Email Address:</label>
          <input type="email" id="shareEmail" class="modal-input" placeholder="Enter email address..." required>
        </div>
        <div class="form-group">
          <label>Permission Level:</label>
          <div class="permission-options">
            <label class="permission-option">
              <input type="radio" name="permission" value="view" checked>
              <span class="permission-label">View Only</span>
            </label>
            <label class="permission-option">
              <input type="radio" name="permission" value="edit">
              <span class="permission-label">Can Edit</span>
            </label>
            <label class="permission-option">
              <input type="radio" name="permission" value="admin">
              <span class="permission-label">Admin</span>
            </label>
          </div>
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-btn secondary" onclick="closeShareGraphModal()">Cancel</button>
        <button class="modal-btn primary" onclick="shareGraph()">Share</button>
      </div>
    </div>
  </div>

  <!-- Floating Toolbar for Tiles -->
  <div class="floating-toolbar tile-toolbar" id="tileToolbar">
    <div class="toolbar-section">
      <div class="toolbar-section-title">Tile</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="duplicateTile()" title="Duplicate">Copy</button>
        <button class="toolbar-button" onclick="bringToFront()" title="Bring to Front">Up</button>
        <button class="toolbar-button" onclick="sendToBack()" title="Send to Back">Down</button>
        <button class="toolbar-button" onclick="deleteSelected()" title="Delete">Delete</button>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Shape</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="changeTileShape('rectangle')" title="Rectangle">Rect</button>
        <button class="toolbar-button" onclick="changeTileShape('rounded')" title="Rounded">Round</button>
        <button class="toolbar-button" onclick="changeTileShape('circular')" title="Circle">Circle</button>
        <button class="toolbar-button" onclick="changeTileShape('hexagon')" title="Hexagon">Hex</button>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Color</div>
      <div class="toolbar-row">
        <div class="toolbar-color-picker" onclick="showColorPicker()" title="Change Color"></div>
        <button class="toolbar-button" onclick="resetTileColor()" title="Reset Color">Reset</button>
      </div>
    </div>
  </div>

  <!-- Floating Toolbar for Connections -->
  <div class="floating-toolbar connection-toolbar" id="connectionToolbar">
    <div class="toolbar-section">
      <div class="toolbar-section-title">Connection</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="deleteSelectedConnection()" title="Delete">Delete</button>
        <button class="toolbar-button" onclick="changeConnectionColor()" title="Color">Color</button>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Style</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="changeLineStyle('solid')" title="Solid">━</button>
        <button class="toolbar-button" onclick="changeLineStyle('dashed')" title="Dashed">┅</button>
        <button class="toolbar-button" onclick="changeLineStyle('dotted')" title="Dotted">┄</button>
      </div>
    </div>
  </div>

  <!-- Context menu -->
  <div class="ctx" id="ctxMenu">
    <ul>
      <li onclick="ctxAction('edit')">Edit</li>
      <li onclick="ctxAction('color')">Color...</li>
      <li onclick="ctxAction('shape')">Shape...</li>
      <li onclick="ctxAction('duplicate')">Duplicate</li>
      <li onclick="ctxAction('delete')">Delete</li>
    </ul>
  </div>

  <!-- SVG markers -->
  <svg style="position:absolute;width:0;height:0;pointer-events:none">
    <defs>
      <marker id="arrowhead" markerWidth="12" markerHeight="8" refX="10" refY="4" orient="auto">
        <polygon points="0 0, 12 4, 0 8" fill="var(--accent-primary)"></polygon>
      </marker>
      <marker id="dotmarker" markerWidth="8" markerHeight="8" refX="4" refY="4" orient="auto">
        <circle cx="4" cy="4" r="3" fill="var(--accent-primary)"></circle>
      </marker>
      <marker id="diamondmarker" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
        <polygon points="5 0, 10 3.5, 5 7, 0 3.5" fill="var(--accent-primary)"></polygon>
      </marker>
    </defs>
  </svg>

  <!-- Hidden file input for import -->
  <input type="file" id="importFile" accept=".json" style="display: none;">

<script>
/* =========================
   Core state
========================= */
let currentUser = null, currentGraph = null;
let tiles = [], connections = [];
let selectedTile = null;
let selectedConnection = null;
let isDragging = false, dragOffsetWorld = {x:0,y:0};
let isPanning = false, panStart = {x:0,y:0};
let canvasOffset = {x:0,y:0};
let zoom = 1; // world -> screen scale
let openTabs = [], activeTabId = null;
let pendingUpdates = [];
let isDirty = false, lastSaveTime = 0, autoSaveTimer = null;
let snapToGrid = true, snapToTiles = true, gridSize = 20, showGrid = false;
let snapIndicators = [], snapLines = [];
let isConnecting = false, connectionStart = null;
let historyStack = [], futureStack = [];
const canvas = document.getElementById('canvas');
const canvasContent = document.getElementById('canvasContent');
const tabContainer = document.getElementById('tabContainer');
// presetPopup removed - using presetTileModal instead
const ctxMenu = document.getElementById('ctxMenu');
let ctxTargetTile = null;

/* =========================
   Init
========================= */
document.addEventListener('DOMContentLoaded', init);

async function init(){
  try { await checkAuth(); } catch {}
  await loadGraphs().catch(()=>{});
  await loadInbox().catch(()=>{});
  
  // Load from localStorage only if no graphs loaded from server and no tiles exist
  if (!currentGraph && tiles.length === 0) {
    loadFromLocalStorage();
  }
  
  setupCanvas();
  setupTheme();
  setupRealtimeUpdates();
  setupAutoSave();
  setupGridVisualization();
  setupSnapping();
  setupKeyboardShortcuts();
  addShareEmailListener();
  initializePermissionSelector();
  addCacheStatusButton();
  
  // Set up import file event listener
  const importFile = document.getElementById('importFile');
  if (importFile) {
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const d = JSON.parse(reader.result);
          // load into current graph
          tiles = [];
          connections = [];
          (d.tiles || []).forEach(t => tiles.push(createTile(t.x, t.y, t.title, t.content, t.id, t.shape || 'rectangle', t.preset || 'custom', t.color || '#ffffff')));
          connections = d.connections || [];
          renderCanvas();
          scheduleSave();
          notify('Imported');
        } catch {
          notify('Import failed', 'error');
        }
      };
      reader.readAsText(file);
    });
  }
  loadCollaborators();
  notify('Ready. Press N to add a tile. Hold Alt and drag between tiles to connect.', 'warn', 3500);
}

/* =========================
   Helpers / UI
========================= */
function notify(msg, type='success', ms=2200){
  const n = document.getElementById('notification');
  n.innerHTML = msg;
  n.className = `notification ${type}`;
  n.classList.add('show');
  setTimeout(()=>{ n.classList.remove('show'); }, ms);
}

function toggleFolder(folderId){
  const folder = document.getElementById(folderId);
  const header = folder.previousElementSibling;
  const arrow = header.querySelector('.folder-arrow');
  folder.classList.toggle('expanded');
  arrow.classList.toggle('expanded');
  header.classList.toggle('active');
}

function toggleShareSection(){
  const section = document.getElementById('shareSection');
  const btn = section.querySelector('.share-toggle');
  const visible = section.classList.toggle('show');
  btn.textContent = visible ? 'Hide' : 'Show';
}

/* =========================
   Theme
========================= */
function setupTheme(){
  const saved = localStorage.getItem('flowpad_theme') || 'dark';
  document.documentElement.setAttribute('data-theme', saved);
  updateThemeIcon(saved);
  if (tiles.length) updateTileColorsForTheme(saved);
}
function toggleTheme(){
  const cur = document.documentElement.getAttribute('data-theme');
  const nxt = cur === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', nxt);
  localStorage.setItem('flowpad_theme', nxt);
  updateThemeIcon(nxt);
  updateTileColorsForTheme(nxt);
}
function updateThemeIcon(theme){ document.getElementById('theme-icon').textContent = theme==='dark'?'Moon':'Sun'; }
function updateTileColorsForTheme(theme){
  tiles.forEach(t=>{
    const c = getComputedStyle(t).backgroundColor;
    t.style.backgroundColor = getThemeAdjustedColor(c, theme);
  });
  renderConnections();
}
function toHex(c){
  c = (c||'').trim();
  if (c.startsWith('rgb')) {
    const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if (m){ const [r,g,b]=[m[1],m[2],m[3]].map(n=>+n); return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
  }
  if (/^#([0-9a-f]{3})$/i.test(c)) return '#'+c.slice(1).split('').map(ch=>ch+ch).join('');
  if (/^#([0-9a-f]{6})$/i.test(c)) return c.toLowerCase();
  return '#ffffff';
}
function adjustColorBrightness(hex, factor){
  hex = toHex(hex);
  const r = Math.min(255, Math.max(0, Math.round(parseInt(hex.slice(1,3),16)*factor)));
  const g = Math.min(255, Math.max(0, Math.round(parseInt(hex.slice(3,5),16)*factor)));
  const b = Math.min(255, Math.max(0, Math.round(parseInt(hex.slice(5,7),16)*factor)));
  return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
}
function getThemeAdjustedColor(color, theme){
  color = toHex(color);
  if (color==='#ffffff') return theme==='light' ? '#2d3748' : '#ffffff';
  if (color==='#000000') return theme==='light' ? '#ffffff' : '#2d3748';
  return adjustColorBrightness(color, theme==='light'?1.1:0.9);
}

/* =========================
   Grid / Snap / Zoom
========================= */
function setupGridVisualization(){
  createGridLines();
  window.addEventListener('resize', createGridLines);
}
function createGridLines(){
  let gridOverlay = document.getElementById('grid-overlay');
  if (!gridOverlay){ gridOverlay = document.createElement('div'); gridOverlay.id='grid-overlay'; gridOverlay.className='grid-overlay'; canvas.appendChild(gridOverlay); }
  gridOverlay.innerHTML = '';
  const rect = canvas.getBoundingClientRect();
  
  // Calculate grid spacing in screen coordinates, accounting for zoom and offset
  const screenGridSize = gridSize * zoom;
  
  // Start from the canvas offset and create grid lines
  const startX = canvasOffset.x % screenGridSize;
  const startY = canvasOffset.y % screenGridSize;
  
  for(let x = startX; x <= rect.width; x += screenGridSize){
    const l = document.createElement('div'); 
    l.className='grid-line vertical'; 
    l.style.left = x + 'px'; 
    gridOverlay.appendChild(l);
  }
  for(let y = startY; y <= rect.height; y += screenGridSize){
    const l = document.createElement('div'); 
    l.className='grid-line horizontal'; 
    l.style.top = y + 'px'; 
    gridOverlay.appendChild(l);
  }
}
function toggleGrid(){
  showGrid = !showGrid;
  const overlay = document.getElementById('grid-overlay');
  overlay && overlay.classList.toggle('show', showGrid);
  notify(`Grid ${showGrid?'ON':'OFF'}`);
}
function setupSnapping(){
  if (!snapIndicators.length){
    for (let i=0;i<10;i++){ const d=document.createElement('div'); d.className='snap-indicator'; canvas.appendChild(d); snapIndicators.push(d); }
  }
  if (!snapLines.length){
    for (let i=0;i<4;i++){ const l=document.createElement('div'); l.className='grid-snap-line'; canvas.appendChild(l); snapLines.push(l); }
  }
}
function worldToScreen(x,y){ return { x: x*zoom + canvasOffset.x, y: y*zoom + canvasOffset.y }; }
function screenToWorld(x,y){ return { x: (x - canvas.getBoundingClientRect().left - canvasOffset.x)/zoom, y: (y - canvas.getBoundingClientRect().top - canvasOffset.y)/zoom }; }
function getSnapPosition(x,y){ // x,y in world coords
  let sx = x, sy = y; const snapDist = 8/zoom;
  if (snapToGrid){
    const gx = Math.round(x/gridSize)*gridSize, gy = Math.round(y/gridSize)*gridSize;
    if (Math.abs(x-gx)<snapDist){ sx=gx; showSnapLineAt(worldToScreen(gx,0).x,'v'); }
    if (Math.abs(y-gy)<snapDist){ sy=gy; showSnapLineAt(worldToScreen(0,gy).y,'h'); }
  }
  if (snapToTiles){
    tiles.forEach(t=>{
      if (t===selectedTile) return;
      const tx = +t.dataset.baseX||0, ty=+t.dataset.baseY||0, tw=t.offsetWidth, th=t.offsetHeight;
      const edges = [{x:tx},{x:tx+tw},{y:ty},{y:ty+th}];
      edges.forEach(e=>{
        if (e.x!==undefined && Math.abs(x-e.x)<snapDist){ sx=e.x; showSnapLineAt(worldToScreen(e.x,0).x,'v'); }
        if (e.y!==undefined && Math.abs(y-e.y)<snapDist){ sy=e.y; showSnapLineAt(worldToScreen(0,e.y).y,'h'); }
      });
      const cx = tx+tw/2, cy=ty+th/2;
      if (Math.abs(x-cx)<snapDist){ sx=cx; }
      if (Math.abs(y-cy)<snapDist){ sy=cy; }
    });
  }
  showSnapDot(worldToScreen(sx,sy));
  return {x:sx,y:sy};
}
function showSnapDot(p){
  const ind = snapIndicators.find(el=>!el.classList.contains('show'));
  if (!ind) return;
  ind.style.left = p.x+'px'; ind.style.top = p.y+'px'; ind.classList.add('show');
  setTimeout(()=>ind.classList.remove('show'), 180);
}
function showSnapLineAt(pos,orient){
  const l = snapLines.find(el=>!el.classList.contains('show'));
  if (!l) return;
  if (orient==='v'){ l.style.left=pos+'px'; l.style.top='0px'; l.style.width='1px'; l.style.height='100%'; l.className='grid-snap-line vertical show'; }
  else { l.style.top=pos+'px'; l.style.left='0px'; l.style.height='1px'; l.style.width='100%'; l.className='grid-snap-line horizontal show'; }
  setTimeout(()=>l.classList.remove('show'), 220);
}
function clearSnapIndicators(){ 
  // Clear all snap indicators
  snapIndicators.forEach(i=>i.classList.remove('show')); 
  snapLines.forEach(l=>l.classList.remove('show')); 
  
  // Also clear any remaining snap indicators
  document.querySelectorAll('.snap-indicator').forEach(i => i.classList.remove('show'));
  document.querySelectorAll('.grid-snap-line').forEach(l => l.classList.remove('show'));
  
  // Clear any snap dots that might be lingering
  document.querySelectorAll('.snap-dot').forEach(d => d.remove());
  
  // Force hide all snap-related elements
  document.querySelectorAll('[class*="snap"]').forEach(el => {
    if (el.classList.contains('show')) {
      el.classList.remove('show');
    }
  });
}

function zoomIn(){ setZoom(zoom*1.1); }
function zoomOut(){ setZoom(zoom/1.1); }
function zoomReset(){ setZoom(1); }
function setZoom(val){
  zoom = Math.min(3, Math.max(0.25, val));
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
  
  // Recreate grid to maintain alignment
  if (showGrid) {
    createGridLines();
  }
  
  document.querySelectorAll('.toolbar .tool-row button')[1]?.setAttribute('title', `Reset Zoom (${Math.round(zoom*100)}%)`);
}

/* =========================
   Autosave / Realtime
========================= */
function setupAutoSave(){
  autoSaveTimer = setInterval(()=>{ if (isDirty && currentGraph && Date.now()-lastSaveTime>15000) autoSaveGraph(); }, 15000);
}
function setupRealtimeUpdates(){
  setInterval(()=>{ if (pendingUpdates.length && currentGraph) sendRealtimeUpdates(); }, 2000);
}
function markAsDirty(){ isDirty=true; lastSaveTime=Date.now(); pushHistory(); }
async function autoSaveGraph(){
  if (!currentGraph || !isDirty) return;
  const indicator = document.getElementById('autoSaveIndicator');
  const text = document.getElementById('autoSaveText');
  try{
    indicator.classList.add('show','saving'); text.textContent='Saving...';
    const token = localStorage.getItem('flowpad_token');
    const data = serializeGraph();
    
    if (token) {
      // Try to save to server if authenticated
      try {
        const res = await fetch(`/api/graphs/${currentGraph.id}`,{
          method:'PUT',
          headers:{'Content-Type':'application/json','Authorization':`Bearer ${token}`},
          body: JSON.stringify({ title: currentGraph.title, data })
        });
        if (res.ok) {
          isDirty=false; lastSaveTime=Date.now();
          indicator.classList.remove('saving'); indicator.classList.add('saved');
          text.textContent = `Saved to server at ${new Date().toLocaleTimeString()}`;
          setTimeout(()=>indicator.classList.remove('show','saved'), 2000);
          return;
        }
      } catch (serverError) {
        console.log('Server save failed, falling back to local storage');
      }
    }
    
    // Fallback to localStorage (demo mode)
    try {
      localStorage.setItem(`flowpad_graph_${currentGraph.id}`, JSON.stringify({
        title: currentGraph.title,
        data: data,
        updated_at: Date.now()
      }));
      isDirty=false; lastSaveTime=Date.now();
      indicator.classList.remove('saving'); indicator.classList.add('saved');
      text.textContent = `Saved locally at ${new Date().toLocaleTimeString()}`;
      setTimeout(()=>indicator.classList.remove('show','saved'), 2000);
    } catch (localError) {
      throw new Error('Local save failed');
    }
  }catch(e){
    indicator.classList.remove('saving'); indicator.classList.add('error');
    text.textContent='Save failed'; setTimeout(()=>indicator.classList.remove('show','error'), 3000);
  }
}
function scheduleSave(){ 
  markAsDirty(); 
  // Don't auto-save while actively editing
  if (!selectedTile && !selectedConnection) {
    clearTimeout(window.saveTimeout); 
    window.saveTimeout=setTimeout(()=>{ if(isDirty) autoSaveGraph(); }, 700); 
  }
}

function saveOnUnselect(){
  if (isDirty) {
    clearTimeout(window.saveTimeout);
    window.saveTimeout = setTimeout(() => { if(isDirty) autoSaveGraph(); }, 100);
  }
}
function addPendingUpdate(type, data){ pendingUpdates.push({type,data,timestamp:Date.now()}); }
function sendRealtimeUpdates(){
  if (!currentGraph || !pendingUpdates.length) return;
  const updates=[...pendingUpdates]; pendingUpdates=[];
  fetch(`/api/graphs/${currentGraph.id}/realtime`,{
    method:'POST',
    headers:{'Content-Type':'application/json','Authorization':`Bearer ${localStorage.getItem('flowpad_token')}`},
    body: JSON.stringify({ updates })
  }).catch(()=>{ pendingUpdates.unshift(...updates); });
}
function forceSave(){ autoSaveGraph(); }

/* =========================
   Canvas interactions
========================= */
function setupCanvas(){
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('contextmenu', onContextMenu);
  document.addEventListener('click', e => { if (!ctxMenu.contains(e.target)) ctxMenu.classList.remove('show'); });
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
}
function onMouseDown(e){
  const tile = e.target.closest('.tile');
  // Support both Alt key and Option key (Mac) for connections
  if (tile && (e.altKey || e.metaKey)){ startConnectionFromTile(tile, e); return; }
  if (e.target.classList.contains('connection-dot')){ startConnectionFromPort(e.target, e); return; }
  if (tile && e.target.tagName !== 'TEXTAREA'){ startDragging(e, tile); }
  else if (!tile){ startPanning(e); }
}
function onMouseMove(e){
  if (isConnecting && connectionStart) updateConnectionPreview(e);
  else if (isDragging && selectedTile) updateDragging(e);
  else if (isPanning) updatePanning(e);
}
function onMouseUp(e){
  if (isConnecting) finishConnection(e);
  if (isDragging) finishDragging();
  isPanning=false;
}
function onContextMenu(e){
  e.preventDefault();
  const tile = e.target.closest('.tile');
  ctxTargetTile = tile || null;
  openCtxMenu(e.clientX, e.clientY, tile);
}
function openCtxMenu(x,y,tile){
  ctxMenu.style.left = x+'px'; ctxMenu.style.top = y+'px';
  ctxMenu.classList.add('show');
}
function ctxAction(action) {
  if (!selectedTile) return;
  
  switch (action) {
    case 'edit':
      selectedTile.querySelector('.tile-content')?.focus();
      break;
    case 'color':
      openColorPopup(selectedTile, (c) => {
        selectedTile.style.backgroundColor = c;
        scheduleSave();
      });
      break;
    case 'shape':
      // Show shape options
      break;
    case 'duplicate':
      duplicateTile();
      break;
    case 'delete':
      deleteSelected();
      break;
  }
  
  // Hide context menu
  const ctxMenu = document.getElementById('ctxMenu');
  if (ctxMenu) ctxMenu.style.display = 'none';
}

/* Panning */
function startPanning(e){ isPanning=true; panStart.x=e.clientX; panStart.y=e.clientY; }
function updatePanning(e){
  const dx = e.clientX - panStart.x, dy = e.clientY - panStart.y;
  panStart.x = e.clientX; panStart.y = e.clientY;
  canvasOffset.x += dx; canvasOffset.y += dy;
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
  
  // Recreate grid to maintain alignment during panning
  if (showGrid) {
    createGridLines();
  }
}

/* Dragging */
function startDragging(e,tile){
  isDragging=true; selectedTile=tile; selectTile(tile);
  const w = screenToWorld(e.clientX, e.clientY);
  dragOffsetWorld.x = w.x - (+tile.dataset.baseX||0);
  dragOffsetWorld.y = w.y - (+tile.dataset.baseY||0);
}
function updateDragging(e){
  const w = screenToWorld(e.clientX, e.clientY);
  let x = w.x - dragOffsetWorld.x, y = w.y - dragOffsetWorld.y;
  const snap = getSnapPosition(x,y); x=snap.x; y=snap.y;
  
  // Use requestAnimationFrame for smooth updates
  if (!updateDragging.rafId) {
    updateDragging.rafId = requestAnimationFrame(() => {
      // Update tile position immediately for responsive feel
      selectedTile.dataset.baseX = x; 
      selectedTile.dataset.baseY = y;
      selectedTile.style.left = x+'px'; 
      selectedTile.style.top = y+'px';
      
      // Add updating class for visual feedback
      selectedTile.classList.add('tile-updating');
      
      // Re-render connections immediately for responsive feel
      renderConnections();
      
      // Update tile menu position to follow the tile
      updateTileMenuPosition();
      
      // Mark as dirty and schedule save
      addPendingUpdate('tile_move', { tileId:selectedTile.dataset.tileId, x,y });
      markAsDirty();
      
      updateDragging.rafId = null;
    });
  }
}
function finishDragging(){
  if (selectedTile) selectedTile.classList.remove('tile-updating');
  
  // Clean up requestAnimationFrame
  if (updateDragging.rafId) {
    cancelAnimationFrame(updateDragging.rafId);
    updateDragging.rafId = null;
  }
  
  selectedTile=null; isDragging=false; clearSnapIndicators();
}

/* Connections */
function toggleConnectMode(on){
  document.body.classList.toggle('connect-mode', on);
  document.getElementById('connectionMode').style.display = 'block';
  document.getElementById('modeConnect').classList.toggle('active', on);
  document.getElementById('modeNone').classList.toggle('active', !on);
}
function startConnectionFromTile(tile,e){
  isConnecting=true;
  const rect = tile.getBoundingClientRect(), cRect = canvas.getBoundingClientRect();
  connectionStart = {
    tile, fromPort: 'auto',
    sx: rect.left + rect.width/2 - cRect.left,
    sy: rect.top + rect.height/2 - cRect.top
  };
}
function startConnectionFromPort(portEl,e){
  isConnecting=true;
  const tile = portEl.closest('.tile');
  const cRect = canvas.getBoundingClientRect();
  const rx = portEl.getBoundingClientRect();
  connectionStart = {
    tile, fromPort: portEl.dataset.port,
    sx: rx.left + rx.width/2 - cRect.left,
    sy: rx.top + rx.height/2 - cRect.top
  };
}
function updateConnectionPreview(e){
  const prev = document.querySelector('.connection-preview');
  prev && prev.remove();
  const rect = canvas.getBoundingClientRect();
  const endX = e.clientX - rect.left, endY = e.clientY - rect.top;
  const preview = createConnectionSVG(connectionStart.sx, connectionStart.sy, endX, endY, true);
  preview.classList.add('connection-preview');
  canvasContent.appendChild(preview);
}
function finishConnection(e){
  const targetTile = e.target.closest('.tile');
  const preview = document.querySelector('.connection-preview'); preview && preview.remove();
  if (targetTile && targetTile!==connectionStart.tile){
    const ports = findOptimalPort(connectionStart.tile, targetTile, connectionStart.fromPort, null);
    const connection = {
      id:'conn_'+Date.now()+'_'+Math.floor(Math.random()*1000),
      fromTile: connectionStart.tile.dataset.tileId,
      fromDot: ports.fromPort.type,
      toTile: targetTile.dataset.tileId,
      toDot:   ports.toPort.type,
      color: getRandomConnectionColor(),
      style: 'solid',
      marker: 'arrow'
    };
    connections.push(connection);
    addPendingUpdate('connection_create', connection);
    markAsDirty();
    renderCanvas();
    notify('Connection created');
  }
  isConnecting=false; connectionStart=null;
}

function getRandomConnectionColor(){
  const colors = ['#3b82f6','#ef4444','#10b981','#f59e0b','#8b5cf6','#ec4899','#06b6d4','#84cc16','#f97316','#6366f1'];
  return colors[Math.floor(Math.random()*colors.length)];
}

function findOptimalPort(fromTile, toTile, fromDotType, toDotType){
  const fr = getTileWorldRect(fromTile), tr = getTileWorldRect(toTile);
  const fromCenter = {x:fr.x+fr.w/2, y:fr.y+fr.h/2};
  const toCenter   = {x:tr.x+tr.w/2, y:tr.y+tr.h/2};
  let f=fromDotType, t=toDotType;
  if (!f || !t){
    const dx = toCenter.x - fromCenter.x, dy = toCenter.y - fromCenter.y;
    if (Math.abs(dx) > Math.abs(dy)){ f = dx>0?'output':'input'; t = dx>0?'input':'output'; }
    else { f = dy>0?'bottom':'top'; t = dy>0?'top':'bottom'; }
  }
  const fp = portCoords(fromTile, f), tp = portCoords(toTile, t);
  return { fromPort:{x:fp.x,y:fp.y,type:f}, toPort:{x:tp.x,y:tp.y,type:t} };
}
function getTileWorldRect(tile){ return { x:+tile.dataset.baseX||0, y:+tile.dataset.baseY||0, w:tile.offsetWidth, h:tile.offsetHeight }; }
function portCoords(tile, port){
  const r = getTileWorldRect(tile);
  switch(port){
    case 'input':  return { x:r.x, y:r.y+r.h/2 };
    case 'output': return { x:r.x+r.w, y:r.y+r.h/2 };
    case 'top':    return { x:r.x+r.w/2, y:r.y };
    case 'bottom': return { x:r.x+r.w/2, y:r.y+r.h };
    default:       return { x:r.x+r.w/2, y:r.y+r.h/2 };
  }
}

/* =========================
   Tiles
========================= */
function createTile(x=100,y=100,title='',content='',id=null,shape='rectangle',preset='custom',color='#ffffff'){
  const t=document.createElement('div');
  t.className = `tile ${shape}`;
  t.dataset.tileId = id || ('tile_'+Date.now()+'_'+Math.floor(Math.random()*1000));
  t.dataset.baseX = x; t.dataset.baseY = y;
  t.dataset.shape = shape; t.dataset.presetType = preset;
  t.style.left=x+'px'; t.style.top=y+'px'; t.style.width='200px'; t.style.height='120px'; t.style.backgroundColor=color;
  t.innerHTML = `
    <div class="shape-palette">
      <div class="shape-option" title="Rounded" data-shape="rounded">Round</div>
      <div class="shape-option" title="Circle" data-shape="circular">Circle</div>
      <div class="shape-option" title="Diamond" data-shape="diamond">Diamond</div>
      <div class="shape-option" title="Hex" data-shape="hexagon">Hex</div>
      <div class="shape-option" title="Triangle" data-shape="triangle">Triangle</div>
      <div class="shape-option" title="Parallelogram" data-shape="parallelogram">Para</div>
    </div>
    <!-- Color palette removed - now in toolbar -->
    <textarea class="tile-title" placeholder="Title">${title||''}</textarea>
    <textarea class="tile-content" placeholder="Content">${content||''}</textarea>
    <div class="connection-dot input"  data-port="input"></div>
    <div class="connection-dot output" data-port="output"></div>
    <div class="connection-dot top"    data-port="top"></div>
    <div class="connection-dot bottom" data-port="bottom"></div>
  `;
  t.querySelectorAll('.shape-option').forEach(el=>el.addEventListener('click',()=>setTileShape(t, el.dataset.shape)));
  t.querySelectorAll('textarea').forEach(inp=>inp.addEventListener('input', scheduleSave));
  t.addEventListener('click', ()=>selectTile(t));
  t.addEventListener('dblclick', (e)=>openTileToolbar(t, {x:e.clientX,y:e.clientY}));
  t.querySelectorAll('.connection-dot').forEach(el=>el.addEventListener('mousedown', (e)=>startConnectionFromPort(el,e)));
  return t;
}
function addTile(){
  const rect = canvas.getBoundingClientRect();
  openPresets(rect.left + rect.width/2, rect.top + rect.height/2);
}
function setTileShape(tile,shape){
  // Preserve text content before changing shape
  const title = tile.querySelector('.tile-title')?.value || '';
  const content = tile.querySelector('.tile-content')?.value || '';
  
  tile.className = 'tile '+shape;
  tile.dataset.shape = shape;
  
  // Restore text content after shape change
  if (title) tile.querySelector('.tile-title').value = title;
  if (content) tile.querySelector('.tile-content').value = content;
  
  markAsDirty();
  scheduleSave();
}
function setTileColor(tile,color){
  tile.style.backgroundColor = color;
  markAsDirty();
  scheduleSave();
}
function selectTile(tile){
  tiles.forEach(t=>t.classList.remove('selected'));
  tile.classList.add('selected');
  selectedTile = tile;
  selectedConnection = null;
  
  // Add resize handles
  addResizeHandles(tile);
  
  openTileToolbar(tile);
}
function clearSelection(){
  tiles.forEach(t=>{
    t.classList.remove('selected');
    // Remove resize handles
    t.querySelectorAll('.resize-handle').forEach(h => h.remove());
  });
  selectedTile=null; selectedConnection=null;
  hideFloatingToolbars();
  
  // Save when unselecting
  saveOnUnselect();
}
function duplicateTile(tile){
  const x = (+tile.dataset.baseX||0)+20, y=(+tile.dataset.baseY||0)+20;
  const t2 = createTile(x,y,
    tile.querySelector('.tile-title').value,
    tile.querySelector('.tile-content').value,
    null,
    tile.dataset.shape,
    tile.dataset.presetType,
    tile.style.backgroundColor || '#ffffff'
  );
  
  // Copy dimensions from original tile
  if (tile.style.width) t2.style.width = tile.style.width;
  if (tile.style.height) t2.style.height = tile.style.height;
  
  tiles.push(t2); renderCanvas(); scheduleSave(); notify('Duplicated');
}
function deleteSelected(){
  if (selectedConnection){ 
    deleteConnection(selectedConnection.id); 
    clearSelection();
    return; 
  }
  if (!selectedTile) return;
  const id = selectedTile.dataset.tileId;
  selectedTile.remove();
  tiles = tiles.filter(t=>t.dataset.tileId!==id);
  connections = connections.filter(c=>c.fromTile!==id && c.toTile!==id);
  addPendingUpdate('tile_delete', {tileId:id});
  markAsDirty(); 
  clearSelection(); 
  renderCanvas(); 
  notify('Tile deleted');
}

/* Floating toolbar for tile & connection */
const floatTB = document.createElement('div'); floatTB.className='floating-toolbar'; document.body.appendChild(floatTB);
function hideFloatingToolbars(){ floatTB.classList.remove('show'); }
function openTileToolbar(tile, at=null, force=false, focusSection=null){
  if (!tile && !force) return;
  
  // Close other menus first
  closeAllTileMenus();
  
  const toolbar = document.getElementById('tileToolbar');
  if (!toolbar) return;
  
  const pos = at || { 
    x: (tile.getBoundingClientRect().left + tile.getBoundingClientRect().right) / 2,
    y: tile.getBoundingClientRect().top - 50 // Position farther from tile
  };
  
  toolbar.innerHTML = `
    <div class="toolbar-section">
      <div class="toolbar-section-title">Tile Actions</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="duplicateTile()" title="Duplicate">Copy</button>
        <button class="toolbar-button" onclick="deleteSelected()" title="Delete">Delete</button>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Shape</div>
      <div class="toolbar-dropdown">
        <button class="toolbar-dropdown-btn" onclick="toggleShapeDropdown()">${shapeIcon(tile?.dataset.shape || 'rectangle')} Shape ▼</button>
        <div class="toolbar-dropdown-content" id="shapeDropdown">
          ${['rectangle','rounded','circular','diamond','hexagon','triangle','parallelogram']
            .map(s=>`<div class="dropdown-item ${tile?.dataset.shape===s?'active':''}" onclick="changeTileShape('${s}')" data-shape="${s}">${shapeIcon(s)} ${s.charAt(0).toUpperCase() + s.slice(1)}</div>`).join('')}
        </div>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Color</div>
      <div class="toolbar-row color-options">
        ${['#ffffff','#fef3c7','#fde68a','#fca5a5','#c7d2fe','#bae6fd','#bbf7d0','#e9d5ff','#fecaca','#d1fae5']
          .map(c=>`<div class="color-option ${tile.style.backgroundColor===c?'selected':''}" onclick="setTileColor(selectedTile,'${c}')" style="background:${c}" title="Set color"></div>`).join('')}
      </div>
    </div>
  `;
  
  // Position the toolbar
  toolbar.style.left = pos.x + 'px';
  toolbar.style.top = pos.y + 'px';
  toolbar.classList.add('show');
  
  // Store reference to tile for color changes
  toolbar.dataset.tileId = tile.dataset.tileId;
}
function openConnectionToolbar(conn, at){
  selectedConnection = conn;
  
  const toolbar = document.getElementById('connectionToolbar');
  if (!toolbar) return;
  
  toolbar.innerHTML = `
    <div class="toolbar-section">
      <div class="toolbar-section-title">Connection</div>
      <div class="toolbar-row">
        <div class="toolbar-color" id="connColorPick" title="Color"></div>
        <button class="toolbar-button" onclick="changeLineStyle('solid')" title="Solid">—</button>
        <button class="toolbar-button" onclick="changeLineStyle('dashed')" title="Dashed">- -</button>
        <button class="toolbar-button" onclick="changeLineStyle('dotted')" title="Dotted">⋯</button>
        <button class="toolbar-button" onclick="changeLineStyle('dash-dot')" title="Dash-dot">-⋅-</button>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Head</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="changeConnectionMarker('arrow')" title="Arrow">➤</button>
        <button class="toolbar-button" onclick="changeConnectionMarker('line')" title="Line">—</button>
        <button class="toolbar-button" onclick="changeConnectionMarker('dot')" title="Dot">•</button>
        <button class="toolbar-button" onclick="changeConnectionMarker('diamond')" title="Diamond">Diamond</button>
        <button class="toolbar-button" onclick="deleteSelectedConnection()" title="Delete">Delete</button>
      </div>
    </div>
  `;
  
  // Position the toolbar
  toolbar.style.left = at.x + 'px';
  toolbar.style.top = at.y + 'px';
  toolbar.classList.add('show');
  
  // Add color picker functionality
  const colorBtn = toolbar.querySelector('#connColorPick');
  if (colorBtn) {
    colorBtn.onclick = () => openColorPopup(colorBtn, (c) => {
      conn.color = c;
      scheduleSave();
      renderCanvas();
    });
  }
}
function shapeIcon(s){ return ({rectangle:'Rect', rounded:'Round', circular:'Circle', diamond:'Diamond', hexagon:'Hex', triangle:'Triangle', parallelogram:'Para'})[s]||'Rect'; }

/* Color popup (secondary) */
function openColorPopup(anchorEl, onPick){
  const pop = document.createElement('div');
  pop.className='preset-popup'; // reuse styling
  pop.style.left = (anchorEl.getBoundingClientRect().left)+'px';
  pop.style.top  = (anchorEl.getBoundingClientRect().bottom+6)+'px';
  pop.innerHTML = `
    <div style="display:grid;grid-template-columns:repeat(10,1fr);gap:6px;">
      ${['#ffffff','#f8fafc','#e2e8f0','#cbd5e0','#94a3b8','#fef3c7','#fde68a','#fca5a5','#fda4af','#fbbf24','#86efac','#10b981','#93c5fd','#60a5fa','#a78bfa','#f472b6','#22d3ee','#f59e0b','#ef4444','#3b82f6']
       .map(c=>`<div style="width:22px;height:22px;border-radius:6px;border:1px solid var(--border-primary);background:${c};cursor:pointer" data-c="${c}"></div>`).join('')}
    </div>`;
  document.body.appendChild(pop);
  pop.classList.add('show');
  pop.querySelectorAll('[data-c]').forEach(el=>el.onclick=()=>{ onPick(el.dataset.c); document.body.removeChild(pop); });
  const close = (ev)=>{ if (!pop.contains(ev.target)){ document.body.removeChild(pop); document.removeEventListener('mousedown', close); } };
  setTimeout(()=>document.addEventListener('mousedown', close), 0);
}

/* =========================
   Presets / Templates
========================= */
function openPresets(cx=null, cy=null){
  // Use the existing preset tile modal instead of the missing presetPopup
  const modal = document.getElementById('presetTileModal');
  if (!modal) return;
  
  // Position the modal in the center of the screen
  modal.style.display = 'flex';
  modal.classList.add('show');
  
  // Set up click handlers for preset tiles
  const presetTiles = modal.querySelectorAll('.preset-tile');
  presetTiles.forEach(tile => {
    tile.onclick = () => {
      const type = tile.classList.contains('title') ? 'title' :
                   tile.classList.contains('notes') ? 'notes' :
                   tile.classList.contains('component') ? 'component' : 'custom';
      
      // Calculate center position for the new tile
      const r = canvas.getBoundingClientRect();
      const centerX = cx || (r.left + r.width / 2);
      const centerY = cy || (r.top + r.height / 2);
      
      // Convert screen coordinates to world coordinates
      const worldX = (centerX - r.left - canvasOffset.x) / zoom;
      const worldY = (centerY - r.top - canvasOffset.y) / zoom;
      
      addPresetTile(type, worldX, worldY);
      
      // Close the modal after creating the tile
      modal.classList.remove('show');
      modal.style.display = 'none';
      
      // Hide any floating toolbars
      hideFloatingToolbars();
    };
  });
  
  // Add click outside to close functionality
  modal.onclick = (e) => {
    if (e.target === modal) {
      modal.classList.remove('show');
      modal.style.display = 'none';
    }
  };
}
function addPresetTile(type, x, y){
  const presets = {
    title:     { title:'Title', content:'', shape:'rounded', color:'#ffffff' },
    notes:     { title:'Note', content:'Type your note…', shape:'rectangle', color:'#fff7ed' },
    component: { title:'Component', content:'• Input\n• Process\n• Output', shape:'hexagon', color:'#e0f2fe' },
    custom:    { title:'New tile', content:'', shape:'rectangle', color:'#ffffff' }
  };
  const p = presets[type] || presets.custom;
  const t = createTile(x,y,p.title,p.content,null,p.shape,type,p.color);
  tiles.push(t); renderCanvas(); scheduleSave(); notify(`${type[0].toUpperCase()+type.slice(1)} tile added`);
}

/* =========================
   Rendering / Connections
========================= */
function renderCanvas(){
  canvasContent.innerHTML='';
  // grid overlay (scaled with content)
  let gridOverlay = document.getElementById('grid-overlay');
  if (gridOverlay) canvasContent.appendChild(gridOverlay);
  // tiles
  tiles.forEach(t=>{
    const x=+t.dataset.baseX||0, y=+t.dataset.baseY||0;
    t.style.left = x+'px'; t.style.top = y+'px';
    canvasContent.appendChild(t);
  });
  renderConnections();
}
function createConnectionSVG(fromX, fromY, toX, toY, isPreview=false, connObj=null){
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.style.position='absolute'; svg.style.left='0'; svg.style.top='0'; svg.style.width='100%'; svg.style.height='100%';
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  const d = createSmartPath(fromX, fromY, toX, toY);
  path.setAttribute('d', d);
  path.setAttribute('fill','none');
  const color = connObj?.color || (isPreview?'#999':'var(--accent-primary)');
  path.setAttribute('stroke', color);
  path.setAttribute('stroke-width', isPreview?'2':'3');
  if (!isPreview){
    const marker = connObj?.marker || 'arrow';
    path.setAttribute('marker-end', marker==='line' ? '' : `url(#${marker==='dot'?'dotmarker':marker==='diamond'?'diamondmarker':'arrowhead'})`);
    const style = connObj?.style || 'solid';
    const dash = {solid:'',dashed:'5,5',dotted:'2,2', 'dash-dot':'10,2,2,2'}[style] || '';
    if (dash) path.setAttribute('stroke-dasharray', dash);
    path.classList.add('connection-line');
    path.addEventListener('click', (e)=>{
      e.stopPropagation();
      selectedConnection = connObj;
      openConnectionToolbar(connObj, {x:e.clientX, y:e.clientY});
    });
    path.addEventListener('dblclick', (e)=>{ e.stopPropagation(); deleteConnection(connObj.id); });
  }
  svg.appendChild(path);
  return svg;
}
function renderConnections(){
  let svg = document.getElementById('connections-svg-live');
  if (!svg){
    svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.id='connections-svg-live';
    svg.style.position='absolute'; svg.style.left='0'; svg.style.top='0'; svg.style.width='100%'; svg.style.height='100%'; svg.style.zIndex='5';
    canvasContent.appendChild(svg);
  }
  // clear previous
  while (svg.firstChild) svg.removeChild(svg.firstChild);
  // draw
  const groups = {};
  connections.forEach(c=>{ const k=`${c.fromTile}__${c.toTile}`; (groups[k] ||= []).push(c); });
  Object.values(groups).forEach(group=>{
    group.forEach((conn, idx)=>{
      const fromTile = tiles.find(t=>t.dataset.tileId===conn.fromTile);
      const toTile   = tiles.find(t=>t.dataset.tileId===conn.toTile);
      if (!fromTile || !toTile) return;
      const {fromPort,toPort} = findOptimalPort(fromTile,toTile,conn.fromDot,conn.toDot);
      // screen coords
      const s1 = worldToScreen(fromPort.x, fromPort.y);
      const s2 = worldToScreen(toPort.x, toPort.y);
      // offset for parallel lines
      const dx = s2.x - s1.x, dy = s2.y - s1.y, len = Math.max(1, Math.hypot(dx,dy));
      const ox = (-dy/len) * (idx? (idx-0.5)*8 : 0), oy = (dx/len) * (idx? (idx-0.5)*8 : 0);
      const path = createConnectionSVG(s1.x+ox, s1.y+oy, s2.x+ox, s2.y+oy, false, conn);
      svg.appendChild(path.firstChild);
    });
  });
}
function createSmartPath(fromX,fromY,toX,toY){
  // Create S-shaped path with 90-degree angles and rounded bends
  const halfTileWidth = 100; // Half of typical tile width
  const halfTileHeight = 60; // Half of typical tile height
  
  const dx = Math.abs(toX - fromX);
  const dy = Math.abs(toY - fromY);
  
  let path = `M ${fromX} ${fromY}`;
  
  if (dx > dy) {
    // More horizontal than vertical - S-shape with horizontal first
    const midX1 = fromX + (toX > fromX ? halfTileWidth : -halfTileWidth);
    const midX2 = toX + (toX > fromX ? -halfTileWidth : halfTileWidth);
    const midY = fromY + (toY - fromY) / 2;
    
    path += ` L ${midX1} ${fromY}`;
    path += ` L ${midX1} ${midY}`;
    path += ` L ${midX2} ${midY}`;
    path += ` L ${midX2} ${toY}`;
    path += ` L ${toX} ${toY}`;
  } else {
    // More vertical than horizontal - S-shape with vertical first
    const midY1 = fromY + (toY > fromY ? halfTileHeight : -halfTileHeight);
    const midY2 = toY + (toY > fromY ? -halfTileHeight : halfTileHeight);
    const midX = fromX + (toX - fromX) / 2;
    
    path += ` L ${fromX} ${midY1}`;
    path += ` L ${midX} ${midY1}`;
    path += ` L ${midX} ${midY2}`;
    path += ` L ${toX} ${midY2}`;
    path += ` L ${toX} ${toY}`;
  }
  
  return path;
}
function deleteConnection(id){
  const i = connections.findIndex(c=>c.id===id);
  if (i>-1){ connections.splice(i,1); addPendingUpdate('connection_delete',{connectionId:id}); markAsDirty(); renderCanvas(); notify('Connection deleted'); }
}

/* =========================
   Tabs / Graphs
========================= */
function createTab(graph){
  const tab = document.createElement('div');
  tab.className='tab'; tab.dataset.graphId = graph.id;
  tab.innerHTML = `${graph.title||'Untitled'} <button class="tab-close" title="Close tab">×</button>`;
  tab.addEventListener('click', (e)=>{ if (!e.target.classList.contains('tab-close')) switchToTab(graph.id); });
  tab.querySelector('.tab-close').addEventListener('click', (e)=>{ e.stopPropagation(); closeTab(graph.id); });
  openTabs.push({id:graph.id, element:tab, graph});
  tabContainer.appendChild(tab);
  return tab;
}
function closeTab(id){
  const i=openTabs.findIndex(t=>t.id===id); if (i===-1) return;
  openTabs[i].element.remove(); openTabs.splice(i,1);
  if (activeTabId===id){ if (openTabs.length) switchToTab(openTabs[0].id); else { activeTabId=null; currentGraph=null; tiles=[]; connections=[]; renderCanvas(); document.getElementById('shareSection').style.display='none'; } }
}
function switchToTab(id){
  const tab=openTabs.find(t=>t.id===id); if (!tab) return;
  openTabs.forEach(t=>t.element.classList.remove('active')); tab.element.classList.add('active');
  activeTabId=id; loadGraph(tab.graph, true); centerCanvas();
}
async function loadGraphs(){
  const token = localStorage.getItem('flowpad_token');
  const res = await fetch('/api/graphs',{ headers:{Authorization:`Bearer ${token}`} }).catch(()=>null);
  if (!res || !res.ok){ // No demo graph creation
    console.log('Failed to load graphs from server');
    return;
  }
  const data = await res.json();
  renderGraphList(data.filter(g=>g.type==='own'), 'ownGraphs');
  renderGraphList(data.filter(g=>g.type==='shared'), 'sharedGraphs');
}
function renderGraphList(list, target){
  const container = (target==='sharedGraphs' ? document.getElementById('sharedGraphsContent') : document.getElementById(target));
  container.innerHTML='';
  list.forEach(g=>{
    const item=document.createElement('div');
    item.className='graph-item'; item.dataset.graphId=g.id;
    item.draggable = true;
    item.innerHTML=`<div class="graph-title">${g.title}</div>
                    <div class="graph-meta">Updated: ${new Date(g.updated_at||Date.now()).toLocaleString()}</div>
                    <button class="graph-delete" onclick="deleteGraph('${g.id}')" title="Delete graph">×</button>`;
    
    // Click to load graph
    item.addEventListener('click', (e)=>{ if (!e.target.classList.contains('graph-delete')) loadGraph(g); });
    
    // Drag and drop functionality
    item.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', g.id);
      e.dataTransfer.setData('application/json', JSON.stringify(g));
      item.classList.add('dragging');
    });
    
    item.addEventListener('dragend', () => {
      item.classList.remove('dragging');
    });
    
    container.appendChild(item);
  });
}
function loadGraph(graph, skipTab=false){
  tiles=[]; connections=[]; canvasContent.innerHTML='';
  currentGraph = graph;
  (graph.data?.tiles||[]).forEach(t=>{
    const tile = createTile(t.x,t.y,t.title,t.content,t.id,t.shape||'rectangle',t.preset||'custom',t.color||'#ffffff');
    
    // Set custom dimensions if they exist in the saved data
    if (t.width) tile.style.width = t.width + 'px';
    if (t.height) tile.style.height = t.height + 'px';
    
    tiles.push(tile);
  });
  connections = graph.data?.connections || [];
  if (!openTabs.find(t=>t.id===graph.id)) createTab(graph);
  if (!skipTab) switchToTab(graph.id);
  document.getElementById('shareSection').style.display='block';
  renderCanvas(); isDirty=false; updateTileColorsForTheme(document.documentElement.getAttribute('data-theme'));
  pushHistory(true);
}
function deleteGraph(id){
  if (!confirm('Delete this graph?')) return;
  fetch(`/api/graphs/${id}`,{method:'DELETE', headers:{Authorization:`Bearer ${localStorage.getItem('flowpad_token')}`}})
    .then(r=>{ if (!r.ok) throw new Error(); notify('Deleted'); loadGraphs(); if (currentGraph?.id===id){ currentGraph=null; tiles=[]; connections=[]; renderCanvas(); }})
    .catch(()=>notify('Failed to delete','error'));
}
async function createNewGraph(){
  const modal = document.getElementById('newGraphModal');
  const input = document.getElementById('newGraphTitle');
  input.value=''; modal.classList.add('show'); input.focus();
  input.onkeydown = (e)=>{ if (e.key==='Enter') confirmNewGraph(); else if (e.key==='Escape') closeNewGraphModal(); };
  modal.onclick = (e)=>{ if (e.target===modal) closeNewGraphModal(); };
}
function closeNewGraphModal(){ document.getElementById('newGraphModal').classList.remove('show'); }
async function confirmNewGraph(){
  const title = document.getElementById('newGraphTitle').value.trim() || 'Untitled';
  const token = localStorage.getItem('flowpad_token');
  const res = await fetch('/api/graphs',{
    method:'POST',
    headers:{'Content-Type':'application/json', Authorization:`Bearer ${token}`},
    body: JSON.stringify({ title, data:{ tiles:[], connections:[] } })
  }).catch(()=>null);
  if (res && res.ok){
    const g = await res.json(); await loadGraphs(); loadGraph(g); closeNewGraphModal(); notify('Graph created');
  }else{
    // local fallback
    const g = { id:'local_'+Date.now(), title, updated_at:Date.now(), data:{ tiles:[], connections:[] }, type:'own' };
    renderGraphList([g], 'ownGraphs'); loadGraph(g); closeNewGraphModal(); notify('Graph created (local)');
  }
}

/* =========================
   Inbox / Sharing / Presence
========================= */
async function loadInbox(){
  const token = localStorage.getItem('flowpad_token');
  const res = await fetch('/api/graphs/inbox', { headers:{Authorization:`Bearer ${token}`} }).catch(()=>null);
  if (res && res.ok) renderInbox(await res.json());
  else document.getElementById('inboxContent').innerHTML = '<div style="text-align:center;color:var(--text-secondary);padding:20px;">No pending invitations</div>';
}
function renderInbox(items){
  const container=document.getElementById('inboxContent'); container.innerHTML='';
  if (!items?.length){
    container.innerHTML='<div style="text-align:center;color:var(--text-secondary);padding:20px;">No pending invitations</div>'; return;
  }
  items.forEach(it=>{
    const el=document.createElement('div');
    el.className=`inbox-item ${it.status||'pending'}`;
    el.innerHTML=`<div class="inbox-title">${it.graphTitle}</div>
      <div class="inbox-meta">From: ${it.sharerName} • ${new Date(it.sharedAt).toLocaleString()}</div>
      ${it.status==='pending'?`<div class="inbox-actions">
        <button class="inbox-btn accept" onclick="respondToInvitation('${it.id}','accept')">Accept</button>
        <button class="inbox-btn reject" onclick="respondToInvitation('${it.id}','reject')">Reject</button></div>`:''}`;
    container.appendChild(el);
  });
}
async function respondToInvitation(id, action){
  const res = await fetch(`/api/graphs/inbox/${id}/${action}`, {method:'POST', headers:{Authorization:`Bearer ${localStorage.getItem('flowpad_token')}`}}).catch(()=>null);
  if (res && res.ok){ notify(`Invitation ${action}ed`); loadInbox(); if(action==='accept') loadGraphs(); }
  else notify(`Failed to ${action} invitation`,'error');
}
function shareGraph(){
  if (!currentGraph) return;
  const email = document.getElementById('shareEmail').value.trim();
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return notify('Invalid email','error');
  fetch(`/api/graphs/${currentGraph.id}/share`,{
    method:'POST',
    headers:{'Content-Type':'application/json', Authorization:`Bearer ${localStorage.getItem('flowpad_token')}`},
    body: JSON.stringify({ email })
  }).then(r=>{ notify(r.ok?'Shared':'Share failed', r.ok?'success':'error'); if (r.ok) document.getElementById('shareEmail').value=''; })
  .catch(()=>notify('Share failed','error'));
}
function addShareEmailListener(){
  const el=document.getElementById('shareEmail'); if (!el) return;
  el.addEventListener('input', ()=>{/* button enabled by HTML5 pattern; noop */});
}
function initializePermissionSelector(){
  document.querySelectorAll('.permission-option').forEach(opt=>{
    opt.addEventListener('click', ()=>{
      document.querySelectorAll('.permission-option').forEach(o=>o.classList.remove('selected'));
      opt.classList.add('selected');
      const input = opt.querySelector('input[type="radio"]'); if (input) input.checked=true;
    });
  });
}
function loadCollaborators(){
  // Try API; else demo presence
  fetch(`/api/graphs/${currentGraph?.id||'none'}/collaborators`, { headers:{Authorization:`Bearer ${localStorage.getItem('flowpad_token')}`} })
    .then(r=>r.ok?r.json():Promise.reject())
    .then(showCollaborators)
    .catch(()=>showCollaborators([{email:'alex@example.com',name:'Alex',status:'online'},{email:'sam@example.com',name:'Sam',status:'away'}]));
}
function showCollaborators(list){
  const wrap = document.getElementById('collaboratorsList');
  const cnt = document.getElementById('collaboratorsContent');
  document.getElementById('collaboratorsCount').textContent = list.length;
  cnt.innerHTML='';
  list.forEach(u=>{
    const item=document.createElement('div'); item.className='collaborator-item';
    item.innerHTML=`<div class="collaborator-avatar">${(u.name||u.email||'?').slice(0,2).toUpperCase()}</div>
      <div class="collaborator-name">${u.name||u.email}</div>
      <div class="collaborator-status ${u.status==='online'?'status-online':u.status==='away'?'status-away':'status-offline'}"></div>`;
    cnt.appendChild(item);
  });
  wrap.classList.add('show');
}
function addCacheStatusButton(){
  // Updates cache/sync status and online/offline
  window.addEventListener('online', ()=>notify('Online','success'));
  window.addEventListener('offline', ()=>notify('Offline','warn'));
}
function showCacheStatus(){
  const status = navigator.onLine ? 'Online' : 'Offline';
  const queued = pendingUpdates.length;
  notify(`Status: <b>${status}</b><div class="small">Pending updates: ${queued}</div>`, navigator.onLine ? 'success' : 'warn', 2500);
}

/* =========================
   Import / Export / Versioning
========================= */
function serializeGraph(){
  return {
    tiles: tiles.map(t=>({
      id:t.dataset.tileId, x:+t.dataset.baseX||0, y:+t.dataset.baseY||0,
      title:t.querySelector('.tile-title').value||'',
      content:t.querySelector('.tile-content').value||'',
      color:t.style.backgroundColor || '#ffffff',
      shape:t.dataset.shape||'rectangle',
      preset:t.dataset.presetType||'custom',
      width:parseInt(t.style.width) || 200,
      height:parseInt(t.style.height) || 120
    })),
    connections:[...connections]
  };
}
function exportJSON(){
  const data = serializeGraph();
  const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=(currentGraph?.title||'diagram')+'.json'; a.click();
  URL.revokeObjectURL(url); notify('Exported JSON');
}
// Import file event listener will be set up in init function

/* Undo / Redo */
function pushHistory(init=false){
  const snapshot = JSON.stringify(serializeGraph());
  if (init || !historyStack.length || historyStack[historyStack.length-1]!==snapshot){
    historyStack.push(snapshot); if (!init) futureStack = []; // clear redo
  }
}
function undo(){
  if (historyStack.length<=1) return;
  const cur = historyStack.pop();
  futureStack.push(cur);
  const prev = JSON.parse(historyStack[historyStack.length-1]);
  restoreFrom(prev);
}
function redo(){
  if (!futureStack.length) return;
  const next = JSON.parse(futureStack.pop());
  historyStack.push(JSON.stringify(next));
  restoreFrom(next);
}
function restoreFrom(d){
  tiles=[]; connections=[];
  (d.tiles||[]).forEach(t=>{
    const tile = createTile(t.x,t.y,t.title,t.content,t.id,t.shape||'rectangle',t.preset||'custom',t.color||'#ffffff');
    
    // Restore custom dimensions if they exist
    if (t.width) tile.style.width = t.width + 'px';
    if (t.height) tile.style.height = t.height + 'px';
    
    tiles.push(tile);
  });
  connections=d.connections||[];
  renderCanvas();
}

/* =========================
   Keyboard Shortcuts
========================= */
function setupKeyboardShortcuts(){
  document.addEventListener('keydown', (e)=>{
    if (e.ctrlKey && e.key.toLowerCase()==='s'){ e.preventDefault(); forceSave(); }
    else if (e.ctrlKey && e.key.toLowerCase()==='e'){ e.preventDefault(); exportJSON(); }
    else if (e.ctrlKey && e.key.toLowerCase()==='i'){ e.preventDefault(); document.getElementById('importFile').click(); }
    else if (e.ctrlKey && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
    else if (e.ctrlKey && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); }
    else if (e.key==='Delete' || e.key==='Backspace'){ if (selectedTile || selectedConnection){ e.preventDefault(); deleteSelected(); } }
    else if (e.key.toLowerCase()==='n' && !e.target.matches('input, textarea, [contenteditable]')){ addTile(); }
    else if (e.key.toLowerCase()==='p'){ openPresets(); }
    else if (e.key.toLowerCase()==='g'){ toggleGrid(); }
    else if (e.key.toLowerCase()==='t'){ toggleSnapTiles(document.querySelector('.snap-tiles-btn')); }
    else if (e.key==='+'){ zoomIn(); }
    else if (e.key==='-'){ zoomOut(); }
    else if (e.key==='0'){ zoomReset(); }
    else if (e.shiftKey && e.key.toLowerCase()==='g'){ toggleSnapGrid(document.querySelector('.snap-grid-btn')); }
  });
}
function toggleSnapGrid(btn){ snapToGrid = !snapToGrid; btn?.classList.toggle('active', snapToGrid); notify(`Snap to grid ${snapToGrid?'ON':'OFF'}`); }
function toggleSnapTiles(btn){ snapToTiles = !snapToTiles; btn?.classList.toggle('active', snapToTiles); notify(`Snap to tiles ${snapToTiles?'ON':'OFF'}`); }

/* =========================
   Auth / User
========================= */
async function checkAuth(){
  const token = localStorage.getItem('flowpad_token');
  const user = localStorage.getItem('flowpad_user');
  currentUser = user ? JSON.parse(user) : { name:'User' };
  document.getElementById('userName').textContent = currentUser.name || 'User';
  if (!token) return; // continue in demo mode if no token
  const ok = await fetch('/api/graphs', { headers:{Authorization:`Bearer ${token}`} }).then(r=>r.ok).catch(()=>false);
  if (!ok){ /* optionally redirect */ }
}
function signOut(){ localStorage.clear(); window.location.reload(); }

/* =========================
   AI Suggestions (optional backend)
========================= */
function toggleAIPanel(){ document.getElementById('aiPanel').classList.toggle('show'); }
async function getAISuggestions(){
  if (!currentGraph || !selectedTile) return notify('Select a tile first','error');
  const input = document.getElementById('aiInput').value.trim(); if (!input) return notify('Type a prompt','error');
  const btn = document.getElementById('aiBtn'), text = document.getElementById('aiBtnText'); btn.disabled=true; text.innerHTML='<span class="loading"></span>Working...';
  try{
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch('/api/ai-suggestions',{
      method:'POST',
      headers:{'Content-Type':'application/json','Authorization':`Bearer ${token}`},
      body: JSON.stringify({
        prompt: input,
        targetTile:{ id:selectedTile.dataset.tileId, content:selectedTile.querySelector('.tile-content').value },
        existingTiles: tiles.map(t=>({ id:t.dataset.tileId, content:t.querySelector('.tile-content').value })),
        connections
      })
    });
    const data = response.ok ? await response.json() : { suggestions:[`• Related item to "${input}"`,`• Another thought`,`• Edge case`] };
    displayAISuggestions(data);
  }catch{ notify('AI call failed','error'); }
  finally{ btn.disabled=false; text.textContent='Get Suggestions'; }
}
function displayAISuggestions(s){
  const c=document.getElementById('aiSuggestions'); c.innerHTML='';
  const arr = Array.isArray(s?.suggestions)?s.suggestions:Array.isArray(s)?s:[s.text||s.content||s.description||'No suggestions'];
  arr.forEach(v=>{
    const d=document.createElement('div'); d.className='ai-suggestion'; d.textContent = typeof v==='string'?v:JSON.stringify(v);
    d.onclick=()=>{ if(!selectedTile) return; selectedTile.querySelector('.tile-content').value=(typeof v==='string'?v:JSON.stringify(v)); scheduleSave(); notify('Applied'); };
    c.appendChild(d);
  });
}

/* =========================
   Utilities / Demo
========================= */
// function demoTemplateGraph(){
//   const g = { id:'demo-1', title:'Demo Diagram', updated_at:Date.now(), type:'own',
//     data:{ tiles:[
//       { id:'a', x:120,y:140, title:'Input', content:'Incoming data', color:'#e0f2fe', shape:'rounded', preset:'component' },
//       { id:'b', x:380,y:140, title:'Process', content:'Transform', color:'#fff7ed', shape:'hexagon', preset:'component' },
//       { id:'c', x:640,y:140, title:'Output', content:'Result', color:'#e9d5ff', shape:'rounded', preset:'component' }
//     ], connections:[
//       { id:'ab', fromTile:'a',toTile:'b',fromDot:'output',toDot:'input',color:'#3b82f6',style:'solid',marker:'arrow' },
//       { id:'bc', fromTile:'b',toTile:'c',fromDot:'output',toDot:'input',color:'#10b981',style:'dashed',marker:'dot' }
//     ] }};
//   return g;
// }

// ------------ Stubs (safe no-ops) ------------
function loadCollaborators() {
  if (!currentGraph || !currentGraph.sharedUsers) return;
  
  const container = document.getElementById('collaboratorsContent');
  const countEl = document.getElementById('collaboratorsCount');
  
  if (!container || !countEl) return;
  
  countEl.textContent = currentGraph.sharedUsers.length;
  container.innerHTML = '';
  
  currentGraph.sharedUsers.forEach(user => {
    const item = document.createElement('div');
    item.className = 'collaborator-item';
    item.innerHTML = `
      <div class="collaborator-avatar">${user.name.charAt(0).toUpperCase()}</div>
      <div class="collaborator-name">${user.name}</div>
      <div class="collaborator-status ${user.status || 'online'}"></div>
    `;
    container.appendChild(item);
  });
  
  document.getElementById('collaboratorsList').classList.add('show');
}

function addCacheStatusButton() {
  // This function is now handled by the toolbar buttons
  // The cache status functionality is implemented in showCacheStatus()
}

// ------------ New Functions for Complete Functionality ------------

// Preset Tile System
function showPresetTileSelector() {
  const modal = document.getElementById('presetTileModal');
  modal.classList.add('show');
  modal.onclick = (e) => { if (e.target === modal) closePresetTileModal(); };
}

function closePresetTileModal() {
  document.getElementById('presetTileModal').classList.remove('show');
}

function createPresetTile(presetType) {
  const canvasRect = canvas.getBoundingClientRect();
  const centerX = canvasRect.width / 2;
  const centerY = canvasRect.height / 2;
  const x = Math.max(20, Math.round(centerX - 90));
  const y = Math.max(20, Math.round(centerY - 60));
  
  let title = '', content = '', shape = 'rectangle';
  
  switch(presetType) {
    case 'title':
      title = 'Title';
      content = 'Enter your title here';
      shape = 'rounded';
      break;
    case 'notes':
      title = 'Notes';
      content = 'Enter your notes here';
      shape = 'rectangle';
      break;
    case 'component':
      title = 'Component';
      content = 'Component description';
      shape = 'hexagon';
      break;
    case 'custom':
      title = 'Custom';
      content = 'Enter custom content';
      shape = 'rectangle';
      break;
  }
  
  const tile = createTile(x, y, title, content, null, shape, presetType);
  tiles.push(tile);
  renderCanvas();
  scheduleSave();
  closePresetTileModal();
  notify(`${presetType.charAt(0).toUpperCase() + presetType.slice(1)} tile added`, 'success');
}

// Snap to Grid/Tiles Toggle
function toggleSnapToGrid() {
  snapToGrid = !snapToGrid;
  const btn = document.querySelector('.snap-grid-btn');
  btn.classList.toggle('active', snapToGrid);
  btn.title = snapToGrid ? 'Snap to Grid (ON)' : 'Snap to Grid (OFF)';
  notify(`Snap to Grid: ${snapToGrid ? 'ON' : 'OFF'}`, 'success');
}

function toggleSnapToTiles() {
  snapToTiles = !snapToTiles;
  const btn = document.querySelector('.snap-tiles-btn');
  btn.classList.toggle('active', snapToTiles);
  btn.title = snapToTiles ? 'Snap to Tiles (ON)' : 'Snap to Tiles (OFF)';
  notify(`Snap to Tiles: ${snapToTiles ? 'ON' : 'OFF'}`, 'success');
}

// Force Save
async function forceSave() {
  if (!currentGraph) return notify('No graph to save', 'error');
  await autoSaveGraph();
  notify('Force save completed', 'success');
}

// Cache Status
function showCacheStatus() {
  const modal = document.getElementById('cacheStatusModal');
  updateCacheStatusDisplay();
  modal.classList.add('show');
  modal.onclick = (e) => { if (e.target === modal) closeCacheStatusModal(); };
}

function closeCacheStatusModal() {
  document.getElementById('cacheStatusModal').classList.remove('show');
}

function updateCacheStatusDisplay() {
  const lastSaveEl = document.getElementById('lastSaveTime');
  const autoSaveEl = document.getElementById('autoSaveStatus');
  const pendingEl = document.getElementById('pendingUpdatesCount');
  const connectionEl = document.getElementById('connectionStatus');

  if (lastSaveEl) {
    lastSaveEl.textContent = lastSaveTime ? new Date(lastSaveTime).toLocaleTimeString() : 'Never';
  }
  if (autoSaveEl) {
    autoSaveEl.textContent = autoSaveTimer ? 'Enabled' : 'Disabled';
  }
  if (pendingEl) {
    pendingEl.textContent = pendingUpdates.length;
  }
  if (connectionEl) {
    connectionEl.textContent = navigator.onLine ? 'Online' : 'Offline';
    connectionEl.style.color = navigator.onLine ? 'var(--inbox-accepted)' : 'var(--inbox-rejected)';
  }
}

// Floating Toolbar for Tiles
function showTileToolbar(tile, event) {
  const toolbar = document.getElementById('tileToolbar');
  const rect = tile.getBoundingClientRect();
  const canvasRect = canvas.getBoundingClientRect();
  
  toolbar.style.left = (rect.left - canvasRect.left + rect.width / 2) + 'px';
  toolbar.style.top = (rect.top - canvasRect.top - 10) + 'px';
  toolbar.classList.add('show');
  
  // Update color picker
  const colorPicker = toolbar.querySelector('.toolbar-color-picker');
  if (colorPicker) {
    const color = tile.style.backgroundColor || '#ffffff';
    colorPicker.style.setProperty('--tile-color', color);
  }
}

function hideTileToolbar() {
  document.getElementById('tileToolbar').classList.remove('show');
}

// Tile Operations
function duplicateTile() {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  const rect = selectedTile.getBoundingClientRect();
  const canvasRect = canvas.getBoundingClientRect();
  const x = rect.left - canvasRect.left + 20;
  const y = rect.top - canvasRect.top + 20;
  
  const title = selectedTile.querySelector('.tile-title').value;
  const content = selectedTile.querySelector('.tile-content').value;
  const shape = selectedTile.dataset.shape || 'rectangle';
  const color = selectedTile.style.backgroundColor || '#ffffff';
  
  const newTile = createTile(x, y, title, content, null, shape);
  newTile.style.backgroundColor = color;
  tiles.push(newTile);
  
  renderCanvas();
  scheduleSave();
  notify('Tile duplicated', 'success');
}

function bringToFront() {
  if (!selectedTile) return notify('No tile selected', 'error');
  selectedTile.style.zIndex = '1000';
  notify('Tile brought to front', 'success');
}

function sendToBack() {
  if (!selectedTile) return notify('No tile selected', 'error');
  selectedTile.style.zIndex = '1';
  notify('Tile sent to back', 'success');
}

function changeTileShape(shape) {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  // Remove existing shape classes
  selectedTile.classList.remove('rounded', 'circular', 'hexagon', 'diamond', 'triangle', 'parallelogram');
  
  // Add new shape class
  if (shape !== 'rectangle') {
    selectedTile.classList.add(shape);
  }
  
  selectedTile.dataset.shape = shape;
  scheduleSave();
  notify(`Shape changed to ${shape}`, 'success');
}

function showColorPicker() {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  // Create color picker popup
  const popup = document.createElement('div');
  popup.className = 'color-picker-popout show';
  popup.innerHTML = `
    <div class="color-picker-header">
      <div class="color-picker-title">Choose Color</div>
      <button class="color-picker-close" onclick="this.parentElement.parentElement.remove()">×</button>
    </div>
    <div class="color-picker-grid">
      <div class="color-picker-option" style="background:#ff6b6b" onclick="changeTileColor('#ff6b6b')"></div>
      <div class="color-picker-option" style="background:#4ecdc4" onclick="changeTileColor('#4ecdc4')"></div>
      <div class="color-picker-option" style="background:#45b7d1" onclick="changeTileColor('#45b7d1')"></div>
      <div class="color-picker-option" style="background:#96ceb4" onclick="changeTileColor('#96ceb4')"></div>
      <div class="color-picker-option" style="background:#feca57" onclick="changeTileColor('#feca57')"></div>
      <div class="color-picker-option" style="background:#ff9ff3" onclick="changeTileColor('#ff9ff3')"></div>
      <div class="color-picker-option" style="background:#54a0ff" onclick="changeTileColor('#54a0ff')"></div>
      <div class="color-picker-option" style="background:#5f27cd" onclick="changeTileColor('#5f27cd')"></div>
      <div class="color-picker-option" style="background:#00d2d3" onclick="changeTileColor('#00d2d3')"></div>
      <div class="color-picker-option" style="background:#ff9f43" onclick="changeTileColor('#ff9f43')"></div>
      <div class="color-picker-option" style="background:#10ac84" onclick="changeTileColor('#10ac84')"></div>
      <div class="color-picker-option" style="background:#ee5253" onclick="changeTileColor('#ee5253')"></div>
    </div>
  `;
  
  const rect = selectedTile.getBoundingClientRect();
  popup.style.left = rect.left + 'px';
  popup.style.top = (rect.top - 200) + 'px';
  
  document.body.appendChild(popup);
}

function changeTileColor(color) {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  selectedTile.style.backgroundColor = color;
  scheduleSave();
  
  // Update color picker in toolbar
  const colorPicker = document.querySelector('.toolbar-color-picker');
  if (colorPicker) {
    colorPicker.style.setProperty('--tile-color', color);
  }
  
  // Remove color picker popup
  const popup = document.querySelector('.color-picker-popout');
  if (popup) popup.remove();
  
  notify('Tile color changed', 'success');
}

function resetTileColor() {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  const defaultColor = document.documentElement.getAttribute('data-theme') === 'light' ? '#2d3748' : '#ffffff';
  selectedTile.style.backgroundColor = defaultColor;
  scheduleSave();
  
  // Update color picker in toolbar
  const colorPicker = document.querySelector('.toolbar-color-picker');
  if (colorPicker) {
    colorPicker.style.setProperty('--tile-color', defaultColor);
  }
  
  notify('Tile color reset', 'success');
}

    // Connection Operations
    function deleteSelectedConnection() {
      if (!selectedConnection) return notify('No connection selected', 'error');
      
      const connectionId = selectedConnection.dataset.connectionId;
      deleteConnection(connectionId);
      selectedConnection = null;
      hideConnectionToolbar();
      notify('Connection deleted', 'success');
    }

function changeConnectionColor() {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  // Simple color change for now
  const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6'];
  const randomColor = colors[Math.floor(Math.random() * colors.length)];
  
  // Find and update the connection
  const connectionId = selectedConnection.dataset.connectionId;
  const connection = connections.find(c => c.id === connectionId);
  if (connection) {
    connection.color = randomColor;
    renderConnections();
    scheduleSave();
    notify('Connection color changed', 'success');
  }
}

function changeLineStyle(style) {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  selectedConnection.style.strokeDasharray = style === 'solid' ? 'none' : 
                                           style === 'dashed' ? '5,5' : 
                                           style === 'dotted' ? '2,2' : '10,2,2,2';
  
  scheduleSave();
  renderCanvas();
  notify(`Line style changed to ${style}`);
}

function changeConnectionMarker(marker) {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  // Update the connection marker
  const path = selectedConnection.querySelector('path');
  if (path) {
    path.setAttribute('marker-end', marker === 'line' ? '' : `url(#${marker === 'dot' ? 'dotmarker' : marker === 'diamond' ? 'diamondmarker' : 'arrowhead'})`);
  }
  
  scheduleSave();
  renderCanvas();
  notify(`Connection marker changed to ${marker}`);
}

// Enhanced Tile Creation with Connection Dots - using existing createTile function

// Enhanced Tile Selection with Toolbar - using existing selectTile function

    // Connection Selection - using existing functions

// Enhanced Connection Rendering with Line Styles
function createConnectionLineWithSeparation(fromTile, toTile, index, connObj) {
  const { fromPort, toPort } = findOptimalPort(fromTile, toTile, connObj?.fromDot, connObj?.toDot);
  let fx = fromPort.x, fy = fromPort.y, tx = toPort.x, ty = toPort.y;
  const dx = tx - fx, dy = ty - fy, len = Math.max(1, Math.hypot(dx, dy));
  const perpX = -dy / len, perpY = dx / len;
  const bump = (index ? (index - 0.5) * 8 : 0);
  fx += perpX * bump; fy += perpY * bump;
  tx += perpX * bump; ty += perpY * bump;

  const d = createSmartPath(fx, fy, tx, ty);
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', d);
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke', connObj?.color || 'var(--accent-primary)');
  path.setAttribute('stroke-width', '3');
  path.setAttribute('marker-end', 'url(#arrowhead)');
  
  // Apply line style
  if (connObj?.lineStyle) {
    path.classList.add(`line-style-${connObj.lineStyle}`);
  }
  
  path.classList.add('connection-line');
  path.style.pointerEvents = 'stroke';
  path.dataset.connectionId = connObj.id;
  
  path.addEventListener('click', (e) => {
    e.stopPropagation();
    selectConnection(path);
  });
  
  path.addEventListener('mouseenter', () => { 
    path.style.strokeWidth = '4'; 
    path.style.filter = 'drop-shadow(0 0 3px currentColor)'; 
  });
  path.addEventListener('mouseleave', () => { 
    path.style.strokeWidth = '3'; 
    path.style.filter = 'none'; 
  });
  
  return path;
}

// Keyboard Shortcuts
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'TEXTAREA') return; // Don't interfere with text editing
  
  switch(e.key) {
    case 'Delete':
    case 'Backspace':
      if (e.ctrlKey || e.metaKey) break;
      deleteSelected();
      break;
    case 'n':
    case 'N':
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        createNewGraph();
      }
      break;
    case 's':
    case 'S':
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        forceSave();
      }
      break;
    case 'Escape':
      clearSelection();
      hideTileToolbar();
      hideConnectionToolbar();
      break;
    case 'g':
    case 'G':
      if (e.shiftKey) {
        e.preventDefault();
        toggleGrid();
      }
      break;
  }
});

// Enhanced Canvas Click Handler
function handleCanvasClick(e) {
  if (e.target === canvas) {
    clearSelection();
    hideTileToolbar();
    hideConnectionToolbar();
  }
}

// Enhanced Clear Selection
function clearSelection() {
  if (selectedTile) {
    selectedTile.classList.remove('selected');
    selectedTile = null;
  }
  if (selectedConnection) {
    selectedConnection.classList.remove('selected');
    selectedConnection = null;
  }
}

// Initialize enhanced functionality
function initializeEnhancedFeatures() {
  // Set initial states for snap buttons
  document.querySelector('.snap-grid-btn').classList.toggle('active', snapToGrid);
  document.querySelector('.snap-tiles-btn').classList.toggle('active', snapToTiles);
  
  // Add connection dot event listeners
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('connection-dot')) {
      e.stopPropagation();
      // Handle connection dot click
      const tile = e.target.closest('.tile');
      if (tile) {
        startConnectionFromTile(tile, e);
      }
    }
  });
}

// Call enhanced initialization
document.addEventListener('DOMContentLoaded', () => {
  init();
  initializeEnhancedFeatures();
});

// ------------ Missing Functions ------------

function centerCanvas() {
  if (tiles.length === 0) return;
  
  // Calculate the bounding box of all tiles
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  
  tiles.forEach(tile => {
    const x = parseFloat(tile.dataset.baseX || 0);
    const y = parseFloat(tile.dataset.baseY || 0);
    const rect = tile.getBoundingClientRect();
    
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + rect.width);
    maxY = Math.max(maxY, y + rect.height);
  });
  
  // Calculate center point
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  
  // Get canvas dimensions
  const canvasRect = canvas.getBoundingClientRect();
  const targetX = canvasRect.width / 2 - centerX;
  const targetY = canvasRect.height / 2 - centerY;
  
  // Update canvas offset
  canvasOffset.x = targetX;
  canvasOffset.y = targetY;
  
  // Apply transform
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  
  // Render connections
  renderConnections();
  
  notify('Canvas centered');
}

function zoomIn() {
  zoom = Math.min(zoom * 1.2, 3);
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
}

function zoomOut() {
  zoom = Math.max(zoom / 1.2, 0.3);
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
}

function zoomReset() {
  zoom = 1;
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
}

function forceSave() {
  if (!currentGraph) return notify('No graph to save', 'error');
  
  const indicator = document.getElementById('autoSaveIndicator');
  const text = document.getElementById('autoSaveText');
  
  indicator.classList.add('show', 'saving');
  text.textContent = 'Saving...';
  
  // Force immediate save
  autoSaveGraph().then(() => {
    indicator.classList.remove('saving');
    indicator.classList.add('saved');
    text.textContent = 'Saved!';
    setTimeout(() => indicator.classList.remove('show', 'saved'), 2000);
  });
}

function showCacheStatus() {
  const modal = document.getElementById('cacheStatusModal');
  if (!modal) return;
  
  // Update status information
  const lastSaveTimeEl = document.getElementById('lastSaveTime');
  const autoSaveStatusEl = document.getElementById('autoSaveStatus');
  const pendingUpdatesCountEl = document.getElementById('pendingUpdatesCount');
  const connectionStatusEl = document.getElementById('connectionStatus');
  
  if (lastSaveTimeEl) {
    lastSaveTimeEl.textContent = lastSaveTime ? new Date(lastSaveTime).toLocaleTimeString() : 'Never';
  }
  
  if (autoSaveStatusEl) {
    autoSaveStatusEl.textContent = autoSaveTimer ? 'Enabled' : 'Disabled';
  }
  
  if (pendingUpdatesCountEl) {
    pendingUpdatesCountEl.textContent = pendingUpdates.length;
  }
  
  if (connectionStatusEl) {
    connectionStatusEl.textContent = navigator.onLine ? 'Online' : 'Offline';
  }
  
  modal.classList.add('show');
  modal.onclick = (e) => { if (e.target === modal) closeCacheStatusModal(); };
}

function closeCacheStatusModal() {
  const modal = document.getElementById('cacheStatusModal');
  if (modal) modal.classList.remove('show');
}

function showPresetTileSelector() {
  const modal = document.getElementById('presetTileModal');
  if (modal) modal.classList.add('show');
}

function closePresetTileModal() {
  const modal = document.getElementById('presetTileModal');
  if (modal) modal.classList.remove('show');
}

function toggleSnapToGrid() {
  snapToGrid = !snapToGrid;
  const btn = document.querySelector('.snap-grid-btn');
  if (btn) btn.classList.toggle('active', snapToGrid);
  notify(`Snap to grid ${snapToGrid ? 'ON' : 'OFF'}`);
}

function toggleSnapToTiles() {
  snapToTiles = !snapToTiles;
  const btn = document.querySelector('.snap-tiles-btn');
  if (btn) btn.classList.toggle('active', snapToTiles);
  notify(`Snap to tiles ${snapToTiles ? 'ON' : 'OFF'}`);
}

function toggleGrid() {
  showGrid = !showGrid;
  const btn = document.querySelector('.grid-toggle-btn');
  if (btn) {
    btn.classList.toggle('active', showGrid);
    btn.title = `Show Grid (${showGrid ? 'ON' : 'OFF'})`;
  }
  
  const overlay = document.getElementById('grid-overlay');
  if (overlay) overlay.classList.toggle('show', showGrid);
  
  notify(`Grid ${showGrid ? 'ON' : 'OFF'}`);
}

function duplicateTile() {
  if (!selectedTile) return notify('Select a tile first', 'error');
  
  const x = parseFloat(selectedTile.dataset.baseX || 0) + 20;
  const y = parseFloat(selectedTile.dataset.baseY || 0) + 20;
  
  const newTile = createTile(
    x, y,
    selectedTile.querySelector('.tile-title')?.value || '',
    selectedTile.querySelector('.tile-content')?.value || '',
    null,
    selectedTile.dataset.shape || 'rectangle',
    selectedTile.dataset.presetType || 'custom',
    selectedTile.style.backgroundColor || '#ffffff'
  );
  
  tiles.push(newTile);
  renderCanvas();
  scheduleSave();
  notify('Tile duplicated');
}

function bringToFront() {
  if (!selectedTile) return;
  selectedTile.style.zIndex = '1000';
  notify('Tile brought to front');
}

function sendToBack() {
  if (!selectedTile) return;
  selectedTile.style.zIndex = '1';
  notify('Tile sent to back');
}

function changeTileShape(shape) {
  if (!selectedTile) return;
  setTileShape(selectedTile, shape);
  notify(`Shape changed to ${shape}`);
}

function resetTileColor() {
  if (!selectedTile) return;
  selectedTile.style.backgroundColor = '#ffffff';
  scheduleSave();
  notify('Color reset');
}

function showColorPicker() {
  // This will be handled by the existing color picker functionality
  notify('Color picker opened');
}

function deleteSelectedConnection() {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  const connectionId = selectedConnection.dataset.connectionId;
  deleteConnection(connectionId);
  selectedConnection = null;
  hideConnectionToolbar();
  notify('Connection deleted');
}

function changeConnectionColor() {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  // Open color picker for connection
  openColorPopup(document.querySelector('#connColorPick'), (color) => {
    selectedConnection.style.stroke = color;
    scheduleSave();
    renderCanvas();
    notify('Connection color changed');
  });
}

function changeLineStyle(style) {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  selectedConnection.style.strokeDasharray = style === 'solid' ? 'none' : 
                                           style === 'dashed' ? '5,5' : 
                                           style === 'dotted' ? '2,2' : '10,2,2,2';
  
  scheduleSave();
  renderCanvas();
  notify(`Line style changed to ${style}`);
}

function openTileToolbar(tile, at = null, force = false, focusSection = null) {
  if (!tile && !force) return;
  
  const pos = at || { 
    x: (tile.getBoundingClientRect().left + tile.getBoundingClientRect().right) / 2,
    y: tile.getBoundingClientRect().top - 8 
  };
  
  const floatTB = document.getElementById('tileToolbar');
  if (!floatTB) return;
  
  floatTB.innerHTML = `
    <div class="toolbar-section">
      <div class="toolbar-section-title">Tile</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="duplicateTile()" title="Duplicate">Copy</button>
        <button class="toolbar-button" onclick="deleteSelected()" title="Delete">Delete</button>
        <div class="toolbar-color" id="tileColorPick" title="Color"></div>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Shape</div>
      <div class="toolbar-row">
        ${['rectangle','rounded','circular','diamond','hexagon','triangle','parallelogram']
          .map(s=>`<button class="toolbar-button ${tile?.dataset.shape===s?'active':''}" onclick="changeTileShape('${s}')">${shapeIcon(s)}</button>`).join('')}
      </div>
    </div>
  `;
  
  floatTB.style.left = pos.x + 'px';
  floatTB.style.top = pos.y + 'px';
  floatTB.classList.add('show');
  
  // Add color picker functionality
  const colorPick = floatTB.querySelector('#tileColorPick');
  if (colorPick) {
    colorPick.onclick = () => openColorPopup(colorPick, (c) => {
      tile.style.backgroundColor = c;
      scheduleSave();
    });
  }
}

function openConnectionToolbar(conn, at) {
  // Close other menus first
  closeAllTileMenus();
  
  const floatTB = document.getElementById('connectionToolbar');
  if (!floatTB) return;
  
  floatTB.innerHTML = `
    <div class="toolbar-section">
      <div class="toolbar-section-title">Connection</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="deleteSelectedConnection()" title="Delete">Delete</button>
        <button class="toolbar-button" onclick="changeConnectionColor()" title="Color">Color</button>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Style</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="changeLineStyle('solid')" title="Solid">━</button>
        <button class="toolbar-button" onclick="changeLineStyle('dashed')" title="Dashed">┅</button>
        <button class="toolbar-button" onclick="changeLineStyle('dotted')" title="Dotted">┄</button>
      </div>
    </div>
  `;
  
  floatTB.style.left = at.x + 'px';
  floatTB.style.top = at.y + 'px';
  floatTB.classList.add('show');
}

function hideConnectionToolbar() {
  const floatTB = document.getElementById('connectionToolbar');
  if (floatTB) floatTB.classList.remove('show');
}

function hideFloatingToolbars() {
  const tileTB = document.getElementById('tileToolbar');
  const connTB = document.getElementById('connectionToolbar');
  
  if (tileTB) tileTB.classList.remove('show');
  if (connTB) connTB.classList.remove('show');
}

function scheduleSave() {
  if (autoSaveTimer) clearTimeout(autoSaveTimer);
  autoSaveTimer = setTimeout(autoSaveGraph, 2000);
  markAsDirty();
}

function markAsDirty() {
  isDirty = true;
  lastSaveTime = Date.now();
  pushHistory();
}

function addPendingUpdate(type, data) {
  pendingUpdates.push({ type, data, timestamp: Date.now() });
}

function ctxAction(action) {
  if (!selectedTile) return;
  
  switch (action) {
    case 'edit':
      selectedTile.querySelector('.tile-content')?.focus();
      break;
    case 'color':
      openColorPopup(selectedTile, (c) => {
        selectedTile.style.backgroundColor = c;
        scheduleSave();
      });
      break;
    case 'shape':
      // Show shape options
      break;
    case 'duplicate':
      duplicateTile();
      break;
    case 'delete':
      deleteSelected();
      break;
  }
  
  // Hide context menu
  const ctxMenu = document.getElementById('ctxMenu');
  if (ctxMenu) ctxMenu.style.display = 'none';
}

// Add missing functions
function addTileClickHandler(tile) {
  tile.addEventListener('click', () => selectTile(tile));
  tile.addEventListener('dblclick', (e) => openTileToolbar(tile, { x: e.clientX, y: e.clientY }));
  
  // Add connection dot event listeners
  tile.querySelectorAll('.connection-dot').forEach(el => {
    el.addEventListener('mousedown', (e) => startConnectionFromPort(el, e));
  });
}

// Using existing findOptimalPort function

// Using existing createSmartPath function

function loadFromLocalStorage() {
  // Look for any saved graphs in localStorage
  const savedGraphs = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.startsWith('flowpad_graph_')) {
      try {
        const graphData = JSON.parse(localStorage.getItem(key));
        if (graphData && graphData.title && graphData.data) {
          savedGraphs.push({
            id: key.replace('flowpad_graph_', ''),
            title: graphData.title,
            updated_at: graphData.updated_at || Date.now(),
            data: graphData.data,
            type: 'local'
          });
        }
      } catch (e) {
        console.log('Failed to parse saved graph:', key);
      }
    }
  }
  
  if (savedGraphs.length > 0) {
    // Sort by most recently updated
    savedGraphs.sort((a, b) => (b.updated_at || 0) - (a.updated_at || 0));
    
    // Load the most recent graph
    const mostRecent = savedGraphs[0];
    currentGraph = mostRecent;
    
    // Create tiles and connections
    tiles = [];
    connections = [];
    (mostRecent.data.tiles || []).forEach(t => {
      const tile = createTile(t.x, t.y, t.title, t.content, t.id, t.shape || 'rectangle', t.preset || 'custom', t.color || '#ffffff');
      
      // Restore custom dimensions if they exist
      if (t.width) tile.style.width = t.width + 'px';
      if (t.height) tile.style.height = t.height + 'px';
      
      tiles.push(tile);
    });
    connections = mostRecent.data.connections || [];
    
    // Create a tab for the loaded graph
    if (!openTabs.find(t => t.id === mostRecent.id)) {
      createTab(mostRecent);
    }
    switchToTab(mostRecent.id);
    
    // Render the canvas
    renderCanvas();
    isDirty = false;
    updateTileColorsForTheme(document.documentElement.getAttribute('data-theme'));
    pushHistory(true);
    
    notify(`Loaded "${mostRecent.title}" from local storage`, 'success');
  } else if (tiles.length === 0) {
    // Don't create demo graph - let user create their own
    notify('No saved graphs found. Create a new graph to get started.', 'info');
  }
}

function addResizeHandles(tile) {
  // Remove existing handles
  tile.querySelectorAll('.resize-handle').forEach(h => h.remove());
  
  // Create resize handles for each edge (4 dots on each side) and corners
  const handles = [
    // North edge - 4 dots
    { class: 'n1', cursor: 'n-resize', position: '25%' },
    { class: 'n2', cursor: 'n-resize', position: '50%' },
    { class: 'n3', cursor: 'n-resize', position: '75%' },
    // South edge - 4 dots
    { class: 's1', cursor: 's-resize', position: '25%' },
    { class: 's2', cursor: 's-resize', position: '50%' },
    { class: 's3', cursor: 's-resize', position: '75%' },
    // East edge - 4 dots
    { class: 'e1', cursor: 'e-resize', position: '25%' },
    { class: 'e2', cursor: 'e-resize', position: '50%' },
    { class: 'e3', cursor: 'e-resize', position: '75%' },
    // West edge - 4 dots
    { class: 'w1', cursor: 'w-resize', position: '25%' },
    { class: 'w2', cursor: 'w-resize', position: '50%' },
    { class: 'w3', cursor: 'w-resize', position: '75%' },
    // Corners
    { class: 'nw', cursor: 'nw-resize', position: 'corner' },
    { class: 'ne', cursor: 'ne-resize', position: 'corner' },
    { class: 'sw', cursor: 'sw-resize', position: 'corner' },
    { class: 'se', cursor: 'se-resize', position: 'corner' }
  ];
  
  handles.forEach(handle => {
    const div = document.createElement('div');
    div.className = `resize-handle ${handle.class}`;
    div.style.cursor = handle.cursor;
    div.dataset.handle = handle.class;
    
    // Add event listeners for resizing
    div.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      startResizing(tile, handle.class, e);
    });
    
    tile.appendChild(div);
  });
}

function startResizing(tile, handleType, e) {
  e.preventDefault();
  
  const startX = e.clientX;
  const startY = e.clientY;
  const startWidth = tile.offsetWidth;
  const startHeight = tile.offsetHeight;
  const startLeft = parseFloat(tile.style.left) || 0;
  const startTop = parseFloat(tile.style.top) || 0;
  
  const isResizing = true;
  
  function onMouseMove(e) {
    const deltaX = e.clientX - startX;
    const deltaY = e.clientY - startY;
    
    let newWidth = startWidth;
    let newHeight = startHeight;
    let newLeft = startLeft;
    let newTop = startTop;
    
    // Handle different resize directions
    switch (handleType) {
      // North edge handles
      case 'n1': case 'n2': case 'n3':
        newHeight = Math.max(100, startHeight - deltaY);
        newTop = startTop + (startHeight - newHeight);
        break;
      // South edge handles
      case 's1': case 's2': case 's3':
        newHeight = Math.max(100, startHeight + deltaY);
        break;
      // East edge handles
      case 'e1': case 'e2': case 'e3':
        newWidth = Math.max(150, startWidth + deltaX);
        break;
      // West edge handles
      case 'w1': case 'w2': case 'w3':
        newWidth = Math.max(150, startWidth - deltaX);
        newLeft = startLeft + (startWidth - newWidth);
        break;
      case 'nw': // Northwest corner
        newWidth = Math.max(150, startWidth - deltaX);
        newHeight = Math.max(100, startHeight - deltaY);
        newLeft = startLeft + (startWidth - newWidth);
        newTop = startTop + (startHeight - newHeight);
        break;
      case 'ne': // Northeast corner
        newWidth = Math.max(150, startWidth + deltaX);
        newHeight = Math.max(100, startHeight - deltaY);
        newTop = startTop + (startHeight - newHeight);
        break;
      case 'sw': // Southwest corner
        newWidth = Math.max(150, startWidth - deltaX);
        newHeight = Math.max(100, startHeight + deltaY);
        newLeft = startLeft + (startWidth - newWidth);
        break;
      case 'se': // Southeast corner
        newWidth = Math.max(150, startWidth + deltaX);
        newHeight = Math.max(100, startHeight + deltaY);
        break;
    }
    
    // Apply new dimensions
    tile.style.width = newWidth + 'px';
    tile.style.height = newHeight + 'px';
    tile.style.left = newLeft + 'px';
    tile.style.top = newTop + 'px';
    
    // Update tile data
    tile.dataset.baseX = newLeft;
    tile.dataset.baseY = newTop;
    
    // Mark as dirty and schedule save
    markAsDirty();
    scheduleSave();
    
    // Re-render connections
    renderConnections();
  }
  
  function onMouseUp() {
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
    
    // Final save
    scheduleSave();
  }
  
  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
}

function openShareGraphModal() {
  const modal = document.getElementById('shareGraphModal');
  if (!modal) return;
  
  // Reset form
  document.getElementById('shareEmail').value = '';
  document.querySelector('input[name="permission"][value="view"]').checked = true;
  
  modal.classList.add('show');
  modal.style.display = 'flex';
}

function closeShareGraphModal() {
  const modal = document.getElementById('shareGraphModal');
  if (!modal) return;
  
  modal.classList.remove('show');
  modal.style.display = 'none';
}

function shareGraph() {
  if (!currentGraph) return;
  
  const email = document.getElementById('shareEmail').value.trim();
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    return notify('Invalid email address', 'error');
  }
  
  const permission = document.querySelector('input[name="permission"]:checked').value;
  
  // Here you would typically send the share request to your server
  // For now, we'll just show a success message
  notify(`Graph shared with ${email} (${permission} access)`, 'success');
  closeShareGraphModal();
  
  // In a real implementation, you would call:
  // fetch(`/api/graphs/${currentGraph.id}/share`, {
  //   method: 'POST',
  //   headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${localStorage.getItem('flowpad_token')}` },
  //   body: JSON.stringify({ email, permission })
  // });
}

function handleDragOver(e) {
  e.preventDefault();
  e.currentTarget.classList.add('drag-over');
}

function handleDragLeave(e) {
  e.currentTarget.classList.remove('drag-over');
}

function handleDrop(e, targetFolder) {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-over');
  
  const graphId = e.dataTransfer.getData('text/plain');
  const graphData = e.dataTransfer.getData('application/json');
  
  if (!graphId || !graphData) return;
  
  try {
    const graph = JSON.parse(graphData);
    
    // Remove from current folder
    const currentFolder = findGraphFolder(graphId);
    if (currentFolder && currentFolder !== targetFolder) {
      removeGraphFromFolder(graphId, currentFolder);
    }
    
    // Add to target folder
    addGraphToFolder(graph, targetFolder);
    
    notify(`Graph "${graph.title}" moved to ${targetFolder}`, 'success');
    
  } catch (error) {
    notify('Failed to move graph', 'error');
  }
}

function findGraphFolder(graphId) {
  // Find which folder currently contains this graph
  const folders = ['myGraphs', 'sharedGraphs', 'inbox'];
  for (const folder of folders) {
    const container = document.getElementById(folder === 'myGraphs' ? 'ownGraphs' : folder === 'sharedGraphs' ? 'sharedGraphsContent' : 'inboxContent');
    if (container.querySelector(`[data-graph-id="${graphId}"]`)) {
      return folder;
    }
  }
  return null;
}

function removeGraphFromFolder(graphId, folderId) {
  const container = document.getElementById(folderId === 'myGraphs' ? 'ownGraphs' : folderId === 'sharedGraphs' ? 'sharedGraphsContent' : 'inboxContent');
  const graphElement = container.querySelector(`[data-graph-id="${graphId}"]`);
  if (graphElement) {
    graphElement.remove();
  }
}

function addGraphToFolder(graph, folderId) {
  const container = document.getElementById(folderId === 'myGraphs' ? 'ownGraphs' : folderId === 'sharedGraphs' ? 'sharedGraphsContent' : 'inboxContent');
  
  const item = document.createElement('div');
  item.className = 'graph-item';
  item.dataset.graphId = graph.id;
  item.draggable = true;
  item.innerHTML = `
    <div class="graph-title">${graph.title}</div>
    <div class="graph-meta">Updated: ${new Date(graph.updated_at || Date.now()).toLocaleString()}</div>
    <button class="graph-delete" onclick="deleteGraph('${graph.id}')" title="Delete graph">×</button>
  `;
  
  // Click to load graph
  item.addEventListener('click', (e) => { 
    if (!e.target.classList.contains('graph-delete')) loadGraph(graph); 
  });
  
  // Drag and drop functionality
  item.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', graph.id);
    e.dataTransfer.setData('application/json', JSON.stringify(graph));
    item.classList.add('dragging');
  });
  
  item.addEventListener('dragend', () => {
    item.classList.remove('dragging');
  });
  
  container.appendChild(item);
}

function updateTileMenuPosition() {
  if (selectedTile) {
    const toolbar = document.getElementById('tileToolbar');
    if (toolbar && toolbar.classList.contains('show')) {
      const rect = selectedTile.getBoundingClientRect();
      const pos = {
        x: (rect.left + rect.right) / 2,
        y: rect.top - 8
      };
      toolbar.style.left = pos.x + 'px';
      toolbar.style.top = pos.y + 'px';
    }
  }
}

function closeAllTileMenus() {
  const tileToolbar = document.getElementById('tileToolbar');
  const connectionToolbar = document.getElementById('connectionToolbar');
  
  if (tileToolbar) {
    tileToolbar.classList.remove('show');
  }
  if (connectionToolbar) {
    connectionToolbar.classList.remove('show');
  }
  
  // Also close preset modal if open
  const presetModal = document.getElementById('presetTileModal');
  if (presetModal && presetModal.classList.contains('show')) {
    presetModal.classList.remove('show');
    presetModal.style.display = 'none';
  }
}

// Add click outside listener to close menus
document.addEventListener('click', (e) => {
  if (!e.target.closest('.toolbar') && !e.target.closest('.tile') && !e.target.closest('.connection-dot')) {
    closeAllTileMenus();
  }
});

function toggleShapeDropdown() {
  const dropdown = document.getElementById('shapeDropdown');
  if (dropdown) {
    dropdown.classList.toggle('show');
  }
}

// Close dropdowns when clicking outside
document.addEventListener('click', (e) => {
  if (!e.target.closest('.toolbar-dropdown')) {
    const dropdowns = document.querySelectorAll('.toolbar-dropdown-content');
    dropdowns.forEach(d => d.classList.remove('show'));
  }
});
</script>
</body>
</html>

