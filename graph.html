<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flowpad - Dashboard</title>
  <style>
    :root {
      --bg-primary: #1a1a1a;
      --bg-secondary: #2d2d2d;
      --bg-tertiary: rgba(0,0,0,0.9);
      --bg-sidebar: rgba(0,0,0,0.8);
      --bg-tile: #fff;
      --bg-tile-hover: #f8f9fa;
      --text-primary: #fff;
      --text-secondary: #ccc;
      --text-tile: #000;
      --border-primary: #333;
      --border-secondary: #555;
      --accent-primary: #007AFF;
      --accent-secondary: #0056CC;
      --shadow-primary: rgba(0,0,0,0.3);
      --shadow-secondary: rgba(0,0,0,0.2);
      --grid-color: rgba(255,255,255,0.03);
      --tab-active: #007AFF;
      --tab-inactive: #444;
      --tab-hover: #555;
      --inbox-pending: #FF9500;
      --inbox-accepted: #34C759;
      --inbox-rejected: #FF3B30;
    }

    :root[data-theme="light"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9fa;
      --bg-tertiary: rgba(255,255,255,0.95);
      --bg-sidebar: rgba(255,255,255,0.95);
      --bg-tile: #ffffff;
      --bg-tile-hover: #f8f9fa;
      --text-primary: #2d3748;
      --text-secondary: #4a5568;
      --text-tile: #000000;
      --border-primary: #e2e8f0;
      --border-secondary: #cbd5e0;
      --shadow-primary: rgba(0,0,0,0.1);
      --shadow-secondary: rgba(0,0,0,0.05);
      --grid-color: rgba(0,0,0,0.03);
      --tab-active: #007AFF;
      --tab-inactive: #ddd;
      --tab-hover: #e2e8f0;
      --inbox-pending: #FF9500;
      --inbox-accepted: #34C759;
      --inbox-rejected: #FF3B30;
    }

    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;background:var(--bg-primary);background-image:linear-gradient(var(--grid-color) 1px,transparent 1px),linear-gradient(90deg,var(--grid-color) 1px,transparent 1px);background-size:20px 20px;color:var(--text-primary);overflow:hidden;transition:all 0.3s ease}
    
    .header{position:fixed;inset:0 0 auto 0;height:60px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border-bottom:1px solid var(--border-primary);display:flex;align-items:center;justify-content:space-between;padding:0 20px;z-index:1000;transition:all 0.3s ease;box-shadow:0 4px 20px var(--shadow-primary)}
    .logo{font-size:1.5rem;font-weight:400;background:linear-gradient(45deg,var(--text-primary),var(--text-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .user-info{display:flex;align-items:center;gap:15px}
    .signout-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 16px;border-radius:6px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .signout-btn:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    .theme-toggle{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 12px;border-radius:6px;cursor:pointer;margin-right:10px;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .theme-toggle:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    .sidebar{position:fixed;left:0;top:60px;bottom:0;width:300px;background:var(--bg-sidebar);backdrop-filter:blur(20px);border-right:1px solid var(--border-primary);overflow-y:auto;transition:all 0.3s ease;box-shadow:4px 0 20px var(--shadow-primary)}
    .sidebar-content{padding:20px}
    .section-title{font-size:1.1rem;font-weight:400;margin-bottom:15px;color:var(--text-primary);text-shadow:0 1px 2px var(--shadow-primary)}
    .new-graph-btn{background:var(--accent-primary);color:#fff;border:none;padding:12px 20px;border-radius:8px;cursor:pointer;width:100%;font-size:1rem;margin-bottom:20px;transition:all 0.3s ease;box-shadow:0 4px 12px var(--shadow-primary)}
    .new-graph-btn:hover{background:var(--accent-secondary);box-shadow:0 6px 16px var(--shadow-secondary)}
    
    .folder-section{margin-bottom:25px;border:1px solid var(--border-secondary);border-radius:8px;overflow:hidden;box-shadow:0 2px 8px var(--shadow-primary)}
    .folder-header{background:var(--bg-secondary);padding:12px 15px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border-secondary);transition:all 0.3s ease}
    .folder-header:hover{background:var(--border-primary)}
    .folder-header.active{background:var(--accent-primary);color:#fff}
    .folder-icon{margin-right:8px;font-size:1.1rem}
    .folder-arrow{transition:transform 0.3s ease}
    .folder-arrow.expanded{transform:rotate(90deg)}
    .folder-content{padding:10px;background:var(--bg-tertiary);display:none}
    .folder-content.expanded{display:block}
    
    .graph-item{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:12px;margin-bottom:8px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary);position:relative}
    .graph-item:hover{background:var(--border-primary);box-shadow:0 4px 12px var(--shadow-secondary);transform:translateX(5px)}
    .graph-item.active{background:var(--accent-primary);color:#fff;border-color:var(--accent-primary)}
    .graph-title{font-weight:400;margin-bottom:5px;color:inherit;font-size:0.95rem}
    .graph-meta{font-size:.75rem;color:inherit;opacity:0.8}
    .graph-delete{position:absolute;top:8px;right:8px;background:rgba(255,0,0,0.8);color:#fff;border:none;border-radius:4px;width:20px;height:20px;cursor:pointer;font-size:12px;opacity:0;transition:opacity 0.3s ease}
    .graph-item:hover .graph-delete{opacity:1}
    .graph-delete:hover{background:rgba(255,0,0,1)}
    
    .inbox-item{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:12px;margin-bottom:8px;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary);position:relative}
    .inbox-item.pending{border-left:4px solid var(--inbox-pending)}
    .inbox-item.accepted{border-left:4px solid var(--inbox-accepted)}
    .inbox-item.rejected{border-left:4px solid var(--inbox-rejected)}
    .inbox-title{font-weight:400;margin-bottom:5px;color:var(--text-primary);font-size:0.95rem}
    .inbox-meta{font-size:.75rem;color:var(--text-secondary);margin-bottom:10px}
    .inbox-actions{display:flex;gap:8px}
    .inbox-btn{flex:1;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;font-size:0.8rem;transition:all 0.3s ease;box-shadow:0 2px 4px var(--shadow-primary)}
    .inbox-btn.accept{background:var(--inbox-accepted);color:#fff}
    .inbox-btn.accept:hover{box-shadow:0 4px 8px var(--shadow-secondary)}
    .inbox-btn.reject{background:var(--inbox-rejected);color:#fff}
    .inbox-btn.reject:hover{box-shadow:0 4px 8px var(--shadow-secondary)}
    
    .canvas-container{position:fixed;left:300px;top:60px;right:0;bottom:0;overflow:hidden}
    .canvas{width:100%;height:100%;background-image:linear-gradient(var(--grid-color) 1px,transparent 1px),linear-gradient(90deg,var(--grid-color) 1px,transparent 1px);background-size:20px 20px;position:relative;cursor:grab}

    
    .tile{position:absolute;background:var(--bg-tile);color:var(--text-tile);border:2px solid var(--border-primary);border-radius:12px;padding:20px;min-width:150px;min-height:100px;cursor:move;user-select:none;box-shadow:0 8px 25px var(--shadow-primary);transition:all 0.3s ease;resize:both;overflow:hidden}
    .tile:hover{background:var(--bg-tile-hover);box-shadow:0 12px 35px var(--shadow-secondary)}
    .tile.selected{border-color:var(--accent-primary);box-shadow:0 0 0 3px rgba(0, 122, 255, 0.3)}
    .tile-title,.tile-content{border:none;background:transparent;width:100%;outline:none;font-family:inherit;resize:none;font-weight:400}
    .tile-title{font-weight:400;margin-bottom:12px;font-size:1rem;color:var(--text-tile)}
    .tile-content{font-size:0.9rem;line-height:1.5;min-height:50px;color:var(--text-tile);font-weight:400}
    
    /* Resize handles - bigger and better positioned */
    .tile::after{content:'';position:absolute;bottom:0;right:0;width:30px;height:30px;cursor:se-resize;background:linear-gradient(-45deg,transparent 30%,var(--border-primary) 30%,var(--border-primary) 40%,transparent 40%,transparent 60%,var(--border-primary) 60%,var(--border-primary) 70%,transparent 70%);border-radius:0 0 12px 0}
    .tile::before{content:'';position:absolute;top:0;left:0;width:30px;height:30px;cursor:nw-resize;background:linear-gradient(45deg,transparent 30%,var(--border-primary) 30%,var(--border-primary) 40%,transparent 40%,transparent 60%,var(--border-primary) 60%,var(--border-primary) 70%,transparent 70%);border-radius:12px 0 0 0}
    
    .color-palette{position:absolute;top:10px;right:10px;display:grid;grid-template-columns:repeat(5,1fr);gap:4px;opacity:0;transition:opacity 0.3s ease;width:120px;z-index:1000}
    .tile:hover .color-palette{opacity:1}
    .color-option{width:20px;height:20px;border-radius:50%;border:2px solid var(--border-primary);cursor:pointer;transition:all 0.3s ease}
    .color-option:hover{transform:scale(1.2);border-color:var(--accent-primary)}
    .color-option.selected{border-color:var(--accent-primary);box-shadow:0 0 0 2px var(--accent-primary)}
    
    /* Color picker popout */
    .color-picker-popout{position:absolute;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:15px;box-shadow:0 10px 25px var(--shadow-primary);z-index:1001;display:none;min-width:200px;backdrop-filter:blur(20px)}
    .color-picker-popout.show{display:block}
    .color-picker-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid var(--border-secondary)}
    .color-picker-title{font-weight:500;color:var(--text-primary);font-size:0.9rem}
    .color-picker-close{background:none;border:none;color:var(--text-secondary);cursor:pointer;font-size:16px;padding:2px;border-radius:4px;transition:all 0.3s ease}
    .color-picker-close:hover{color:var(--text-primary);background:var(--border-primary)}
    .color-picker-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;margin-bottom:15px}
    .color-picker-option{width:30px;height:30px;border-radius:50%;border:2px solid var(--border-primary);cursor:pointer;transition:all 0.3s ease;position:relative}
    .color-picker-option:hover{transform:scale(1.1);border-color:var(--accent-primary)}
    .color-picker-option.selected{border-color:var(--accent-primary);box-shadow:0 0 0 3px var(--accent-primary)}
    .color-picker-option.selected::after{content:'‚úì';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:12px;font-weight:bold;text-shadow:0 1px 2px rgba(0,0,0,0.5)}
    .color-picker-recent{display:grid;grid-template-columns:repeat(5,1fr);gap:5px}
    .color-picker-recent-title{font-size:0.8rem;color:var(--text-secondary);margin-bottom:8px;text-align:center}
    .color-picker-recent-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:5px}
    
    /* Collaborative users list */
    .collaborators-list{position:fixed;bottom:20px;right:20px;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:12px;box-shadow:0 8px 25px var(--shadow-primary);z-index:1000;min-width:180px;backdrop-filter:blur(20px);display:none}
    .collaborators-list.show{display:block}
    .collaborators-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--border-secondary)}
    .collaborators-title{font-size:0.8rem;font-weight:500;color:var(--text-primary)}
    .collaborators-count{background:var(--accent-primary);color:#fff;border-radius:10px;padding:2px 8px;font-size:0.7rem;font-weight:500}
    .collaborator-item{display:flex;align-items:center;gap:8px;padding:6px 0;border-bottom:1px solid var(--border-secondary);font-size:0.8rem}
    .collaborator-item:last-child{border-bottom:none}
    .collaborator-avatar{width:24px;height:24px;border-radius:50%;background:var(--accent-primary);color:#fff;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:500}
    .collaborator-name{color:var(--text-primary);flex:1}
    .collaborator-status{width:8px;height:8px;border-radius:50%;background:var(--inbox-accepted)}
    .collaborator-status.away{background:var(--inbox-pending)}
    .collaborator-status.offline{background:var(--inbox-rejected)}
    
    .connection-dot{position:absolute;width:20px;height:20px;background:var(--accent-primary);border:3px solid #fff;border-radius:50%;cursor:crosshair;z-index:10;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .connection-dot:hover{transform:scale(1.2);background:var(--accent-secondary)}
    .connection-dot.input{left:-10px;top:50%;transform:translateY(-50%)}
    .connection-dot.output{right:-10px;top:50%;transform:translateY(-50%)}
    .connection-dot.top{top:-10px;left:50%;transform:translateX(-50%)}
    .connection-dot.bottom{bottom:-10px;left:50%;transform:translateX(-50%)}
    
    .connection{position:absolute;pointer-events:none;z-index:5}
    .connection-line{stroke:var(--accent-primary);stroke-width:3;fill:none;marker-end:url(#arrowhead);filter:drop-shadow(0 2px 4px var(--shadow-primary))}
    .connection-line:hover{stroke:var(--accent-secondary);stroke-width:4}
    
    .toolbar{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:15px;z-index:1000;min-width:200px;transition:all 0.3s ease;box-shadow:0 8px 25px var(--shadow-primary)}
    .tool-label{color:var(--text-secondary);font-size:.8rem;margin-bottom:8px;text-align:center;font-weight:400}
    .tool-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px;border-radius:6px;cursor:pointer;margin:2px;width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;font-size:1rem;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .tool-btn:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    .tool-btn.active{background:var(--accent-primary);color:#fff}
    .tool-btn.cache-status-btn{background:var(--accent-primary);color:#fff}
    .tool-btn.cache-status-btn:hover{background:var(--accent-secondary)}
    .tool-btn.force-save-btn{background:var(--inbox-pending);color:#fff}
    .tool-btn.force-save-btn:hover{background:var(--inbox-accepted)}
    .tool-btn.snap-grid-btn{background:var(--accent-primary);color:#fff}
    .tool-btn.snap-grid-btn:hover{background:var(--accent-secondary)}
    .tool-btn.snap-grid-btn:not(.active){background:var(--border-primary);color:var(--text-primary)}
    .tool-btn.snap-tiles-btn{background:var(--accent-primary);color:#fff}
    .tool-btn.snap-tiles-btn:hover{background:var(--accent-secondary)}
    .tool-btn.snap-tiles-btn:not(.active){background:var(--border-primary);color:var(--text-primary)}
    
    .ai-panel{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:20px;z-index:1000;width:300px;display:none;transition:all 0.3s ease;box-shadow:0 8px 25px var(--shadow-primary)}
    .ai-panel.show{display:block}
    .ai-title{font-size:1.1rem;font-weight:400;margin-bottom:15px;color:var(--text-primary)}
    .ai-input{width:100%;padding:10px;border:1px solid var(--border-secondary);border-radius:6px;background:var(--bg-secondary);color:var(--text-primary);margin-bottom:15px;resize:vertical;min-height:80px;font-weight:400}
    .ai-btn{background:var(--accent-primary);color:#fff;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;width:100%;transition:all 0.3s ease;box-shadow:0 4px 12px var(--shadow-primary)}
    .ai-btn:hover{background:var(--accent-secondary);box-shadow:0 6px 16px var(--shadow-secondary)}
    .ai-btn:disabled{background:var(--border-secondary);cursor:not-allowed;box-shadow:none}
    .ai-suggestions{margin-top:15px;max-height:200px;overflow-y:auto}
    .ai-suggestion{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:10px;margin-bottom:8px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary);font-weight:400}
    .ai-suggestion:hover{background:var(--border-primary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    .notification{position:fixed;top:80px;right:20px;background:var(--accent-primary);color:#fff;padding:12px 20px;border-radius:8px;box-shadow:0 8px 25px var(--shadow-primary);z-index:10000;transform:translateX(400px);transition:.3s transform;max-width:300px}
    .notification.show{transform:translateX(0)}
    .notification.error{background:#f44336}
    
    .connection-mode{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:15px;z-index:1000;margin-bottom:10px;box-shadow:0 8px 25px var(--shadow-primary)}
    .connection-mode-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 16px;border-radius:6px;cursor:pointer;margin:2px;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .connection-mode-btn:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    .connection-mode-btn.active{background:var(--accent-primary);color:#fff}
    
    .loading{display:inline-block;width:16px;height:16px;border:2px solid transparent;border-top:2px solid currentColor;border-radius:50%;animation:spin 1s linear infinite;margin-right:8px}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
    
    .modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);backdrop-filter:blur(5px);z-index:10000;display:none;align-items:center;justify-content:center}
    .modal-overlay.show{display:flex}
    .modal{background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:12px;padding:30px;min-width:400px;max-width:600px;box-shadow:0 20px 40px var(--shadow-primary)}
    .modal-title{font-size:1.3rem;font-weight:400;margin-bottom:20px;color:var(--text-primary)}
    .modal-input{width:100%;padding:15px;border:1px solid var(--border-secondary);border-radius:8px;background:var(--bg-secondary);color:var(--text-primary);font-size:1rem;margin-bottom:20px;outline:none;transition:border-color 0.3s ease;font-weight:400}
    .modal-input:focus{border-color:var(--accent-primary)}
    .modal-buttons{display:flex;gap:10px;justify-content:flex-end}
    .modal-btn{padding:12px 24px;border:none;border-radius:8px;cursor:pointer;font-size:1rem;transition:all 0.3s ease;box-shadow:0 4px 12px var(--shadow-primary)}
    .modal-btn.primary{background:var(--accent-primary);color:#fff}
    .modal-btn.primary:hover{background:var(--accent-secondary);box-shadow:0 6px 16px var(--shadow-secondary)}
    .modal-btn.secondary{background:var(--border-primary);color:var(--text-primary)}
    .modal-btn.secondary:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    .recent-colors-popup{position:absolute;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:10px;box-shadow:0 10px 25px var(--shadow-primary);z-index:1000;display:grid;grid-template-columns:repeat(5,1fr);gap:5px;min-width:200px}
    .recent-colors-popup .color-option{width:25px;height:25px;border-radius:4px;cursor:pointer;border:2px solid transparent;transition:all 0.2s ease}
    .recent-colors-popup .color-option:hover{border-color:var(--accent-primary);transform:scale(1.1)}
    
    /* Share section styling */
    .share-section{display:none;margin-top:20px;padding:15px;background:var(--bg-secondary);border-radius:8px;border:1px solid var(--border-secondary);box-shadow:0 2px 8px var(--shadow-primary)}
    .share-section.show{display:block}
    .share-toggle{background:var(--accent-primary);color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:0.9rem;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .share-toggle:hover{background:var(--accent-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    .share-toggle.off{background:var(--border-primary);color:var(--text-primary)}
    .share-toggle.off:hover{background:var(--border-secondary)}
    .share-email{width:100%;padding:8px;border-radius:6px;border:1px solid var(--border-secondary);background:var(--bg-tertiary);color:var(--text-primary);margin-top:10px;font-weight:400}
    .share-btn{margin-top:8px;background:var(--accent-primary);color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;width:100%;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .share-btn:hover{background:var(--accent-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    /* Smooth animations for real-time updates */
    .tile-updating{transition:all 0.1s ease-out}
    .connection-updating{transition:all 0.1s ease-out}
    
    /* Browser-like tab interface */
    .tab-container{display:flex;background:var(--bg-secondary);border-bottom:1px solid var(--border-primary);overflow-x:auto;padding:0 20px}
    .tab{background:var(--tab-inactive);color:var(--text-secondary);border:none;padding:12px 20px;cursor:pointer;transition:all 0.3s ease;border-radius:8px 8px 0 0;margin-right:2px;font-weight:400;position:relative;min-width:120px;text-align:center}
    .tab:hover{background:var(--tab-hover);color:var(--text-primary)}
    .tab.active{background:var(--tab-active);color:#fff}
    .tab-close{position:absolute;top:8px;right:8px;background:rgba(255,255,255,0.2);color:inherit;border:none;border-radius:50%;width:16px;height:16px;cursor:pointer;font-size:10px;opacity:0;transition:opacity 0.3s ease}
    .tab:hover .tab-close{opacity:1}
    .tab-close:hover{background:rgba(255,255,255,0.3)}
    
    /* Auto-save indicator */
    .auto-save-indicator{position:fixed;bottom:20px;left:320px;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:8px 12px;box-shadow:0 4px 12px var(--shadow-primary);z-index:1000;font-size:0.8rem;color:var(--text-secondary);transition:all 0.3s ease;opacity:0;transform:translateY(20px)}
    .auto-save-indicator.show{opacity:1;transform:translateY(0)}
    .auto-save-indicator.saving{color:var(--inbox-pending)}
    .auto-save-indicator.saved{color:var(--inbox-accepted)}
    .auto-save-indicator.error{color:var(--inbox-rejected)}
    
    /* Snap to grid and other tiles */
    .snap-indicator{position:absolute;width:2px;height:2px;background:var(--accent-primary);border-radius:50%;pointer-events:none;z-index:1000;opacity:0;transition:opacity 0.2s ease}
    .snap-indicator.show{opacity:1}
    .snap-indicator.grid{background:var(--accent-primary)}
    .snap-indicator.tile{background:var(--inbox-accepted)}
    
    /* Shape palette */
    .shape-palette{position:absolute;top:10px;left:10px;display:grid;grid-template-columns:repeat(3,1fr);gap:4px;opacity:0;transition:opacity 0.3s ease;z-index:1000}
    .tile:hover .shape-palette{opacity:1}
    .shape-option{width:24px;height:24px;border:2px solid var(--border-primary);border-radius:4px;cursor:pointer;transition:all 0.3s ease;background:var(--bg-secondary);display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--text-secondary)}
    .shape-option:hover{transform:scale(1.1);border-color:var(--accent-primary)}
    .shape-option.selected{border-color:var(--accent-primary);background:var(--accent-primary);color:#fff}
    
    /* Different tile shapes */
    .tile.rounded{border-radius:20px}
    .tile.circular{border-radius:50%;min-width:120px;min-height:120px}
    .tile.hexagon{clip-path:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)}
    .tile.diamond{clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)}
    .tile.triangle{clip-path:polygon(50% 0%, 0% 100%, 100% 100%)}
    .tile.parallelogram{clip-path:polygon(25% 0%, 100% 0%, 75% 100%, 0% 100%)}
    
    /* Grid snapping visual feedback */
    .grid-snap-line{position:absolute;background:var(--accent-primary);opacity:0.3;pointer-events:none;z-index:999;transition:opacity 0.2s ease}
    .grid-snap-line.show{opacity:0.6}
    .grid-snap-line.vertical{width:1px}
    .grid-snap-line.horizontal{height:1px}
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">Flowpad</div>
    <div class="user-info">
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <span id="theme-icon">üåô</span>
      </button>
      <span id="userName">User</span>
      <button class="signout-btn" onclick="signOut()">Sign Out</button>
    </div>
  </div>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-content">
      <button class="new-graph-btn" onclick="createNewGraph()">+ New Graph</button>
      
      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('myGraphs')">
          <span><span class="folder-icon">üìÅ</span>My Graphs</span>
          <span class="folder-arrow">‚ñ∂</span>
        </div>
        <div class="folder-content expanded" id="myGraphs">
          <div id="ownGraphs"></div>
        </div>
      </div>
      
      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('sharedGraphs')">
          <span><span class="folder-icon">üë•</span>Shared With Me</span>
          <span class="folder-arrow">‚ñ∂</span>
        </div>
        <div class="folder-content" id="sharedGraphs">
          <div id="sharedGraphsContent"></div>
        </div>
      </div>
      
      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('inbox')">
          <span><span class="folder-icon">üì•</span>Inbox</span>
          <span class="folder-arrow">‚ñ∂</span>
        </div>
        <div class="folder-content" id="inbox">
          <div id="inboxContent"></div>
        </div>
      </div>
      
      <div class="share-section" id="shareSection">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
          <span style="font-weight:500;color:var(--text-primary)">Share Current Graph</span>
          <button class="share-toggle" id="shareToggle" onclick="toggleSharing()">ON</button>
        </div>
        <input type="email" id="shareEmail" class="share-email" placeholder="Enter email address" style="display:none"/>
        <button id="shareBtn" class="share-btn" style="display:none" onclick="shareGraph()">Share</button>
      </div>
    </div>
  </div>
  
  <div class="canvas-container">
    <div class="tab-container" id="tabContainer">
      <!-- Tabs will be dynamically added here -->
    </div>
    <div class="canvas" id="canvas"></div>
  </div>
  
  <div class="connection-mode" id="connectionMode" style="display:none;">
    <div style="color:var(--text-secondary);font-size:0.8rem;margin-bottom:8px;text-align:center;">Connection Mode</div>
    <button class="connection-mode-btn" onclick="setConnectionMode('none')" id="modeNone">Select</button>
    <button class="connection-mode-btn active" onclick="setConnectionMode('connect')" id="modeConnect">Connect</button>
  </div>
  
  <div class="toolbar" id="toolbar" style="display:none;">
    <div class="tool-label">Tools</div>
    <button class="tool-btn" onclick="addTile()" title="Add Tile">+</button>
    <button class="tool-btn" onclick="deleteSelected()" title="Delete Selected">DEL</button>
    <button class="tool-btn" onclick="centerCanvas()" title="Center Canvas">‚åÇ</button>
    <button class="tool-btn" onclick="toggleAIPanel()" title="AI Suggestions">AI</button>
  </div>
  
  <div class="ai-panel" id="aiPanel">
    <div class="ai-title">AI Suggestions</div>
    <textarea class="ai-input" id="aiInput" placeholder="Describe what you want to add or connect..."></textarea>
    <button class="ai-btn" onclick="getAISuggestions()" id="aiBtn">
      <span id="aiBtnText">Get Suggestions</span>
    </button>
    <div class="ai-suggestions" id="aiSuggestions"></div>
  </div>
  
  <div id="notification" class="notification"></div>

  <!-- Collaborative Users List -->
  <div class="collaborators-list" id="collaboratorsList">
    <div class="collaborators-header">
      <span class="collaborators-title">Collaborators</span>
      <span class="collaborators-count" id="collaboratorsCount">0</span>
    </div>
    <div id="collaboratorsContent"></div>
  </div>

  <!-- Auto-save Indicator -->
  <div class="auto-save-indicator" id="autoSaveIndicator">
    <span id="autoSaveText">Ready</span>
  </div>

  <!-- New Graph Modal -->
  <div class="modal-overlay" id="newGraphModal">
    <div class="modal">
      <div class="modal-title">Create New Graph</div>
      <input type="text" class="modal-input" id="newGraphTitle" placeholder="Enter graph title..." maxlength="100">
      <div class="modal-buttons">
        <button class="modal-btn secondary" onclick="closeNewGraphModal()">Cancel</button>
        <button class="modal-btn primary" onclick="confirmNewGraph()">Create</button>
      </div>
    </div>
  </div>

  <svg style="position:absolute;width:0;height:0;pointer-events:none">
        <defs>
      <marker id="arrowhead" markerWidth="12" markerHeight="8" refX="10" refY="4" orient="auto">
        <polygon points="0 0, 12 4, 0 8" fill="var(--accent-primary)"></polygon>
          </marker>
        </defs>
      </svg>

  <script>
    let currentUser = null, currentGraph = null, tiles = [], connections = [], selectedTile = null, isDragging = false, dragOffset = {x: 0, y: 0};
    let connectionMode = 'connect';
    let isConnecting = false;
    let connectionStart = null;
    let hoveredTile = null;
    let isPanning = false;
    let panStart = {x: 0, y: 0};
    let canvasOffset = {x: 0, y: 0};
    let openTabs = [];
    let activeTabId = null;
    let realtimeUpdateTimer = null;
    let pendingUpdates = [];
    let autoSaveTimer = null;
    let lastSaveTime = 0;
    let isDirty = false;
    let snapToGrid = true;
    let snapToTiles = true;
    let gridSize = 20;
    let snapIndicators = [];
    let snapLines = [];
    
    const canvas = document.getElementById('canvas');
    const tabContainer = document.getElementById('tabContainer');

    document.addEventListener('DOMContentLoaded', init);

    async function init() {
      await checkAuth();
      await loadGraphs();
      await loadInbox();
      setupCanvas();
      setupTheme();
      setupRealtimeUpdates();
      setupAutoSave();
      setupSnapping();
    }

    function setupSnapping() {
      // Create snap indicators
      for (let i = 0; i < 10; i++) {
        const indicator = document.createElement('div');
        indicator.className = 'snap-indicator';
        indicator.id = `snap-indicator-${i}`;
        canvas.appendChild(indicator);
        snapIndicators.push(indicator);
      }
      
      // Create snap lines
      for (let i = 0; i < 6; i++) {
        const line = document.createElement('div');
        line.className = 'grid-snap-line';
        line.id = `snap-line-${i}`;
        canvas.appendChild(line);
        snapLines.push(line);
      }
    }

    function getSnapPosition(x, y) {
      let snappedX = x;
      let snappedY = y;
      let snapDistance = 10; // Distance within which to snap
      
      // Snap to grid
      if (snapToGrid) {
        const gridX = Math.round(x / gridSize) * gridSize;
        const gridY = Math.round(y / gridSize) * gridSize;
        
        if (Math.abs(x - gridX) < snapDistance) {
          snappedX = gridX;
          showSnapIndicator(gridX, y, 'grid');
        }
        if (Math.abs(y - gridY) < snapDistance) {
          snappedY = gridY;
          showSnapIndicator(x, gridY, 'grid');
        }
      }
      
      // Snap to other tiles
      if (snapToTiles) {
        tiles.forEach(tile => {
          if (tile === selectedTile) return;
          
          const tileRect = tile.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          const tileX = tileRect.left - canvasRect.left;
          const tileY = tileRect.top - canvasRect.top;
          const tileWidth = tileRect.width;
          const tileHeight = tileRect.height;
          
          // Snap to tile edges
          const edges = [
            { x: tileX, y: y, type: 'left' },
            { x: tileX + tileWidth, y: y, type: 'right' },
            { x: x, y: tileY, type: 'top' },
            { x: x, y: tileY + tileHeight, type: 'bottom' }
          ];
          
          edges.forEach(edge => {
            if (Math.abs(x - edge.x) < snapDistance) {
              snappedX = edge.x;
              showSnapIndicator(edge.x, y, 'tile');
              showSnapLine(edge.x, 'vertical');
            }
            if (Math.abs(y - edge.y) < snapDistance) {
              snappedY = edge.y;
              showSnapIndicator(x, edge.y, 'tile');
              showSnapLine(edge.y, 'horizontal');
            }
          });
          
          // Snap to tile center
          const centerX = tileX + tileWidth / 2;
          const centerY = tileY + tileHeight / 2;
          
          if (Math.abs(x - centerX) < snapDistance) {
            snappedX = centerX;
            showSnapIndicator(centerX, y, 'tile');
          }
          if (Math.abs(y - centerY) < snapDistance) {
            snappedY = centerY;
            showSnapIndicator(x, centerY, 'tile');
          }
        });
      }
      
      return { x: snappedX, y: snappedY };
    }

    function showSnapIndicator(x, y, type) {
      const indicator = snapIndicators.find(ind => !ind.classList.contains('show'));
      if (indicator) {
        indicator.style.left = (x + canvasOffset.x) + 'px';
        indicator.style.top = (y + canvasOffset.y) + 'px';
        indicator.className = `snap-indicator show ${type}`;
        
        // Hide after a short time
        setTimeout(() => {
          indicator.classList.remove('show');
        }, 200);
      }
    }

    function showSnapLine(position, orientation) {
      const line = snapLines.find(l => !l.classList.contains('show'));
      if (line) {
        if (orientation === 'vertical') {
          line.style.left = (position + canvasOffset.x) + 'px';
          line.style.top = '0px';
          line.style.height = '100%';
          line.className = 'grid-snap-line show vertical';
        } else {
          line.style.top = (position + canvasOffset.y) + 'px';
          line.style.left = '0px';
          line.style.width = '100%';
          line.className = 'grid-snap-line show horizontal';
        }
        
        // Hide after a short time
        setTimeout(() => {
          line.classList.remove('show');
        }, 300);
      }
    }

    function clearSnapIndicators() {
      snapIndicators.forEach(ind => ind.classList.remove('show'));
      snapLines.forEach(line => line.classList.remove('show'));
    }

    function setupAutoSave() {
      // Set up automatic saving every 15 seconds
      autoSaveTimer = setInterval(() => {
        if (isDirty && currentGraph && Date.now() - lastSaveTime > 15000) {
          autoSaveGraph();
        }
      }, 15000);
    }

    function setupRealtimeUpdates() {
      // Set up real-time updates every 2 seconds
      setInterval(() => {
        if (pendingUpdates.length > 0 && currentGraph) {
          sendRealtimeUpdates();
        }
      }, 2000);
    }

    function markAsDirty() {
      isDirty = true;
      lastSaveTime = Date.now();
    }

    async function autoSaveGraph() {
      if (!currentGraph || !isDirty) return;
      
      const indicator = document.getElementById('autoSaveIndicator');
      const text = document.getElementById('autoSaveText');
      
      try {
        // Show saving indicator
        indicator.classList.add('show', 'saving');
        text.textContent = 'Saving...';
        
        const token = localStorage.getItem('flowpad_token');
        const data = {
          tiles: tiles.map(t => ({
            id: t.dataset.tileId,
            x: parseInt(t.dataset.baseX) || 0,
            y: parseInt(t.dataset.baseY) || 0,
            title: t.querySelector('.tile-title').value || '',
            content: t.querySelector('.tile-content').value || '',
            color: t.style.background || '#ffffff'
          })),
          connections: connections
        };
        
        const res = await fetch(`/api/graphs/${currentGraph.id}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ title: currentGraph.title, data })
        });
        
        if (res.ok) {
          isDirty = false;
          lastSaveTime = Date.now();
          
          // Show saved indicator
          indicator.classList.remove('saving');
          indicator.classList.add('saved');
          text.textContent = `Saved at ${new Date().toLocaleTimeString()}`;
          
          // Hide after 3 seconds
          setTimeout(() => {
            indicator.classList.remove('show', 'saved');
          }, 3000);
          
          console.log('Auto-saved graph successfully');
        } else {
          throw new Error('Save failed');
        }
      } catch (error) {
        console.error('Auto-save failed:', error);
        
        // Show error indicator
        indicator.classList.remove('saving');
        indicator.classList.add('error');
        text.textContent = 'Save failed';
        
        // Hide after 5 seconds
        setTimeout(() => {
          indicator.classList.remove('show', 'error');
        }, 5000);
      }
    }

    function scheduleSave() {
      markAsDirty();
      // Debounced save - only save after 500ms of inactivity
      clearTimeout(window.saveTimeout);
      window.saveTimeout = setTimeout(() => {
        if (isDirty) {
          autoSaveGraph();
        }
      }, 500);
    }

    function setupTheme() {
      const savedTheme = localStorage.getItem('flowpad_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      updateThemeIcon(savedTheme);
      
      // Apply tile colors for the current theme if tiles exist
      if (tiles.length > 0) {
        updateTileColorsForTheme(savedTheme);
      }
    }

    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('flowpad_theme', newTheme);
      updateThemeIcon(newTheme);
      
      // Update tile colors for the new theme
      updateTileColorsForTheme(newTheme);
    }

    function updateThemeIcon(theme) {
      const icon = document.getElementById('theme-icon');
      icon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
    }

    function toggleFolder(folderId) {
      const folder = document.getElementById(folderId);
      const header = folder.previousElementSibling;
      const arrow = header.querySelector('.folder-arrow');
      
      folder.classList.toggle('expanded');
      arrow.classList.toggle('expanded');
      header.classList.toggle('active');
    }

    function toggleSharing() {
      const toggle = document.getElementById('shareToggle');
      const email = document.getElementById('shareEmail');
      const shareBtn = document.getElementById('shareBtn');
      
      if (toggle.textContent === 'ON') {
        toggle.textContent = 'OFF';
        toggle.classList.add('off');
        email.style.display = 'none';
        shareBtn.style.display = 'none';
        // Turn off sharing
        if (currentGraph) {
          currentGraph.sharingEnabled = false;
        }
      } else {
        toggle.textContent = 'ON';
        toggle.classList.remove('off');
        email.style.display = 'block';
        shareBtn.style.display = 'block';
        // Turn on sharing
        if (currentGraph) {
          currentGraph.sharingEnabled = true;
        }
      }
    }

    function createTab(graph) {
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.dataset.graphId = graph.id;
      tab.innerHTML = `
        ${graph.title || 'Untitled Graph'}
        <button class="tab-close" onclick="closeTab('${graph.id}')" title="Close tab">√ó</button>
      `;
      
      tab.addEventListener('click', () => {
        if (graph.id !== activeTabId) {
          switchToTab(graph.id);
        }
      });
      
      openTabs.push({ id: graph.id, element: tab, graph: graph });
      tabContainer.appendChild(tab);
      
      return tab;
    }

    function closeTab(graphId) {
      const tabIndex = openTabs.findIndex(tab => tab.id === graphId);
      if (tabIndex === -1) return;
      
      const tab = openTabs[tabIndex];
      tab.element.remove();
      openTabs.splice(tabIndex, 1);
      
      if (activeTabId === graphId) {
        if (openTabs.length > 0) {
          switchToTab(openTabs[0].id);
        } else {
          // No tabs left, show empty state
          activeTabId = null;
          currentGraph = null;
          tiles = [];
          connections = [];
          renderCanvas();
          document.getElementById('shareSection').style.display = 'none';
        }
      }
    }

    function switchToTab(graphId) {
      const tab = openTabs.find(t => t.id === graphId);
      if (!tab) return;
      
      // Update active tab styling
      openTabs.forEach(t => t.element.classList.remove('active'));
      tab.element.classList.add('active');
      activeTabId = graphId;
      
      // Load the graph
      loadGraph(tab.graph);
      
      // Auto-scroll to center the graph
      centerCanvas();
    }

    async function loadInbox() {
      const token = localStorage.getItem('flowpad_token');
      try {
        const res = await fetch('/api/graphs/inbox', { headers: { Authorization: `Bearer ${token}` } });
        if (res.ok) {
          const inboxItems = await res.json();
          renderInbox(inboxItems);
        }
      } catch (error) {
        console.error('Failed to load inbox:', error);
      }
    }

    function renderInbox(inboxItems) {
      const container = document.getElementById('inboxContent');
      container.innerHTML = '';
      
      if (inboxItems.length === 0) {
        container.innerHTML = '<div style="text-align:center;color:var(--text-secondary);padding:20px;">No pending invitations</div>';
        return;
      }
      
      inboxItems.forEach(item => {
        const inboxItem = document.createElement('div');
        inboxItem.className = `inbox-item ${item.status}`;
        
        inboxItem.innerHTML = `
          <div class="inbox-title">${item.graphTitle}</div>
          <div class="inbox-meta">From: ${item.sharerName} ‚Ä¢ ${new Date(item.sharedAt).toLocaleString()}</div>
          ${item.status === 'pending' ? `
            <div class="inbox-actions">
              <button class="inbox-btn accept" onclick="respondToInvitation('${item.id}', 'accept')">Accept</button>
              <button class="inbox-btn reject" onclick="respondToInvitation('${item.id}', 'reject')">Reject</button>
            </div>
          ` : ''}
        `;
        
        container.appendChild(inboxItem);
      });
    }

    async function respondToInvitation(invitationId, response) {
      const token = localStorage.getItem('flowpad_token');
      try {
        const res = await fetch(`/api/graphs/inbox/${invitationId}/${response}`, { 
          method: 'POST', 
          headers: { Authorization: `Bearer ${token}` } 
        });
        
        if (res.ok) {
          notify(`Invitation ${response}ed successfully`, 'success');
          await loadInbox(); // Refresh inbox
          if (response === 'accept') {
            await loadGraphs(); // Refresh graphs list
          }
        } else {
          notify(`Failed to ${response} invitation`, 'error');
        }
      } catch (error) {
        notify(`Failed to ${response} invitation: ${error.message}`, 'error');
      }
    }

    function deleteGraph(graphId) {
      if (confirm('Are you sure you want to delete this graph? This action cannot be undone.')) {
        // Remove from UI first
        const graphElement = document.querySelector(`[data-graph-id="${graphId}"]`);
        if (graphElement) {
          graphElement.remove();
        }
        
        // Close tab if open
        if (openTabs.find(tab => tab.id === graphId)) {
          closeTab(graphId);
        }
        
        // Remove from arrays
        if (currentGraph && currentGraph.id === graphId) {
          currentGraph = null;
          tiles = [];
          connections = [];
          renderCanvas();
          document.getElementById('shareSection').style.display = 'none';
        }
        
        // TODO: Add API call to delete from server
        notify('Graph deleted', 'success');
      }
    }

    function renderGraphList(list, id) {
      const container = id === 'sharedGraphs' ? document.getElementById('sharedGraphsContent') : document.getElementById(id);
      container.innerHTML = '';
      
      list.forEach(g => {
        const item = document.createElement('div');
        item.className = 'graph-item';
        item.dataset.graphId = g.id;
        
        item.innerHTML = `
          <div class="graph-title">${g.title}</div>
          <div class="graph-meta">Updated: ${new Date(g.updated_at).toLocaleString()}</div>
          <button class="graph-delete" onclick="deleteGraph('${g.id}')" title="Delete graph">√ó</button>
        `;
        
        item.addEventListener('click', (e) => {
          if (!e.target.classList.contains('graph-delete')) {
            loadGraph(g);
            // Auto-scroll to center the graph
            centerCanvas();
          }
        });
        
        container.appendChild(item);
      });
    }

    function loadGraph(graph) {
      currentGraph = graph;
      tiles = (graph.data?.tiles || []).map(t => {
        const tile = createTile(t.x, t.y, t.title, t.content, t.id);
        if (t.color) {
          tile.style.background = t.color;
        }
        return tile;
      });
      connections = graph.data?.connections || [];
      
      // Create or update tab
      if (!openTabs.find(tab => tab.id === graph.id)) {
        createTab(graph);
      }
      switchToTab(graph.id);
      
      // Show share section
      document.getElementById('shareSection').style.display = 'block';
      if (graph.sharingEnabled !== false) {
        document.getElementById('shareToggle').textContent = 'ON';
        document.getElementById('shareToggle').classList.remove('off');
        document.getElementById('shareEmail').style.display = 'block';
        document.getElementById('shareBtn').style.display = 'block';
      } else {
        document.getElementById('shareToggle').textContent = 'OFF';
        document.getElementById('shareToggle').classList.add('off');
        document.getElementById('shareEmail').style.display = 'none';
        document.getElementById('shareBtn').style.display = 'none';
      }
      
      renderCanvas();
      
      // Load collaborators
      loadCollaborators();
      
      // Add cache status buttons
      addCacheStatusButton();
      
      // Reset dirty state
      isDirty = false;
      
      // Apply theme colors to loaded tiles
      const currentTheme = document.documentElement.getAttribute('data-theme');
      updateTileColorsForTheme(currentTheme);
    }

    function addPendingUpdate(type, data) {
      pendingUpdates.push({ type, data, timestamp: Date.now() });
    }

    function sendRealtimeUpdates() {
      if (pendingUpdates.length === 0 || !currentGraph) return;
      
      const updates = [...pendingUpdates];
      pendingUpdates = [];
      
      // Send updates to server
      fetch(`/api/graphs/${currentGraph.id}/realtime`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('flowpad_token')}`
        },
        body: JSON.stringify({ updates })
      }).catch(error => {
        console.error('Failed to send real-time updates:', error);
        // Re-add failed updates
        pendingUpdates.unshift(...updates);
      });
    }

    function updateDragging(e) {
      // More responsive dragging with direct mouse coordinates
      let x = e.clientX - dragOffset.x - canvasOffset.x;
      let y = e.clientY - dragOffset.y - canvasOffset.y;
      
      // Apply snapping
      const snapped = getSnapPosition(x, y);
      x = snapped.x;
      y = snapped.y;
      
      // Update base coordinates and current position
      selectedTile.dataset.baseX = x;
      selectedTile.dataset.baseY = y;
      selectedTile.style.left = (x + canvasOffset.x) + 'px';
      selectedTile.style.top = (y + canvasOffset.y) + 'px';
      
      // Add smooth animation class
      selectedTile.classList.add('tile-updating');
      
      // Update connections immediately when tile moves
      renderConnections();
      
      // Add to pending updates for real-time sync
      addPendingUpdate('tile_move', {
        tileId: selectedTile.dataset.tileId,
        x: x,
        y: y
      });
      
      // Mark as dirty for auto-save
      markAsDirty();
    }

    function finishDragging() {
      if (selectedTile) {
        selectedTile.classList.remove('tile-updating');
        selectedTile = null;
      }
      isDragging = false;
      
      // Clear snap indicators
      clearSnapIndicators();
    }

    function deleteSelected() {
      if (selectedTile) {
        // Delete the tile
        const tileId = selectedTile.dataset.tileId;
        selectedTile.remove();
        tiles = tiles.filter(t => t.dataset.tileId !== tileId);
        
        // Remove connections involving this tile
        connections = connections.filter(conn => 
          conn.fromTile !== tileId && conn.toTile !== tileId
        );
        
        // Add to pending updates
        addPendingUpdate('tile_delete', { tileId });
        
        // Mark as dirty
        markAsDirty();
        
        clearSelection();
        renderCanvas();
        notify('Tile deleted', 'success');
      }
    }

    function deleteConnection(connectionId) {
      connections = connections.filter(conn => conn.id !== connectionId);
      
      // Add to pending updates
      addPendingUpdate('connection_delete', { connectionId });
      
      // Mark as dirty
      markAsDirty();
      
      renderConnections();
      notify('Connection deleted', 'success');
    }

    function setupCanvas() {
      canvas.addEventListener('mousedown', handleCanvasMouseDown);
      canvas.addEventListener('mousemove', handleCanvasMouseMove);
      canvas.addEventListener('mouseup', handleCanvasMouseUp);
      canvas.addEventListener('click', handleCanvasClick);
    }

    function handleCanvasMouseDown(e) {
      const tile = e.target.closest('.tile');
      const dot = e.target.closest('.connection-dot');
      
      if (dot) {
        startConnection(e, dot);
      } else if (tile && e.target.tagName !== 'TEXTAREA') {
        // Only start dragging if not clicking on textarea
        startDragging(e, tile);
      } else if (!tile) {
        // Start panning when clicking on empty canvas
        startPanning(e);
      }
    }

    function handleCanvasMouseMove(e) {
      if (isConnecting && connectionStart) {
        updateConnectionPreview(e);
      } else if (isDragging && selectedTile) {
        updateDragging(e);
      } else if (isPanning) {
        updatePanning(e);
      }
    }

    function handleCanvasMouseUp(e) {
      if (isConnecting) {
        finishConnection(e);
      }
      if (isDragging) {
        finishDragging();
      }
      isPanning = false;
    }

    function handleCanvasClick(e) {
      if (e.target === canvas) {
        clearSelection();
      }
    }

    function startConnection(e, dot) {
      isConnecting = true;
      connectionStart = {
        tile: dot.closest('.tile'),
        dot: dot,
        x: e.clientX,
        y: e.clientY
      };
      e.stopPropagation();
    }

    function updateConnectionPreview(e) {
      // Remove existing preview
      const existingPreview = document.querySelector('.connection-preview');
      if (existingPreview) existingPreview.remove();
      
      // Create preview line
      const rect = canvas.getBoundingClientRect();
      const startX = connectionStart.x - rect.left;
      const startY = connectionStart.y - rect.top;
      const endX = e.clientX - rect.left;
      const endY = e.clientY - rect.top;
      
      const preview = createConnectionLine(startX, startY, endX, endY, true);
      preview.classList.add('connection-preview');
      canvas.appendChild(preview);
    }

    function finishConnection(e) {
      const targetTile = e.target.closest('.tile');
      const targetDot = e.target.closest('.connection-dot');
      
      if (targetTile && targetTile !== connectionStart.tile) {
        // Use automatic port selection if no specific dots were clicked
        let fromDotType = connectionStart.dot ? connectionStart.dot.dataset.dotType : null;
        let toDotType = targetDot ? targetDot.dataset.dotType : null;
        
        // If no specific dots, use automatic port selection
        if (!fromDotType || !toDotType) {
          const ports = findOptimalPort(connectionStart.tile, targetTile, fromDotType, toDotType);
          fromDotType = ports.fromPort.type;
          toDotType = ports.toPort.type;
        }
        
        const connection = {
          id: 'conn_' + Date.now(),
          fromTile: connectionStart.tile.dataset.tileId,
          fromDot: fromDotType,
          toTile: targetTile.dataset.tileId,
          toDot: toDotType,
          color: getRandomConnectionColor()
        };
        
        connections.push(connection);
        
        // Add to pending updates
        addPendingUpdate('connection_create', connection);
        
        // Mark as dirty
        markAsDirty();
        
        renderCanvas();
        notify('Connection created', 'success');
      }
      
      // Clean up
      const preview = document.querySelector('.connection-preview');
      if (preview) preview.remove();
      
      isConnecting = false;
      connectionStart = null;
    }

    function getRandomConnectionColor() {
      const colors = [
        '#3b82f6', // Blue
        '#ef4444', // Red
        '#10b981', // Green
        '#f59e0b', // Amber
        '#8b5cf6', // Purple
        '#ec4899', // Pink
        '#06b6d4', // Cyan
        '#84cc16', // Lime
        '#f97316', // Orange
        '#6366f1'  // Indigo
      ];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function saveRecentColor(color) {
      let recentColors = JSON.parse(localStorage.getItem('flowpad_recent_colors') || '[]');
      // Remove if already exists
      recentColors = recentColors.filter(c => c !== color);
      // Add to beginning
      recentColors.unshift(color);
      // Keep only last 10
      recentColors = recentColors.slice(0, 10);
      localStorage.setItem('flowpad_recent_colors', JSON.stringify(recentColors));
    }

    function getRecentColors() {
      return JSON.parse(localStorage.getItem('flowpad_recent_colors') || '[]');
    }

    function showRecentColorsPopup(tile, optionElement) {
      const recentColors = getRecentColors();
      
      // Create popup
      const popup = document.createElement('div');
      popup.className = 'recent-colors-popup';
      popup.style.cssText = `
        position: absolute;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 10px 25px var(--shadow-primary);
        z-index: 1000;
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 5px;
        min-width: 200px;
      `;
      
      // Position popup near the recent colors button
      const rect = optionElement.getBoundingClientRect();
      popup.style.left = (rect.left - 100) + 'px';
      popup.style.top = (rect.bottom + 5) + 'px';
      
      // Add recent colors
      recentColors.forEach(color => {
        const colorOption = document.createElement('div');
        colorOption.style.cssText = `
          width: 25px;
          height: 25px;
          background: ${color};
          border-radius: 4px;
          cursor: pointer;
          border: 2px solid transparent;
        `;
        colorOption.title = color;
        
        colorOption.addEventListener('click', () => {
          tile.style.background = color;
          tile.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
          optionElement.classList.add('selected');
          saveRecentColor(color);
          scheduleSave();
          popup.remove();
        });
        
        popup.appendChild(colorOption);
      });
      
      // Add close button
      if (recentColors.length === 0) {
        const noColors = document.createElement('div');
        noColors.textContent = 'No recent colors';
        noColors.style.cssText = `
          grid-column: 1 / -1;
          text-align: center;
          color: var(--text-secondary);
          padding: 10px;
        `;
        popup.appendChild(noColors);
      }
      
      // Close popup when clicking outside
      document.addEventListener('click', function closePopup(e) {
        if (!popup.contains(e.target) && !optionElement.contains(e.target)) {
          popup.remove();
          document.removeEventListener('click', closePopup);
        }
      });
      
      document.body.appendChild(popup);
    }

    function startPanning(e) {
      isPanning = true;
      panStart.x = e.clientX - canvasOffset.x;
      panStart.y = e.clientY - canvasOffset.y;
    }

    function startDragging(e, tile) {
      isDragging = true;
      selectedTile = tile;
      selectTile(tile);
      
      // Calculate offset relative to tile's current position
      const baseX = parseInt(tile.dataset.baseX) || 0;
      const baseY = parseInt(tile.dataset.baseY) || 0;
      dragOffset.x = e.clientX - (baseX + canvasOffset.x);
      dragOffset.y = e.clientY - (baseY + canvasOffset.y);
    }

    function updatePanning(e) {
      const deltaX = e.clientX - panStart.x;
      const deltaY = e.clientY - panStart.y;
      
      // Update pan start for next frame
      panStart.x = e.clientX;
      panStart.y = e.clientY;
      
      // Apply pan offset to canvas view (not individual tiles)
      canvasOffset.x += deltaX;
      canvasOffset.y += deltaY;
      
      // Update tile positions immediately for responsive feel
      tiles.forEach(t => {
        const baseX = parseInt(t.dataset.baseX) || parseInt(t.style.left) || 0;
        const baseY = parseInt(t.dataset.baseY) || parseInt(t.style.top) || 0;
        t.style.left = (baseX + canvasOffset.x) + 'px';
        t.style.top = (baseY + canvasOffset.y) + 'px';
      });
      
      // Update connections with new canvas offset
      renderConnections();
    }

    function updateDragging(e) {
      // More responsive dragging with direct mouse coordinates
      let x = e.clientX - dragOffset.x - canvasOffset.x;
      let y = e.clientY - dragOffset.y - canvasOffset.y;
      
      // Apply snapping
      const snapped = getSnapPosition(x, y);
      x = snapped.x;
      y = snapped.y;
      
      // Update base coordinates and current position
      selectedTile.dataset.baseX = x;
      selectedTile.dataset.baseY = y;
      selectedTile.style.left = (x + canvasOffset.x) + 'px';
      selectedTile.style.top = (y + canvasOffset.y) + 'px';
      
      // Add smooth animation class
      selectedTile.classList.add('tile-updating');
      
      // Update connections immediately when tile moves
      renderConnections();
      
      // Add to pending updates for real-time sync
      addPendingUpdate('tile_move', {
        tileId: selectedTile.dataset.tileId,
        x: x,
        y: y
      });
      
      // Mark as dirty for auto-save
      markAsDirty();
    }

    function finishDragging() {
      if (selectedTile) {
        selectedTile.classList.remove('tile-updating');
        selectedTile = null;
      }
      isDragging = false;
      
      // Clear snap indicators
      clearSnapIndicators();
    }

    function createTile(x = 100, y = 100, title = '', content = '', id = null, shape = 'rectangle') {
      const tile = document.createElement('div');
      tile.className = `tile ${shape}`;
      tile.dataset.tileId = id || 'tile_' + Date.now();
      tile.dataset.baseX = x;
      tile.dataset.baseY = y;
      tile.dataset.shape = shape;
      tile.style.left = (x + canvasOffset.x) + 'px';
      tile.style.top = (y + canvasOffset.y) + 'px';
      
      tile.innerHTML = `
        <div class="shape-palette">
          <div class="shape-option" data-shape="rectangle" title="Rectangle">‚ñ°</div>
          <div class="shape-option" data-shape="rounded" title="Rounded">‚óê</div>
          <div class="shape-option" data-shape="circular" title="Circle">‚óã</div>
          <div class="shape-option" data-shape="hexagon" title="Hexagon">‚¨°</div>
          <div class="shape-option" data-shape="diamond" title="Diamond">‚óá</div>
          <div class="shape-option" data-shape="triangle" title="Triangle">‚ñ≥</div>
        </div>
        <div class="color-picker-trigger" style="position:absolute;top:10px;right:10px;width:20px;height:20px;border-radius:50%;background:var(--accent-primary);cursor:pointer;border:2px solid var(--border-primary);transition:all 0.3s ease;opacity:0;z-index:1000" title="Change color"></div>
        <textarea class="tile-title" placeholder="Title">${title || ''}</textarea>
        <textarea class="tile-content" placeholder="Content">${content || ''}</textarea>
        <div class="connection-dot input" data-dot-type="input" title="Input connection"></div>
        <div class="connection-dot output" data-dot-type="output" title="Output connection"></div>
        <div class="connection-dot top" data-dot-type="top" title="Top connection"></div>
        <div class="connection-dot bottom" data-dot-type="bottom" title="Bottom connection"></div>
      `;
      
      // Set initial selected shape
      const shapeOption = tile.querySelector(`[data-shape="${shape}"]`);
      if (shapeOption) {
        shapeOption.classList.add('selected');
      }
      
      // Add shape selection functionality
      tile.querySelectorAll('.shape-option').forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          
          // Remove selected class from all options
          tile.querySelectorAll('.shape-option').forEach(opt => opt.classList.remove('selected'));
          
          // Add selected class to clicked option
          option.classList.add('selected');
          
          // Update tile shape
          const newShape = option.dataset.shape;
          tile.className = `tile ${newShape}`;
          tile.dataset.shape = newShape;
          
          // Mark as dirty
          markAsDirty();
          
          // Update connections
          renderConnections();
        });
      });
      
      // Add color picker trigger functionality
      const colorTrigger = tile.querySelector('.color-picker-trigger');
      colorTrigger.addEventListener('click', (e) => {
        e.stopPropagation();
        showColorPicker(tile, colorTrigger);
      });
      
      // Show color trigger on hover
      tile.addEventListener('mouseenter', () => {
        colorTrigger.style.opacity = '1';
      });
      
      tile.addEventListener('mouseleave', () => {
        colorTrigger.style.opacity = '0';
      });
      
      tile.querySelectorAll('textarea').forEach(t => t.addEventListener('input', scheduleSave));
      
      return tile;
    }

    function selectTile(tile) {
      clearSelection();
      selectedTile = tile;
      tile.classList.add('selected');
    }

    function clearSelection() {
      if (selectedTile) {
        selectedTile.classList.remove('selected');
        selectedTile = null;
      }
    }

    function addTile() {
      const newTile = createTile(200, 200, 'New Tile', '', null, 'rectangle');
      tiles.push(newTile);
      
      // Add to pending updates
      addPendingUpdate('tile_create', {
        id: newTile.dataset.tileId,
        x: 200,
        y: 200,
        title: 'New Tile',
        content: '',
        color: '#ffffff',
        shape: 'rectangle'
      });
      
      // Mark as dirty
      markAsDirty();
      
      renderCanvas();
      notify('New tile added', 'success');
    }

    function deleteSelected() {
      if (selectedTile) {
        const tileId = selectedTile.dataset.tileId;
        
        // Remove the tile from DOM
        selectedTile.remove();
        
        // Remove from tiles array
        tiles = tiles.filter(t => t !== selectedTile);
        
        // Remove all connections involving this tile
        connections = connections.filter(c => c.fromTile !== tileId && c.toTile !== tileId);
        
        // Clear selection
        selectedTile = null;
        
        // Re-render and save
        renderCanvas();
        scheduleSave();
        
        notify('Tile deleted successfully', 'success');
      } else {
        notify('No tile selected for deletion', 'error');
      }
    }

    function deleteConnection(connectionId) {
      const connectionIndex = connections.findIndex(c => c.id === connectionId);
      if (connectionIndex !== -1) {
        connections.splice(connectionIndex, 1);
        renderCanvas();
        scheduleSave();
        notify('Connection deleted successfully', 'success');
      }
    }

    function centerCanvas() {
      // Reset canvas panning to center
      canvasOffset.x = 0;
      canvasOffset.y = 0;
      
      // Update tile positions to their base coordinates
      tiles.forEach(t => {
        const baseX = parseInt(t.dataset.baseX) || 0;
        const baseY = parseInt(t.dataset.baseY) || 0;
        t.style.left = baseX + 'px';
        t.style.top = baseY + 'px';
      });
      
      // Re-render connections
      renderConnections();
      
      notify('Canvas centered', 'success');
    }

    function setConnectionMode(mode) {
      connectionMode = mode;
      document.querySelectorAll('.connection-mode-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
    }

    function toggleAIPanel() {
      const panel = document.getElementById('aiPanel');
      panel.classList.toggle('show');
    }

    async function getAISuggestions() {
      if (!currentGraph || !selectedTile) {
        notify('Please select a tile first', 'error');
        return;
      }

      const aiInput = document.getElementById('aiInput').value.trim();
      if (!aiInput) {
        notify('Please describe what you want to add', 'error');
        return;
      }

      const aiBtn = document.getElementById('aiBtn');
      const aiBtnText = document.getElementById('aiBtnText');
      aiBtn.disabled = true;
      aiBtnText.innerHTML = '<span class="loading"></span>Getting suggestions...';

      try {
        const token = localStorage.getItem('flowpad_token');
        const response = await fetch('/api/ai-suggestions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            targetTile: {
              id: selectedTile.dataset.tileId,
              content: selectedTile.querySelector('.tile-content').value
            },
            existingTiles: tiles.map(t => ({
              id: t.dataset.tileId,
              content: t.querySelector('.tile-content').value
            })),
            connections: connections
          })
        });

        if (!response.ok) {
          throw new Error('Failed to get AI suggestions');
        }

        const data = await response.json();
        displayAISuggestions(data);
      } catch (error) {
        notify('Failed to get AI suggestions: ' + error.message, 'error');
      } finally {
        aiBtn.disabled = false;
        aiBtnText.textContent = 'Get Suggestions';
      }
    }

    function displayAISuggestions(suggestions) {
      const container = document.getElementById('aiSuggestions');
      container.innerHTML = '';
      
      console.log('AI Response:', suggestions); // Debug log
      
      // Handle different response formats more robustly
      let suggestionsArray = [];
      
      if (suggestions && typeof suggestions === 'object') {
        if (suggestions.suggestions && Array.isArray(suggestions.suggestions)) {
          suggestionsArray = suggestions.suggestions;
        } else if (suggestions.data && Array.isArray(suggestions.data)) {
          suggestionsArray = suggestions.data;
        } else if (suggestions.text && typeof suggestions.text === 'string') {
          suggestionsArray = [suggestions.text];
        } else if (suggestions.content && typeof suggestions.content === 'string') {
          suggestionsArray = [suggestions.content];
        } else if (suggestions.description && typeof suggestions.description === 'string') {
          suggestionsArray = [suggestions.description];
        } else if (suggestions.message && typeof suggestions.message === 'string') {
          suggestionsArray = [suggestions.message];
        } else if (suggestions.response && typeof suggestions.response === 'string') {
          suggestionsArray = [suggestions.response];
        } else if (Array.isArray(suggestions)) {
          suggestionsArray = suggestions;
        } else {
          // Try to extract any meaningful text content
          const suggestionText = extractTextFromObject(suggestions);
          if (suggestionText) {
            suggestionsArray = [suggestionText];
          }
        }
      } else if (typeof suggestions === 'string') {
        suggestionsArray = [suggestions];
      }
      
      if (suggestionsArray.length > 0) {
        suggestionsArray.forEach((suggestion, index) => {
          const div = document.createElement('div');
          div.className = 'ai-suggestion';
          
          let displayText = '';
          if (typeof suggestion === 'string') {
            displayText = suggestion;
          } else if (suggestion && typeof suggestion === 'object') {
            displayText = extractTextFromObject(suggestion);
          } else {
            displayText = String(suggestion);
          }
          
          div.textContent = displayText;
          div.addEventListener('click', () => applyAISuggestion(suggestion));
          container.appendChild(div);
        });
      } else {
        container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">No suggestions available</div>';
      }
    }

    function extractTextFromObject(obj) {
      if (!obj || typeof obj !== 'object') return null;
      
      // Try common text fields
      const textFields = ['text', 'content', 'description', 'message', 'response', 'suggestion', 'title', 'name'];
      for (const field of textFields) {
        if (obj[field] && typeof obj[field] === 'string') {
          return obj[field];
        }
      }
      
      // Try to find any string value
      for (const key in obj) {
        if (typeof obj[key] === 'string' && obj[key].length > 0) {
          return obj[key];
        }
      }
      
      // Fallback to JSON string
      try {
        return JSON.stringify(obj, null, 2);
      } catch (e) {
        return 'Unable to process suggestion';
      }
    }

    function applyAISuggestion(suggestion) {
      if (selectedTile) {
        let content = '';
        
        if (typeof suggestion === 'string') {
          content = suggestion;
        } else if (suggestion && typeof suggestion === 'object') {
          content = extractTextFromObject(suggestion);
        } else {
          content = String(suggestion);
        }
        
        if (content) {
          selectedTile.querySelector('.tile-content').value = content;
          scheduleSave();
          notify('Suggestion applied!', 'success');
        } else {
          notify('Unable to apply suggestion', 'error');
        }
      } else {
        notify('Please select a tile first', 'error');
      }
    }

    function createConnectionLine(fromX, fromY, toX, toY, isPreview = false, color = null, connectionId = null) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.style.position = 'absolute';
      svg.style.left = '0';
      svg.style.top = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';
      svg.style.zIndex = isPreview ? '15' : '5';
      
      if (!isPreview) {
        svg.style.pointerEvents = 'auto';
        svg.style.cursor = 'pointer';
        svg.dataset.connectionId = connectionId;
        
        // Add click handler for deletion
        svg.addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm('Delete this connection?')) {
            deleteConnection(connectionId);
          }
        });
        
        // Add hover effect
        svg.addEventListener('mouseenter', () => {
          path.style.strokeWidth = '4';
          path.style.filter = 'drop-shadow(0 0 3px currentColor)';
          svg.style.cursor = 'pointer';
        });
        
        svg.addEventListener('mouseleave', () => {
          path.style.strokeWidth = '3';
          path.style.filter = 'none';
          svg.style.cursor = 'pointer';
        });
      }
      
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      
      // Always use curved lines for better visual appeal
      let pathData = createSmartPath(fromX, fromY, toX, toY);
      
      path.setAttribute('d', pathData);
      path.setAttribute('stroke', isPreview ? '#888' : (color || 'var(--accent-primary)'));
      path.setAttribute('stroke-width', isPreview ? '2' : '3');
      path.setAttribute('fill', 'none');
      path.setAttribute('marker-end', isPreview ? 'none' : 'url(#arrowhead)');
      path.classList.add('connection-line');
      
      svg.appendChild(path);
      return svg;
    }

    function createSmartPath(fromX, fromY, toX, toY) {
      // Find obstacles (tiles) between the connection points
      const obstacles = findObstacles(fromX, fromY, toX, toY);
      
      if (obstacles.length === 0) {
        // No obstacles, use smooth S-curve with better control points
        const midX = (fromX + toX) / 2;
        const midY = (fromY + toY) / 2;
        const distance = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
        const curveIntensity = Math.max(distance * 0.3, 40); // Minimum curve intensity
        
        // Create smooth cubic bezier curve with more pronounced curves
        const control1 = { 
          x: fromX + (midX - fromX) * 0.5, 
          y: fromY + (fromY < toY ? curveIntensity : -curveIntensity) 
        };
        const control2 = { 
          x: toX - (toX - midX) * 0.5, 
          y: toY + (toY < fromY ? curveIntensity : -curveIntensity) 
        };
        
        return `M ${fromX} ${fromY} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${toX} ${toY}`;
      }
      
      // Use Manhattan routing for obstacle avoidance
      return createManhattanPath(fromX, fromY, toX, toY, obstacles);
    }

    function findObstacles(fromX, fromY, toX, toY) {
      const obstacles = [];
      const canvasRect = canvas.getBoundingClientRect();
      
      tiles.forEach(tile => {
        const tileRect = tile.getBoundingClientRect();
        const tileX = tileRect.left - canvasRect.left;
        const tileY = tileRect.top - canvasRect.top;
        const tileWidth = tileRect.width;
        const tileHeight = tileRect.height;
        
        // Check if line intersects with tile
        if (lineIntersectsRect(fromX, fromY, toX, toY, tileX, tileY, tileWidth, tileHeight)) {
          obstacles.push({
            x: tileX,
            y: tileY,
            width: tileWidth,
            height: tileHeight
          });
        }
      });
      
      return obstacles;
    }

    function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
      // Simple line-rectangle intersection test
      const left = rx;
      const right = rx + rw;
      const top = ry;
      const bottom = ry + rh;
      
      // Check if line endpoints are inside rectangle
      if ((x1 >= left && x1 <= right && y1 >= top && y1 <= bottom) ||
          (x2 >= left && x2 <= right && y2 >= top && y2 <= bottom)) {
        return true;
      }
      
      // Check line segments against rectangle edges
      const lines = [
        [left, top, right, top],     // top edge
        [right, top, right, bottom], // right edge
        [right, bottom, left, bottom], // bottom edge
        [left, bottom, left, top]    // left edge
      ];
      
      for (const line of lines) {
        if (linesIntersect(x1, y1, x2, y2, line[0], line[1], line[2], line[3])) {
          return true;
        }
      }
      
      return false;
    }

    function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (den === 0) return false;
      
      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
      const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
      
      return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }

    function calculateWaypoints(fromX, fromY, toX, toY, obstacles) {
      const waypoints = [];
      
      // Sort obstacles by distance from start point
      obstacles.sort((a, b) => {
        const distA = Math.sqrt((a.x - fromX) ** 2 + (a.y - fromY) ** 2);
        const distB = Math.sqrt((b.x - fromX) ** 2 + (b.y - fromY) ** 2);
        return distA - distB;
      });
      
      let currentX = fromX;
      let currentY = fromY;
      
      for (const obstacle of obstacles) {
        // Find best waypoint around this obstacle
        const waypoint = findBestWaypoint(currentX, currentY, toX, toY, obstacle);
        if (waypoint) {
          waypoints.push(waypoint);
          currentX = waypoint.x;
          currentY = waypoint.y;
        }
      }
      
      return waypoints;
    }

    function findBestWaypoint(currentX, currentY, toX, toY, obstacle) {
      // Find the best waypoint around an obstacle
      const waypoints = [];
      const margin = 20;
      
      // Generate waypoints around the obstacle
      const left = obstacle.x - margin;
      const right = obstacle.x + obstacle.width + margin;
      const top = obstacle.y - margin;
      const bottom = obstacle.y + obstacle.height + margin;
      
      // Add corner waypoints
      waypoints.push({ x: left, y: top });
      waypoints.push({ x: right, y: top });
      waypoints.push({ x: left, y: bottom });
      waypoints.push({ x: right, y: bottom });
      
      // Add edge waypoints
      waypoints.push({ x: left, y: obstacle.y + obstacle.height / 2 });
      waypoints.push({ x: right, y: obstacle.y + obstacle.height / 2 });
      waypoints.push({ x: obstacle.x + obstacle.width / 2, y: top });
      waypoints.push({ x: obstacle.x + obstacle.width / 2, y: bottom });
      
      // Find the waypoint that minimizes total path length
      let bestWaypoint = null;
      let bestScore = Infinity;
      
      for (const wp of waypoints) {
        const score = calculatePathScore(currentX, currentY, wp.x, wp.y, toX, toY, obstacle);
        if (score < bestScore) {
          bestScore = score;
          bestWaypoint = wp;
        }
      }
      
      return bestWaypoint;
    }

    function createPathMap(fromX, fromY, toX, toY, obstacles) {
      // Create a path map with straight edges and max 3 bends
      const pathMap = {
        points: [{ x: fromX, y: fromY }],
        edges: []
      };
      
      if (obstacles.length === 0) {
        // Direct path
        pathMap.points.push({ x: toX, y: toY });
        pathMap.edges.push({ from: 0, to: 1 });
        return pathMap;
      }
      
      // Sort obstacles by distance from start
      obstacles.sort((a, b) => {
        const distA = Math.sqrt((a.x - fromX) ** 2 + (a.y - fromY) ** 2);
        const distB = Math.sqrt((b.x - fromX) ** 2 + (b.y - fromY) ** 2);
        return distA - distB;
      });
      
      let currentX = fromX;
      let currentY = fromY;
      let bendCount = 0;
      const maxBends = 3;
      
      for (const obstacle of obstacles) {
        if (bendCount >= maxBends) break;
        
        // Find best waypoint around this obstacle
        const waypoint = findBestWaypoint(currentX, currentY, toX, toY, obstacle);
        if (waypoint) {
          pathMap.points.push(waypoint);
          pathMap.edges.push({ 
            from: pathMap.points.length - 2, 
            to: pathMap.points.length - 1 
          });
          
          currentX = waypoint.x;
          currentY = waypoint.y;
          bendCount++;
        }
      }
      
      // Add final destination
      pathMap.points.push({ x: toX, y: toY });
      pathMap.edges.push({ 
        from: pathMap.points.length - 2, 
        to: pathMap.points.length - 1 
      });
      
      return pathMap;
    }

    function convertPathMapToCurves(pathMap) {
      if (pathMap.points.length < 2) {
        return `M ${pathMap.points[0].x} ${pathMap.points[0].y}`;
      }
      
      let path = `M ${pathMap.points[0].x} ${pathMap.points[0].y}`;
      
      for (let i = 1; i < pathMap.points.length; i++) {
        const current = pathMap.points[i];
        const previous = pathMap.points[i - 1];
        
        if (i === 1 || i === pathMap.points.length - 1) {
          // First and last segments: straight lines
          path += ` L ${current.x} ${current.y}`;
        } else {
          // Middle segments: convert bends to curves
          const next = pathMap.points[i + 1];
          const curve = convertBendToCurve(previous, current, next);
          path += ` ${curve}`;
        }
      }
      
      return path;
    }

    function convertBendToCurve(prev, current, next) {
      // Calculate the angle between the two line segments
      const angle1 = Math.atan2(current.y - prev.y, current.x - prev.x);
      const angle2 = Math.atan2(next.y - current.y, next.x - current.x);
      const angleDiff = Math.abs(angle1 - angle2);
      
      // If the angle is too sharp, create a curve
      if (angleDiff > Math.PI / 6) { // 30 degrees
        const radius = 20;
        const control1 = {
          x: current.x - Math.cos(angle1) * radius,
          y: current.y - Math.sin(angle1) * radius
        };
        const control2 = {
          x: current.x + Math.cos(angle2) * radius,
          y: current.y + Math.sin(angle2) * radius
        };
        
        return `C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${next.x} ${next.y}`;
      } else {
        // Small angle, keep it straight
        return `L ${next.x} ${next.y}`;
      }
    }

    function findOptimalPort(fromTile, toTile, fromDotType, toDotType) {
      // Find the optimal connection ports based on relative tile positions
      const fromRect = fromTile.getBoundingClientRect();
      const toRect = toTile.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      
      // Calculate relative positions
      const fromCenterX = fromRect.left + fromRect.width / 2 - canvasRect.left;
      const fromCenterY = fromRect.top + fromRect.height / 2 - canvasRect.top;
      const toCenterX = toRect.left + toRect.width / 2 - canvasRect.left;
      const toCenterY = toRect.top + toRect.height / 2 - canvasRect.top;
      
      // Determine optimal port types based on relative positions
      let optimalFromPort = fromDotType;
      let optimalToPort = toDotType;
      
      // If no specific ports specified, choose based on relative positions
      if (!fromDotType || !toDotType) {
        const dx = toCenterX - fromCenterX;
        const dy = toCenterY - fromCenterY;
        
        if (Math.abs(dx) > Math.abs(dy)) {
          // Horizontal connection
          optimalFromPort = dx > 0 ? 'output' : 'input';
          optimalToPort = dx > 0 ? 'input' : 'output';
        } else {
          // Vertical connection
          optimalFromPort = dy > 0 ? 'bottom' : 'top';
          optimalToPort = dy > 0 ? 'top' : 'bottom';
        }
      }
      
      // Calculate actual port coordinates
      const fromPort = getPortCoordinates(fromTile, optimalFromPort, canvasRect);
      const toPort = getPortCoordinates(toTile, optimalToPort, canvasRect);
      
      return {
        fromPort: { x: fromPort.x, y: fromPort.y, type: optimalFromPort },
        toPort: { x: toPort.x, y: toPort.y, type: optimalToPort }
      };
    }

    function getPortCoordinates(tile, portType, canvasRect) {
      const rect = tile.getBoundingClientRect();
      
      switch (portType) {
        case 'input':
          return { x: rect.left - canvasRect.left, y: rect.top + rect.height / 2 - canvasRect.top };
        case 'output':
          return { x: rect.right - canvasRect.left, y: rect.top + rect.height / 2 - canvasRect.top };
        case 'top':
          return { x: rect.left + rect.width / 2 - canvasRect.left, y: rect.top - canvasRect.top };
        case 'bottom':
          return { x: rect.left + rect.width / 2 - canvasRect.left, y: rect.bottom - canvasRect.top };
        default:
          return { x: rect.left + rect.width / 2 - canvasRect.left, y: rect.top + rect.height / 2 - canvasRect.top };
      }
    }

    function createManhattanPath(fromX, fromY, toX, toY, obstacles) {
      // Create a coarse grid for Manhattan routing
      const gridSize = 20;
      const grid = createRoutingGrid(fromX, fromY, toX, toY, obstacles, gridSize);
      
      // Find path using A* with Manhattan heuristic
      const path = findManhattanPath(fromX, fromY, toX, toY, grid, gridSize);
      
      if (path.length === 0) {
        // Fallback to simple S-curve if routing fails
        return createSimpleSCurve(fromX, fromY, toX, toY);
      }
      
      // Convert path to SVG with rounded corners
      return convertPathToSVG(path, gridSize);
    }

    function createRoutingGrid(fromX, fromY, toX, toY, obstacles, gridSize) {
      // Create a grid that covers the area between the two points
      const minX = Math.min(fromX, toX) - 100;
      const maxX = Math.max(fromX, toX) + 100;
      const minY = Math.min(fromY, toY) - 100;
      const maxY = Math.max(fromY, toY) + 100;
      
      const cols = Math.ceil((maxX - minX) / gridSize);
      const rows = Math.ceil((maxY - minY) / gridSize);
      
      const grid = Array(rows).fill().map(() => Array(cols).fill(0));
      
      // Mark obstacles as blocked
      obstacles.forEach(obstacle => {
        const startCol = Math.max(0, Math.floor((obstacle.x - minX) / gridSize));
        const endCol = Math.min(cols - 1, Math.ceil((obstacle.x + obstacle.width - minX) / gridSize));
        const startRow = Math.max(0, Math.floor((obstacle.y - minY) / gridSize));
        const endRow = Math.min(rows - 1, Math.ceil((obstacle.y + obstacle.height - minY) / gridSize));
        
        for (let row = startRow; row <= endRow; row++) {
          for (let col = startCol; col <= endCol; col++) {
            grid[row][col] = 1; // Blocked
          }
        }
      });
      
      return { grid, minX, minY, gridSize, cols, rows };
    }

    function findManhattanPath(fromX, fromY, toX, toY, gridInfo, gridSize) {
      const { grid, minX, minY, cols, rows } = gridInfo;
      
      // Convert world coordinates to grid coordinates
      const startCol = Math.floor((fromX - minX) / gridSize);
      const startRow = Math.floor((fromY - minY) / gridSize);
      const endCol = Math.floor((toX - minX) / gridSize);
      const endRow = Math.floor((toY - minY) / gridSize);
      
      // Clamp to grid bounds
      const clampedStartCol = Math.max(0, Math.min(cols - 1, startCol));
      const clampedStartRow = Math.max(0, Math.min(rows - 1, startRow));
      const clampedEndCol = Math.max(0, Math.min(cols - 1, endCol));
      const clampedEndRow = Math.max(0, Math.min(rows - 1, endRow));
      
      // A* pathfinding with Manhattan heuristic
      const openSet = [{ col: clampedStartCol, row: clampedStartRow, g: 0, h: 0, parent: null }];
      const closedSet = new Set();
      const cameFrom = new Map();
      const gScore = new Map();
      const fScore = new Map();
      
      gScore.set(`${clampedStartCol},${clampedStartRow}`, 0);
      fScore.set(`${clampedStartCol},${clampedStartRow}`, 0);
      
      while (openSet.length > 0) {
        // Find node with lowest f score
        openSet.sort((a, b) => a.h - b.h);
        const current = openSet.shift();
        
        if (current.col === clampedEndCol && current.row === clampedEndRow) {
          // Reconstruct path
          return reconstructPath(current, cameFrom, minX, minY, gridSize);
        }
        
        const currentKey = `${current.col},${current.row}`;
        closedSet.add(currentKey);
        
        // Check neighbors
        const neighbors = [
          { col: current.col + 1, row: current.row },
          { col: current.col - 1, row: current.row },
          { col: current.col, row: current.row + 1 },
          { col: current.col, row: current.row - 1 }
        ];
        
        for (const neighbor of neighbors) {
          if (neighbor.col < 0 || neighbor.col >= cols || neighbor.row < 0 || neighbor.row >= rows) {
            continue;
          }
          
          if (grid[neighbor.row][neighbor.col] === 1) {
            continue; // Blocked
          }
          
          const neighborKey = `${neighbor.col},${neighbor.row}`;
          if (closedSet.has(neighborKey)) {
            continue;
          }
          
          const tentativeG = current.g + 1;
          const neighborG = gScore.get(neighborKey) || Infinity;
          
          if (tentativeG < neighborG) {
            cameFrom.set(neighborKey, current);
            gScore.set(neighborKey, tentativeG);
            
            const h = Math.abs(neighbor.col - clampedEndCol) + Math.abs(neighbor.row - clampedEndRow);
            const f = tentativeG + h;
            fScore.set(neighborKey, f);
            
            // Add to open set if not already there
            if (!openSet.find(n => n.col === neighbor.col && n.row === neighbor.row)) {
              openSet.push({ col: neighbor.col, row: neighbor.row, g: tentativeG, h: h, parent: current });
            }
          }
        }
      }
      
      return []; // No path found
    }

    function reconstructPath(endNode, cameFrom, minX, minY, gridSize) {
      const path = [];
      let current = endNode;
      
      while (current) {
        const worldX = minX + current.col * gridSize + gridSize / 2;
        const worldY = minY + current.row * gridSize + gridSize / 2;
        path.unshift({ x: worldX, y: worldY });
        
        const currentKey = `${current.col},${current.row}`;
        current = cameFrom.get(currentKey);
      }
      
      return path;
    }

    function convertPathToSVG(path, gridSize) {
      if (path.length < 2) {
        return `M ${path[0].x} ${path[0].y}`;
      }
      
      let svgPath = `M ${path[0].x} ${path[0].y}`;
      
      for (let i = 1; i < path.length; i++) {
        const prev = path[i - 1];
        const curr = path[i];
        
        // Add rounded corners for Manhattan routing
        if (i < path.length - 1) {
          const next = path[i + 1];
          const cornerRadius = Math.min(gridSize / 3, 15);
          
          // Determine if this is a corner (direction change)
          const dx1 = curr.x - prev.x;
          const dy1 = curr.y - prev.y;
          const dx2 = next.x - curr.x;
          const dy2 = next.y - curr.y;
          
          if ((Math.abs(dx1) > 0.1 && Math.abs(dy2) > 0.1) || 
              (Math.abs(dy1) > 0.1 && Math.abs(dx2) > 0.1)) {
            // This is a corner, add rounded corner
            const corner = createRoundedCorner(prev, curr, next, cornerRadius);
            svgPath += corner;
          } else {
            // Straight line
            svgPath += ` L ${curr.x} ${curr.y}`;
          }
        } else {
          // Last segment
          svgPath += ` L ${curr.x} ${curr.y}`;
        }
      }
      
      return svgPath;
    }

    function createRoundedCorner(prev, curr, next, radius) {
      // Create a rounded corner between three points
      const dx1 = curr.x - prev.x;
      const dy1 = curr.y - prev.y;
      const dx2 = next.x - curr.x;
      const dy2 = next.y - curr.y;
      
      // Calculate the angle between the two segments
      const angle1 = Math.atan2(dy1, dx1);
      const angle2 = Math.atan2(dy2, dx2);
      const angleDiff = Math.abs(angle1 - angle2);
      
      if (angleDiff < Math.PI / 6) {
        // Small angle, just use straight line
        return ` L ${curr.x} ${curr.y}`;
      }
      
      // Calculate control points for the rounded corner
      const midAngle = (angle1 + angle2) / 2;
      const control1 = {
        x: curr.x - Math.cos(angle1) * radius,
        y: curr.y - Math.sin(angle1) * radius
      };
      const control2 = {
        x: curr.x + Math.cos(angle2) * radius,
        y: curr.y + Math.sin(angle2) * radius
      };
      
      return ` C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${next.x} ${next.y}`;
    }

    function createSimpleSCurve(fromX, fromY, toX, toY) {
      // Fallback to simple S-curve
      const midX = (fromX + toX) / 2;
      const midY = (fromY + toY) / 2;
      const distance = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
      const curveIntensity = Math.max(distance * 0.3, 40);
      
      const control1 = { 
        x: fromX + (midX - fromX) * 0.5, 
        y: fromY + (fromY < toY ? curveIntensity : -curveIntensity) 
      };
      const control2 = { 
        x: toX - (toX - midX) * 0.5, 
        y: toY + (toY < fromY ? curveIntensity : -curveIntensity) 
      };
      
      return `M ${fromX} ${fromY} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${toX} ${toY}`;
    }

    function renderCanvas() {
      // Clear canvas
      canvas.innerHTML = '';
      
      // Add tiles with proper positioning
      tiles.forEach(t => {
        // Position tiles relative to viewport, not transformed canvas
        const x = parseInt(t.style.left) || 0;
        const y = parseInt(t.style.top) || 0;
        t.style.left = (x + canvasOffset.x) + 'px';
        t.style.top = (y + canvasOffset.y) + 'px';
        t.style.position = 'absolute';
        t.style.zIndex = '10';
        canvas.appendChild(t);
      });
      
      // Add connections
      renderConnections();
    }

    function renderConnections() {
      // Remove existing connections
      document.querySelectorAll('.connection-svg').forEach(svg => svg.remove());
      
      connections.forEach(conn => {
        const fromTile = tiles.find(t => t.dataset.tileId === conn.fromTile);
        const toTile = tiles.find(t => t.dataset.tileId === conn.toTile);
        
        if (fromTile && toTile) {
          // Use automatic port selection for optimal connection points
          const ports = findOptimalPort(fromTile, toTile, conn.fromDot, conn.toDot);
          
          if (ports.fromPort && ports.toPort) {
            const connectionLine = createConnectionLine(
              ports.fromPort.x, 
              ports.fromPort.y, 
              ports.toPort.x, 
              ports.toPort.y, 
              false, 
              conn.color, 
              conn.id
            );
            connectionLine.classList.add('connection-svg');
            canvas.appendChild(connectionLine);
          }
        }
      });
    }

    async function shareGraph() {
      if (!currentGraph) return;
      const email = document.getElementById('shareEmail').value.trim();
      if (!email) return notify('Please enter an email', 'error');
      const token = localStorage.getItem('flowpad_token');
      const res = await fetch(`/api/graphs/${currentGraph.id}/share`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ email }) });
      notify(res.ok ? 'Graph shared successfully' : 'Failed to share graph', res.ok ? 'success' : 'error');
      if (res.ok) document.getElementById('shareEmail').value = '';
    }

    function notify(msg, type = 'success', ms = 2500) {
      const n = document.getElementById('notification');
      n.textContent = msg; n.className = `notification ${type}`; n.classList.add('show');
      setTimeout(() => n.classList.remove('show'), ms);
    }

    function adjustConnectionForSeparation(connection, allConnections) {
      // Find parallel connections and adjust them to avoid overlap
      const parallelConnections = findParallelConnections(connection, allConnections);
      
      if (parallelConnections.length > 0) {
        // Apply small offsets to separate parallel edges
        const offset = 8; // pixels
        const index = parallelConnections.indexOf(connection);
        
        if (index > 0) {
          // Apply offset based on connection index
          const offsetAmount = (index * offset) / 2;
          
          // Adjust the connection path slightly
          return applyOffsetToConnection(connection, offsetAmount);
        }
      }
      
      return connection;
    }

    function findParallelConnections(connection, allConnections) {
      const parallel = [connection];
      
      allConnections.forEach(otherConn => {
        if (otherConn.id === connection.id) return;
        
        if (isParallelConnection(connection, otherConn)) {
          parallel.push(otherConn);
        }
      });
      
      return parallel;
    }

    function isParallelConnection(conn1, conn2) {
      // Check if two connections are roughly parallel
      const fromTile1 = tiles.find(t => t.dataset.tileId === conn1.fromTile);
      const toTile1 = tiles.find(t => t.dataset.tileId === conn1.toTile);
      const fromTile2 = tiles.find(t => t.dataset.tileId === conn2.fromTile);
      const toTile2 = tiles.find(t => t.dataset.tileId === conn2.toTile);
      
      if (!fromTile1 || !toTile1 || !fromTile2 || !toTile2) return false;
      
      const rect1 = fromTile1.getBoundingClientRect();
      const rect2 = toTile1.getBoundingClientRect();
      const rect3 = fromTile2.getBoundingClientRect();
      const rect4 = toTile2.getBoundingClientRect();
      
      const canvasRect = canvas.getBoundingClientRect();
      
      // Calculate connection vectors
      const vec1 = {
        x: rect2.left - rect1.left,
        y: rect2.top - rect1.top
      };
      const vec2 = {
        x: rect4.left - rect3.left,
        y: rect4.top - rect3.top
      };
      
      // Normalize vectors
      const len1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
      const len2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
      
      if (len1 === 0 || len2 === 0) return false;
      
      vec1.x /= len1;
      vec1.y /= len1;
      vec2.x /= len2;
      vec2.y /= len2;
      
      // Check if vectors are parallel (dot product close to 1 or -1)
      const dotProduct = vec1.x * vec2.x + vec1.y * vec2.y;
      return Math.abs(dotProduct) > 0.8; // 0.8 = cos(37 degrees)
    }

    function applyOffsetToConnection(connection, offset) {
      // Apply a small perpendicular offset to the connection
      const fromTile = tiles.find(t => t.dataset.tileId === connection.fromTile);
      const toTile = tiles.find(t => t.dataset.tileId === connection.toTile);
      
      if (!fromTile || !toTile) return connection;
      
      const ports = findOptimalPort(fromTile, toTile, connection.fromDot, connection.toDot);
      
      if (ports.fromPort && ports.toPort) {
        // Calculate perpendicular vector
        const dx = ports.toPort.x - ports.fromPort.x;
        const dy = ports.toPort.y - ports.fromPort.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        if (length > 0) {
          // Normalize and rotate 90 degrees
          const perpX = -dy / length;
          const perpY = dx / length;
          
          // Apply offset
          const offsetFromX = ports.fromPort.x + perpX * offset;
          const offsetFromY = ports.fromPort.y + perpY * offset;
          const offsetToX = ports.toPort.x + perpX * offset;
          const offsetToY = ports.toPort.y + perpY * offset;
          
          // Create new connection with offset
          return {
            ...connection,
            offsetFrom: { x: offsetFromX, y: offsetFromY },
            offsetTo: { x: offsetToX, y: offsetToY }
          };
        }
      }
      
      return connection;
    }

    function createNewGraph() {
      const modal = document.getElementById('newGraphModal');
      const input = document.getElementById('newGraphTitle');
      input.value = '';
      modal.classList.add('show');
      input.focus();
      
      // Handle Enter key
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          confirmNewGraph();
        } else if (e.key === 'Escape') {
          closeNewGraphModal();
        }
      };
      
      // Handle click outside to close
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeNewGraphModal();
        }
      };
    }

    function closeNewGraphModal() {
      const modal = document.getElementById('newGraphModal');
      modal.classList.remove('show');
    }

    async function confirmNewGraph() {
      const title = document.getElementById('newGraphTitle').value.trim();
      if (!title) {
        document.getElementById('newGraphTitle').focus();
        return;
      }
      
      const createBtn = document.querySelector('#newGraphModal .modal-btn.primary');
      const originalText = createBtn.textContent;
      createBtn.textContent = 'Creating...';
      createBtn.disabled = true;
      
      try {
        const token = localStorage.getItem('flowpad_token');
        const res = await fetch('/api/graphs', { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title, data: { tiles: [], connections: [] } }) });
        if (!res.ok) {
          notify('Failed to create graph', 'error');
          return;
        }
        const graph = await res.json();
      await loadGraphs();
      loadGraph(graph);
        closeNewGraphModal();
        notify('Graph created successfully!', 'success');
      } catch (error) {
        notify('Failed to create graph: ' + error.message, 'error');
      } finally {
        createBtn.textContent = originalText;
        createBtn.disabled = false;
      }
    }

    async function checkAuth() {
      const token = localStorage.getItem('flowpad_token');
      const user = localStorage.getItem('flowpad_user');
      if (!token || !user) { window.location.href = '/'; return; }
      currentUser = JSON.parse(user);
      document.getElementById('userName').textContent = currentUser.name;
      const ok = await fetch('/api/graphs', { headers: { Authorization: `Bearer ${token}` } }).then(r => r.ok).catch(() => false);
      if (!ok) { localStorage.clear(); window.location.href = '/'; }
    }

    function signOut() { localStorage.clear(); window.location.href = '/'; }

    function el(html) { const d = document.createElement('div'); d.innerHTML = html.trim(); return d.firstChild; }

    async function loadGraphs() {
      const token = localStorage.getItem('flowpad_token');
      const res = await fetch('/api/graphs', { headers: { Authorization: `Bearer ${token}` } });
      if (!res.ok) return;
      const data = await res.json();
      renderGraphList(data.own, 'ownGraphs');
      renderGraphList(data.shared, 'sharedGraphs');
    }

    function updateTileColorsForTheme(theme) {
      // Update tile colors based on theme
      tiles.forEach(tile => {
        const currentColor = tile.style.background;
        if (currentColor) {
          const newColor = getThemeAdjustedColor(currentColor, theme);
          tile.style.background = newColor;
          
          // Update the selected color in the palette
          const colorOption = tile.querySelector(`[data-color="${currentColor}"]`);
          if (colorOption) {
            colorOption.classList.remove('selected');
          }
          
          const newColorOption = tile.querySelector(`[data-color="${newColor}"]`);
          if (newColorOption) {
            newColorOption.classList.add('selected');
          }
        }
      });
      
      // Re-render to update connections
      renderConnections();
    }

    function getThemeAdjustedColor(color, theme) {
      // Handle white and black colors - reverse them for theme
      if (color === '#ffffff' || color === 'white') {
        return theme === 'light' ? '#2d3748' : '#ffffff';
      }
      if (color === '#000000' || color === 'black' || color === '#212529') {
        return theme === 'light' ? '#ffffff' : '#2d3748';
      }
      
      // For other colors, keep them the same but adjust brightness slightly
      if (theme === 'light') {
        // Make colors slightly lighter in light mode
        return adjustColorBrightness(color, 1.1);
      } else {
        // Make colors slightly darker in dark mode
        return adjustColorBrightness(color, 0.9);
      }
    }

    function adjustColorBrightness(hex, factor) {
      // Convert hex to RGB, adjust brightness, convert back
      const r = Math.min(255, Math.round(parseInt(hex.slice(1, 3), 16) * factor));
      const g = Math.min(255, Math.round(parseInt(hex.slice(3, 5), 16) * factor));
      const b = Math.min(255, Math.round(parseInt(hex.slice(5, 7), 16) * factor));
      
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    function showColorPicker(tile, trigger) {
      // Remove existing color picker
      const existing = document.querySelector('.color-picker-popout');
      if (existing) existing.remove();
      
      const popout = document.createElement('div');
      popout.className = 'color-picker-popout';
      
      const currentColor = tile.style.background || '#ffffff';
      const recentColors = getRecentColors();
      
      popout.innerHTML = `
        <div class="color-picker-header">
          <span class="color-picker-title">Choose Color</span>
          <button class="color-picker-close" onclick="this.closest('.color-picker-popout').remove()">√ó</button>
        </div>
        <div class="color-picker-grid">
          <div class="color-picker-option" data-color="#ffffff" style="background:#ffffff" data-selected="${currentColor === '#ffffff'}"></div>
          <div class="color-picker-option" data-color="#f8f9fa" style="background:#f8f9fa" data-selected="${currentColor === '#f8f9fa'}"></div>
          <div class="color-picker-option" data-color="#e9ecef" style="background:#e9ecef" data-selected="${currentColor === '#e9ecef'}"></div>
          <div class="color-picker-option" data-color="#dee2e6" style="background:#dee2e6" data-selected="${currentColor === '#dee2e6'}"></div>
          <div class="color-picker-option" data-color="#ced4da" style="background:#ced4da" data-selected="${currentColor === '#ced4da'}"></div>
          <div class="color-picker-option" data-color="#adb5bd" style="background:#adb5bd" data-selected="${currentColor === '#adb5bd'}"></div>
          <div class="color-picker-option" data-color="#6c757d" style="background:#6c757d" data-selected="${currentColor === '#6c757d'}"></div>
          <div class="color-picker-option" data-color="#495057" style="background:#495057" data-selected="${currentColor === '#495057'}"></div>
          <div class="color-picker-option" data-color="#343a40" style="background:#343a40" data-selected="${currentColor === '#343a40'}"></div>
          <div class="color-picker-option" data-color="#212529" style="background:#212529" data-selected="${currentColor === '#212529'}"></div>
          <div class="color-picker-option" data-color="#ff6b6b" style="background:#ff6b6b" data-selected="${currentColor === '#ff6b6b'}"></div>
          <div class="color-picker-option" data-color="#4ecdc4" style="background:#4ecdc4" data-selected="${currentColor === '#4ecdc4'}"></div>
          <div class="color-picker-option" data-color="#45b7d1" style="background:#45b7d1" data-selected="${currentColor === '#45b7d1'}"></div>
          <div class="color-picker-option" data-color="#96ceb4" style="background:#96ceb4" data-selected="${currentColor === '#96ceb4'}"></div>
          <div class="color-picker-option" data-color="#feca57" style="background:#feca57" data-selected="${currentColor === '#feca57'}"></div>
          <div class="color-picker-option" data-color="#ff9ff3" style="background:#ff9ff3" data-selected="${currentColor === '#ff9ff57'}"></div>
          <div class="color-picker-option" data-color="#54a0ff" style="background:#54a0ff" data-selected="${currentColor === '#54a0ff'}"></div>
          <div class="color-picker-option" data-color="#5f27cd" style="background:#5f27cd" data-selected="${currentColor === '#5f27cd'}"></div>
          <div class="color-picker-option" data-color="#00d2d3" style="background:#00d2d3" data-selected="${currentColor === '#00d2d3'}"></div>
          <div class="color-picker-option" data-color="#ff9f43" style="background:#ff9f43" data-selected="${currentColor === '#ff9f43'}"></div>
        </div>
        ${recentColors.length > 0 ? `
          <div class="color-picker-recent">
            <div class="color-picker-recent-title">Recent Colors</div>
            <div class="color-picker-recent-grid">
              ${recentColors.map(color => `
                <div class="color-picker-option" data-color="${color}" style="background:${color}" data-selected="${currentColor === color}"></div>
              `).join('')}
            </div>
          </div>
        ` : ''}
      `;
      
      // Position the popout
      const rect = trigger.getBoundingClientRect();
      popout.style.left = (rect.left - 100) + 'px';
      popout.style.top = (rect.bottom + 5) + 'px';
      
      // Add click handlers
      popout.querySelectorAll('.color-picker-option').forEach(option => {
        option.addEventListener('click', () => {
          const color = option.dataset.color;
          tile.style.background = color;
          saveRecentColor(color);
          scheduleSave();
          popout.remove();
          
          // Update selected state
          popout.querySelectorAll('.color-picker-option').forEach(opt => {
            opt.dataset.selected = 'false';
            opt.classList.remove('selected');
          });
          option.dataset.selected = 'true';
          option.classList.add('selected');
        });
      });
      
      // Mark current color as selected
      const currentOption = popout.querySelector(`[data-color="${currentColor}"]`);
      if (currentOption) {
        currentOption.classList.add('selected');
      }
      
      document.body.appendChild(popout);
      
      // Close when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function closeColorPicker(e) {
          if (!popout.contains(e.target) && !trigger.contains(e.target)) {
            popout.remove();
            document.removeEventListener('click', closeColorPicker);
          }
        });
      }, 100);
    }

    function updateCollaboratorsList(users) {
      const list = document.getElementById('collaboratorsList');
      const content = document.getElementById('collaboratorsContent');
      const count = document.getElementById('collaboratorsCount');
      
      if (!users || users.length === 0) {
        list.classList.remove('show');
        return;
      }
      
      list.classList.add('show');
      count.textContent = users.length;
      
      content.innerHTML = users.map(user => `
        <div class="collaborator-item">
          <div class="collaborator-avatar">${user.name.charAt(0).toUpperCase()}</div>
          <span class="collaborator-name">${user.name}</span>
          <div class="collaborator-status ${user.status || 'online'}"></div>
        </div>
      `).join('');
    }

    function loadCollaborators() {
      if (!currentGraph) return;
      
      // Simulate loading collaborators (replace with actual API call)
      const collaborators = [
        { name: 'John Doe', status: 'online' },
        { name: 'Jane Smith', status: 'away' },
        { name: 'Bob Johnson', status: 'online' }
      ];
      
      updateCollaboratorsList(collaborators);
    }

    async function showCacheStatus() {
      if (!currentGraph) return;
      
      try {
        const token = localStorage.getItem('flowpad_token');
        const res = await fetch(`/api/graphs/${currentGraph.id}/cache-status`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        
        if (res.ok) {
          const status = await res.json();
          if (status.cached) {
            const timeAgo = Math.round((Date.now() - status.lastModified) / 1000);
            const dirtyText = status.dirty ? ' (unsaved changes)' : ' (saved)';
            notify(`Cache: ${timeAgo}s ago${dirtyText}`, 'success');
          } else {
            notify('Graph not cached', 'error');
          }
        }
      } catch (error) {
        console.error('Failed to get cache status:', error);
      }
    }

    function forceSave() {
      if (!currentGraph) return;
      
      autoSaveGraph();
      notify('Forcing save...', 'success');
    }

    // Add cache status button to toolbar
    function addCacheStatusButton() {
      const toolbar = document.getElementById('toolbar');
      if (toolbar && !toolbar.querySelector('.cache-status-btn')) {
        const cacheBtn = document.createElement('button');
        cacheBtn.className = 'tool-btn cache-status-btn';
        cacheBtn.title = 'Cache Status';
        cacheBtn.textContent = 'üíæ';
        cacheBtn.onclick = showCacheStatus;
        toolbar.appendChild(cacheBtn);
        
        const forceSaveBtn = document.createElement('button');
        forceSaveBtn.className = 'tool-btn force-save-btn';
        forceSaveBtn.title = 'Force Save';
        forceSaveBtn.textContent = 'üíæ!';
        forceSaveBtn.onclick = forceSave;
        toolbar.appendChild(forceSaveBtn);
        
        // Add snap toggles
        const snapGridBtn = document.createElement('button');
        snapGridBtn.className = 'tool-btn snap-grid-btn';
        snapGridBtn.title = 'Snap to Grid';
        snapGridBtn.textContent = '‚äû';
        snapGridBtn.onclick = toggleSnapToGrid;
        snapGridBtn.classList.add('active'); // Default enabled
        toolbar.appendChild(snapGridBtn);
        
        const snapTilesBtn = document.createElement('button');
        snapTilesBtn.className = 'tool-btn snap-tiles-btn';
        snapTilesBtn.title = 'Snap to Tiles';
        snapTilesBtn.textContent = '‚äü';
        snapTilesBtn.onclick = toggleSnapToTiles;
        snapTilesBtn.classList.add('active'); // Default enabled
        toolbar.appendChild(snapTilesBtn);
      }
    }

    function toggleSnapToGrid() {
      snapToGrid = !snapToGrid;
      const btn = document.querySelector('.snap-grid-btn');
      btn.classList.toggle('active', snapToGrid);
      btn.title = snapToGrid ? 'Snap to Grid (ON)' : 'Snap to Grid (OFF)';
      notify(`Snap to Grid: ${snapToGrid ? 'ON' : 'OFF'}`, 'success');
    }

    function toggleSnapToTiles() {
      snapToTiles = !snapToTiles;
      const btn = document.querySelector('.snap-tiles-btn');
      btn.classList.toggle('active', snapToTiles);
      btn.title = snapToTiles ? 'Snap to Tiles (ON)' : 'Snap to Tiles (OFF)';
      notify(`Snap to Tiles: ${snapToTiles ? 'ON' : 'OFF'}`, 'success');
    }

    function showAutoSaveStatus() {
      const indicator = document.getElementById('autoSaveIndicator');
      const text = document.getElementById('autoSaveText');
      
      if (isDirty) {
        const timeSinceLastSave = Math.round((Date.now() - lastSaveTime) / 1000);
        text.textContent = `Unsaved changes (${timeSinceLastSave}s ago)`;
        indicator.classList.add('show', 'saving');
      } else {
        text.textContent = `Last saved at ${new Date(lastSaveTime).toLocaleTimeString()}`;
        indicator.classList.add('show', 'saved');
      }
      
      // Hide after 3 seconds
      setTimeout(() => {
        indicator.classList.remove('show', 'saving', 'saved');
      }, 3000);
    }
  </script>
</body>
</html>

