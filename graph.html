<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Flowpad - Graph Editor</title>
<style>
  :root {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --bg-tertiary: rgba(0,0,0,0.9);
    --bg-sidebar: rgba(0,0,0,0.8);
    --bg-tile: #fff;
    --bg-tile-hover: #f8f9fa;
    --text-primary: #fff;
    --text-secondary: #ccc;
    --text-tile: #000;
    --border-primary: #333;
    --border-secondary: #555;
    --accent-primary: #007AFF;
    --accent-secondary: #0056CC;
    --shadow-primary: rgba(0,0,0,0.3);
    --shadow-secondary: rgba(0,0,0,0.2);
    --grid-color: rgba(255,255,255,0.03);
    --tab-active: #007AFF;
    --tab-inactive: #444;
    --tab-hover: #555;
    --inbox-pending: #FF9500;
    --inbox-accepted: #34C759;
    --inbox-rejected: #FF3B30;
  }
  :root[data-theme="light"] {
    --bg-primary: #ffffff;
    --bg-secondary: #f8f9fa;
    --bg-tertiary: rgba(255,255,255,0.95);
    --bg-sidebar: rgba(255,255,255,0.95);
    --bg-tile: #ffffff;
    --bg-tile-hover: #f8f9fa;
    --text-primary: #2d3748;
    --text-secondary: #4a5568;
    --text-tile: #000000;
    --border-primary: #e2e8f0;
    --border-secondary: #cbd5e0;
    --shadow-primary: rgba(0,0,0,0.1);
    --shadow-secondary: rgba(0,0,0,0.05);
    --grid-color: rgba(0,0,0,0.03);
    --tab-active: #007AFF;
    --tab-inactive: #ddd;
    --tab-hover: #e2e8f0;
    --inbox-pending: #FF9500;
    --inbox-accepted: #34C759;
    --inbox-rejected: #FF3B30;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 60px;
    background: var(--bg-tertiary);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border-primary);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 20px;
    z-index: 1000;
    transition: all 0.3s ease;
    box-shadow: 0 4px 20px var(--shadow-primary);
  }

  .logo {
    font-size: 1.5rem;
    font-weight: 400;
    background: linear-gradient(45deg, var(--text-primary), var(--text-secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .user-info {
    display: flex;
    align-items: center;
    gap: 15px;
  }

  .theme-toggle, .signout-btn {
    background: var(--border-primary);
    color: var(--text-primary);
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 6px var(--shadow-primary);
  }

  .theme-toggle:hover, .signout-btn:hover {
    background: var(--border-secondary);
    box-shadow: 0 4px 12px var(--shadow-secondary);
  }


  .sidebar {
    position: fixed;
    left: 0;
    top: 60px;
    bottom: 0;
    width: 300px;
    background: var(--bg-sidebar);
    backdrop-filter: blur(20px);
    border-right: 1px solid var(--border-primary);
    overflow-y: auto;
    transition: all 0.3s ease;
    box-shadow: 4px 0 20px var(--shadow-primary);
  }

  .sidebar-content {
    padding: 20px;
  }

  .new-graph-btn {
    background: var(--accent-primary);
    color: #fff;
    border: none;
    padding: 12px 20px;
    border-radius: 8px;
    cursor: pointer;
    width: 100%;
    font-size: 1rem;
    margin-bottom: 20px;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px var(--shadow-primary);
  }

  .new-graph-btn:hover {
    background: var(--accent-secondary);
    box-shadow: 0 6px 16px var(--shadow-secondary);
  }

  .folder-section {
    margin-bottom: 25px;
    border: 1px solid var(--border-secondary);
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px var(--shadow-primary);
  }

  .folder-header {
    background: var(--bg-secondary);
    padding: 12px 15px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid var(--border-secondary);
    transition: all 0.3s ease;
  }

  .folder-header:hover {
    background: var(--border-primary);
  }

  .folder-header.active {
    background: var(--accent-primary);
    color: #fff;
  }

  .folder-content {
    padding: 10px;
    background: var(--bg-tertiary);
    display: none;
  }

  .folder-content.expanded {
    display: block;
  }

  .graph-item {
    background: var(--bg-secondary);
    border: 1px solid var(--border-primary);
    border-radius: 6px;
    padding: 12px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 6px var(--shadow-primary);
  }

  .graph-item:hover {
    background: var(--border-primary);
    box-shadow: 0 4px 12px var(--shadow-secondary);
  }

  .graph-item.active {
    background: var(--accent-primary);
    color: #fff;
    border-color: var(--accent-primary);
  }

  .canvas-container {
    position: fixed;
    left: 300px;
    top: 60px;
    right: 0;
    bottom: 0;
    overflow: hidden;
  }

  .canvas {
    position: relative;
    width: 100%;
    height: 100%;
    background: var(--bg-primary);
    cursor: grab;
  }

  .canvas-content {
    position: absolute;
    left: 0;
    top: 0;
    transform-origin: 0 0;
  }


  .tile {
    position: absolute;
    background: var(--bg-tile);
    color: var(--text-tile);
    border: 2px solid var(--border-primary);
    border-radius: 12px;
    padding: 20px;
    min-width: 150px;
    min-height: 100px;
    cursor: move;
    user-select: none;
    box-shadow: 0 8px 25px var(--shadow-primary);
    transition: all 0.1s ease;
    overflow: hidden;
  }

  .tile:hover {
    background: var(--bg-tile-hover);
    box-shadow: 0 12px 35px var(--shadow-secondary);
  }

  .tile.selected {
    border-color: var(--accent-primary);
    box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.3);
  }

  .tile-title, .tile-content {
    border: none;
    background: transparent;
    width: 100%;
    outline: none;
    font-family: inherit;
    resize: none;
    font-weight: 400;
  }

  .tile-title {
    font-weight: 400;
    margin-bottom: 12px;
    font-size: 1rem;
    color: var(--text-tile);
  }

  .tile-content {
    font-size: 0.9rem;
    line-height: 1.5;
    min-height: 50px;
    color: var(--text-tile);
    font-weight: 400;
  }

  .connection {
    position: absolute;
    pointer-events: none;
    z-index: 5;
  }

  .connection-line {
    stroke: var(--accent-primary);
    stroke-width: 3;
    fill: none;
    filter: drop-shadow(0 2px 4px var(--shadow-primary));
  }

  .connection-line:hover {
    stroke: var(--accent-secondary);
    stroke-width: 4;
  }

  .connection-line.selected {
    stroke-width: 5;
    filter: drop-shadow(0 0 8px currentColor);
  }


  .toolbar {
    position: fixed;
    top: 70px;
    right: 20px;
    background: var(--bg-tertiary);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border-primary);
    border-radius: 12px;
    padding: 12px;
    z-index: 1000;
    min-width: 230px;
    transition: all 0.3s ease;
    box-shadow: 0 8px 25px var(--shadow-primary);
  }

  .tool-label {
    color: var(--text-secondary);
    font-size: 0.8rem;
    margin-bottom: 8px;
    text-align: center;
    font-weight: 400;
  }

  .tool-row {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .tool-btn {
    background: var(--border-primary);
    color: var(--text-primary);
    border: none;
    padding: 8px;
    border-radius: 6px;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.95rem;
    transition: all 0.2s ease;
    box-shadow: 0 2px 6px var(--shadow-primary);
  }

  .tool-btn:hover {
    background: var(--border-secondary);
    box-shadow: 0 4px 12px var(--shadow-secondary);
  }

  .tool-btn.active {
    background: var(--accent-primary);
    color: #fff;
  }

  .notification {
    position: fixed;
    top: 80px;
    right: 20px;
    background: var(--accent-primary);
    color: #fff;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 8px 25px var(--shadow-primary);
    z-index: 10000;
    transform: translateX(400px);
    transition: 0.3s transform;
    max-width: 300px;
  }

  .notification.show {
    transform: translateX(0);
  }

  .notification.error {
    background: #f44336;
  }

  .notification.warn {
    background: #FF9500;
  }

  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(5px);
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
  }

  .modal-overlay.show {
    display: flex;
  }

  .modal {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-primary);
    border-radius: 12px;
    padding: 30px;
    min-width: 400px;
    max-width: 600px;
    box-shadow: 0 20px 40px var(--shadow-primary);
  }

  .modal-title {
    font-size: 1.3rem;
    font-weight: 400;
    margin-bottom: 20px;
    color: var(--text-primary);
  }

  .modal-input {
    width: 100%;
    padding: 15px;
    border: 1px solid var(--border-secondary);
    border-radius: 8px;
    background: var(--bg-secondary);
    color: var(--text-primary);
    font-size: 1rem;
    margin-bottom: 20px;
    outline: none;
    transition: border-color 0.3s ease;
    font-weight: 400;
  }

  .modal-input:focus {
    border-color: var(--accent-primary);
  }

  .modal-buttons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
  }

  .modal-btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px var(--shadow-primary);
  }

  .modal-btn.primary {
    background: var(--accent-primary);
    color: #fff;
  }

  .modal-btn.primary:hover {
    background: var(--accent-secondary);
    box-shadow: 0 6px 16px var(--shadow-secondary);
  }

  .modal-btn.secondary {
    background: var(--border-primary);
    color: var(--text-primary);
  }

  .modal-btn.secondary:hover {
    background: var(--border-secondary);
    box-shadow: 0 4px 12px var(--shadow-secondary);
  }

  /* Enhanced features CSS */
  .grid-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .grid-overlay.show {
    opacity: 0.1;
  }

  .grid-line {
    position: absolute;
    background: var(--accent-primary);
  }

  .grid-line.vertical {
    width: 1px;
    height: 100%;
  }

  .grid-line.horizontal {
    height: 1px;
    width: 100%;
  }

  .color-picker-popout {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 10px 25px var(--shadow-primary);
    backdrop-filter: blur(20px);
    min-width: 200px;
  }

  .color-picker-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-secondary);
  }

  .color-picker-title {
    font-weight: 500;
    color: var(--text-primary);
    font-size: 0.9rem;
  }

  .color-picker-close {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 16px;
    padding: 2px;
    border-radius: 4px;
    transition: all 0.3s ease;
  }

  .color-picker-close:hover {
    color: var(--text-primary);
    background: var(--border-primary);
  }

  .color-picker-grid {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
  }

  .color-picker-option {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 2px solid var(--border-primary);
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .color-picker-option:hover {
    transform: scale(1.1);
    border-color: var(--accent-primary);
  }

  .ai-suggestion {
    background: var(--bg-secondary);
    border: 1px solid var(--border-primary);
    border-radius: 6px;
    padding: 10px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 6px var(--shadow-primary);
    font-weight: 400;
  }

  .ai-suggestion:hover {
    background: var(--border-primary);
    box-shadow: 0 4px 12px var(--shadow-secondary);
  }

  .inbox-item {
    background: var(--bg-secondary);
    border: 1px solid var(--border-primary);
    border-radius: 6px;
    padding: 12px;
    margin-bottom: 8px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 6px var(--shadow-primary);
  }

  .inbox-item.pending {
    border-left: 4px solid var(--inbox-pending);
  }

  .inbox-title {
    font-weight: 400;
    margin-bottom: 5px;
    color: var(--text-primary);
    font-size: 0.95rem;
  }

  .inbox-meta {
    font-size: 0.75rem;
    color: var(--text-secondary);
    margin-bottom: 10px;
  }

  .inbox-actions {
    display: flex;
    gap: 8px;
  }

  .inbox-btn {
    flex: 1;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px var(--shadow-primary);
  }

  .inbox-btn.accept {
    background: var(--inbox-accepted);
    color: #fff;
  }

  .inbox-btn.accept:hover {
    box-shadow: 0 4px 8px var(--shadow-secondary);
  }

  .inbox-btn.reject {
    background: var(--inbox-rejected);
    color: #fff;
  }

  .inbox-btn.reject:hover {
    box-shadow: 0 4px 8px var(--shadow-secondary);
  }

  .shared-user-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: 6px;
    margin-bottom: 8px;
  }

  .shared-user-info {
    display: flex;
    flex-direction: column;
  }

  .shared-user-email {
    font-size: 14px;
    color: var(--text-primary);
    font-weight: 500;
  }

  .shared-user-permission {
    font-size: 12px;
    color: var(--text-secondary);
  }

  .shared-user-actions {
    display: flex;
    gap: 4px;
  }

  .change-permission-btn, .remove-user-btn {
    background: var(--accent-primary);
    color: #fff;
    border: none;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.3s ease;
  }

  .remove-user-btn {
    background: var(--inbox-rejected);
  }

  .change-permission-btn:hover, .remove-user-btn:hover {
    background: var(--accent-secondary);
  }

  .loading {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid transparent;
    border-top: 2px solid currentColor;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 8px;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

</style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <div class="logo">Flowpad</div>
    <div class="user-info">
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <span id="theme-icon">🌙</span>
      </button>
      <span id="userName">User</span>
      <button class="signout-btn" onclick="signOut()">Sign Out</button>
    </div>
  </div>

  <!-- Sidebar -->
  <div class="sidebar">
    <div class="sidebar-content">
      <button class="new-graph-btn" onclick="createNewGraph()">+ New Graph</button>

      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('myGraphs')">
          <span>📁 My Graphs</span>
          <span class="folder-arrow">▶</span>
        </div>
        <div class="folder-content expanded" id="myGraphs">
          <div id="ownGraphs"></div>
        </div>
      </div>

      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('sharedGraphs')">
          <span>👥 Shared With Me</span>
          <span class="folder-arrow">▶</span>
        </div>
        <div class="folder-content" id="sharedGraphs">
          <div id="sharedGraphsContent"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Canvas -->
  <div class="canvas-container">
    <div class="canvas" id="canvas">
      <div class="canvas-content" id="canvasContent">
        <!-- SVG for connections -->
        <svg id="connections-svg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;">
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" fill="var(--accent-primary)" />
            </marker>
          </defs>
        </svg>
        <!-- Tiles will be added here dynamically -->
      </div>
    </div>
  </div>

  <!-- Toolbar -->
  <div class="toolbar" id="toolbar">
    <div class="tool-label">Tools</div>
    <div class="tool-row">
      <button class="tool-btn" onclick="addTile()" title="Add Tile">+</button>
      <button class="tool-btn" onclick="deleteSelected()" title="Delete Selected">🗑</button>
      <button class="tool-btn" onclick="centerCanvas()" title="Center Canvas">🏠</button>
    </div>
  </div>

  <!-- Notifications -->
  <div id="notification" class="notification"></div>

  <!-- New Graph Modal -->
  <div class="modal-overlay" id="newGraphModal">
    <div class="modal">
      <div class="modal-title">Create New Graph</div>
      <input type="text" class="modal-input" id="newGraphTitle" placeholder="Enter graph title..." maxlength="100">
      <div class="modal-buttons">
        <button class="modal-btn secondary" onclick="closeNewGraphModal()">Cancel</button>
        <button class="modal-btn primary" onclick="confirmNewGraph()">Create</button>
      </div>
    </div>
  </div>



<!-- Essential JavaScript for core graph functionality -->
<script>
// Core state variables
let currentGraph = null;
let tiles = [];
let connections = [];
let selectedTile = null;
let isDragging = false;
let dragOffset = { x: 0, y: 0 };
let canvasOffset = { x: 0, y: 0 };
let zoom = 1;

// DOM elements
const canvas = document.getElementById('canvas');
const canvasContent = document.getElementById('canvasContent');

// Initialize the application
document.addEventListener('DOMContentLoaded', init);

async function init() {
  try {
    await checkAuth();
    await loadGraphs();
    setupCanvas();
    setupTheme();
    initializeEnhancedFeatures();
    notify('Flowpad loaded successfully!', 'success');
  } catch (error) {
    console.error('Initialization error:', error);
    notify('Failed to initialize Flowpad', 'error');
  }
}

// Authentication functions
async function checkAuth() {
  const token = localStorage.getItem('flowpad_token');
  if (!token) {
    window.location.href = '/';
    return;
  }

  try {
    const response = await fetch('/api/graphs', {
      headers: { 'Authorization': `Bearer ${token}` }
    });

    if (!response.ok) {
      throw new Error('Authentication failed');
    }
  } catch (error) {
    localStorage.removeItem('flowpad_token');
    window.location.href = '/';
  }
}

function signOut() {
  localStorage.clear();
  window.location.href = '/';
}

// Theme management
function setupTheme() {
  const saved = localStorage.getItem('flowpad_theme') || 'dark';
  document.documentElement.setAttribute('data-theme', saved);
  updateThemeIcon(saved);
}

function toggleTheme() {
  const current = document.documentElement.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', next);
  localStorage.setItem('flowpad_theme', next);
  updateThemeIcon(next);
}

function updateThemeIcon(theme) {
  document.getElementById('theme-icon').textContent = theme === 'dark' ? '🌙' : '☀️';
}

// Canvas setup and interaction
function setupCanvas() {
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('click', onCanvasClick);
}

function onMouseDown(e) {
  const tile = e.target.closest('.tile');
  if (tile) {
    startDragging(e, tile);
  }
}

function onMouseMove(e) {
  if (isDragging && selectedTile) {
    updateDragging(e);
  }
}

function onMouseUp(e) {
  if (isDragging) {
    finishDragging();
  }
}

function onCanvasClick(e) {
  if (!e.target.closest('.tile')) {
    clearSelection();
  }
}

// Tile management
function addTile() {
  const x = Math.random() * 400 + 100;
  const y = Math.random() * 300 + 100;
  const tile = createTile(x, y, 'New Tile', 'Enter content here...');
  tiles.push(tile);
  renderCanvas();
  selectTile(tile);
  scheduleSave();
}

function createTile(x, y, title = '', content = '', id = null) {
  const tile = document.createElement('div');
  tile.className = 'tile';
  tile.dataset.tileId = id || generateId();
  tile.dataset.x = x;
  tile.dataset.y = y;
  tile.style.left = x + 'px';
  tile.style.top = y + 'px';

  tile.innerHTML = `
    <textarea class="tile-title" placeholder="Title">${title}</textarea>
    <textarea class="tile-content" placeholder="Content">${content}</textarea>
  `;

  // Add event listeners
  tile.addEventListener('click', () => selectTile(tile));
  tile.querySelectorAll('textarea').forEach(textarea => {
    textarea.addEventListener('input', scheduleSave);
  });

  return tile;
}

function selectTile(tile) {
  clearSelection();
  tile.classList.add('selected');
  selectedTile = tile;
}

function clearSelection() {
  tiles.forEach(tile => tile.classList.remove('selected'));
  selectedTile = null;
}

function deleteSelected() {
  if (selectedTile) {
    const index = tiles.indexOf(selectedTile);
    if (index > -1) {
      tiles.splice(index, 1);
      selectedTile.remove();
      selectedTile = null;
      renderCanvas();
      scheduleSave();
      notify('Tile deleted', 'success');
    }
  }
}

// Dragging functionality
function startDragging(e, tile) {
  isDragging = true;
  selectedTile = tile;
  selectTile(tile);

  const rect = tile.getBoundingClientRect();
  const canvasRect = canvas.getBoundingClientRect();
  dragOffset.x = e.clientX - rect.left;
  dragOffset.y = e.clientY - rect.top;
}

function updateDragging(e) {
  if (!selectedTile) return;

  const canvasRect = canvas.getBoundingClientRect();
  const x = e.clientX - canvasRect.left - dragOffset.x;
  const y = e.clientY - canvasRect.top - dragOffset.y;

  selectedTile.style.left = x + 'px';
  selectedTile.style.top = y + 'px';
  selectedTile.dataset.x = x;
  selectedTile.dataset.y = y;
}

function finishDragging() {
  isDragging = false;
  if (selectedTile) {
    scheduleSave();
  }
}

// Canvas utilities
function centerCanvas() {
  if (tiles.length === 0) return;

  // Calculate center of all tiles
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  tiles.forEach(tile => {
    const x = parseFloat(tile.dataset.x);
    const y = parseFloat(tile.dataset.y);
    const width = tile.offsetWidth;
    const height = tile.offsetHeight;

    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + width);
    maxY = Math.max(maxY, y + height);
  });

  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const canvasRect = canvas.getBoundingClientRect();

  canvasOffset.x = canvasRect.width / 2 - centerX;
  canvasOffset.y = canvasRect.height / 2 - centerY;

  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
}

function renderCanvas() {
  // Clear existing tiles from DOM
  canvasContent.querySelectorAll('.tile').forEach(tile => tile.remove());

  // Add all tiles to canvas
  tiles.forEach(tile => {
    canvasContent.appendChild(tile);
  });
}

// Graph management - API integration
async function loadGraphs() {
  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch('/api/graphs', {
      headers: { 'Authorization': `Bearer ${token}` }
    });

    if (!response.ok) throw new Error('Failed to load graphs');

    const graphs = await response.json();
    displayGraphs(graphs);
  } catch (error) {
    console.error('Error loading graphs:', error);
    notify('Failed to load graphs', 'error');
  }
}

function displayGraphs(graphs) {
  const ownGraphs = document.getElementById('ownGraphs');
  const sharedGraphs = document.getElementById('sharedGraphsContent');

  ownGraphs.innerHTML = '';
  sharedGraphs.innerHTML = '';

  graphs.forEach(graph => {
    const graphElement = createGraphElement(graph);
    if (graph.type === 'own') {
      ownGraphs.appendChild(graphElement);
    } else {
      sharedGraphs.appendChild(graphElement);
    }
  });
}

function createGraphElement(graph) {
  const div = document.createElement('div');
  div.className = 'graph-item';
  div.innerHTML = `
    <div class="graph-title">${graph.title}</div>
    <div class="graph-meta">Updated: ${new Date(graph.updated_at).toLocaleDateString()}</div>
  `;

  div.addEventListener('click', () => loadGraph(graph));
  return div;
}

async function loadGraph(graph) {
  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch(`/api/graphs/${graph.id}`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });

    if (!response.ok) throw new Error('Failed to load graph');

    const graphData = await response.json();
    currentGraph = graphData;

    // Clear existing tiles
    tiles = [];
    connections = [];

    // Load tiles from graph data
    if (graphData.data && graphData.data.tiles) {
      graphData.data.tiles.forEach(tileData => {
        const tile = createTile(
          tileData.x || 0,
          tileData.y || 0,
          tileData.title || '',
          tileData.content || '',
          tileData.id
        );
        tiles.push(tile);
      });
    }

    renderCanvas();
    notify(`Loaded "${graphData.title}"`, 'success');
  } catch (error) {
    console.error('Error loading graph:', error);
    notify('Failed to load graph', 'error');
  }
}

// Graph creation
function createNewGraph() {
  const modal = document.getElementById('newGraphModal');
  const input = document.getElementById('newGraphTitle');
  input.value = '';
  modal.classList.add('show');
  input.focus();
}

function closeNewGraphModal() {
  document.getElementById('newGraphModal').classList.remove('show');
}

async function confirmNewGraph() {
  const title = document.getElementById('newGraphTitle').value.trim();
  if (!title) {
    notify('Please enter a title', 'error');
    return;
  }

  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch('/api/graphs', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        title: title,
        data: { tiles: [], connections: [] }
      })
    });

    if (!response.ok) throw new Error('Failed to create graph');

    const newGraph = await response.json();
    currentGraph = newGraph;
    tiles = [];
    connections = [];
    renderCanvas();
    closeNewGraphModal();
    loadGraphs(); // Refresh the sidebar
    notify(`Created "${title}"`, 'success');
  } catch (error) {
    console.error('Error creating graph:', error);
    notify('Failed to create graph', 'error');
  }
}

// Save functionality
let saveTimeout = null;

function scheduleSave() {
  if (!currentGraph) return;

  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(saveGraph, 1000);
}

async function saveGraph() {
  if (!currentGraph) return;

  try {
    const token = localStorage.getItem('flowpad_token');
    const graphData = {
      tiles: tiles.map(tile => ({
        id: tile.dataset.tileId,
        x: parseFloat(tile.dataset.x),
        y: parseFloat(tile.dataset.y),
        title: tile.querySelector('.tile-title').value,
        content: tile.querySelector('.tile-content').value
      })),
      connections: connections
    };

    const response = await fetch(`/api/graphs/${currentGraph.id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        title: currentGraph.title,
        data: graphData
      })
    });

    if (!response.ok) throw new Error('Failed to save graph');

    console.log('Graph saved successfully');
  } catch (error) {
    console.error('Error saving graph:', error);
    notify('Failed to save graph', 'error');
  }
}

// Folder management
function toggleFolder(folderId) {
  const folder = document.getElementById(folderId);
  const header = folder.previousElementSibling;
  const arrow = header.querySelector('.folder-arrow');

  folder.classList.toggle('expanded');
  arrow.textContent = folder.classList.contains('expanded') ? '▼' : '▶';
  header.classList.toggle('active');
}

// Utility functions
function generateId() {
  return 'tile_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
}

function notify(message, type = 'success', duration = 3000) {
  const notification = document.getElementById('notification');
  notification.textContent = message;
  notification.className = `notification ${type}`;
  notification.classList.add('show');

  setTimeout(() => {
    notification.classList.remove('show');
  }, duration);
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Delete' && selectedTile) {
    deleteSelected();
  } else if (e.key === 'n' && !e.target.matches('input, textarea')) {
    addTile();
  }
});

// ===========================
// API-INTEGRATED FUNCTIONS
// ===========================

// Text rectangle creation
function createTextRectangle() {
  const x = Math.random() * 400 + 100;
  const y = Math.random() * 300 + 100;
  const tile = createTile(x, y, 'Text Block', 'Enter your text here...');
  tile.style.minHeight = '80px';
  tiles.push(tile);
  renderCanvas();
  selectTile(tile);
  scheduleSave();
  notify('Text rectangle added', 'success');
}

// AI Panel functionality
let aiPanelVisible = false;
function toggleAIPanel() {
  const panel = document.getElementById('aiPanel');
  if (!panel) {
    notify('AI Panel element not found', 'error');
    return;
  }

  aiPanelVisible = !aiPanelVisible;
  panel.style.display = aiPanelVisible ? 'block' : 'none';

  if (aiPanelVisible) {
    document.getElementById('aiInput')?.focus();
  }
}

// AI Suggestions with API integration
async function getAISuggestions() {
  const input = document.getElementById('aiInput');
  const button = document.getElementById('aiBtn');
  const suggestionsDiv = document.getElementById('aiSuggestions');

  if (!input || !input.value.trim()) {
    notify('Please enter a description', 'warn');
    return;
  }

  const prompt = input.value.trim();
  button.disabled = true;
  button.innerHTML = '<span class="loading"></span>Getting suggestions...';

  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch('/api/ai-suggestions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        prompt: prompt,
        targetTile: selectedTile ? {
          id: selectedTile.dataset.tileId,
          title: selectedTile.querySelector('.tile-title')?.value,
          content: selectedTile.querySelector('.tile-content')?.value
        } : null,
        existingTiles: tiles.map(tile => ({
          id: tile.dataset.tileId,
          title: tile.querySelector('.tile-title')?.value,
          content: tile.querySelector('.tile-content')?.value
        })),
        connections: connections
      })
    });

    if (!response.ok) throw new Error('Failed to get suggestions');

    const data = await response.json();
    displayAISuggestions(data.suggestions);
    notify('AI suggestions generated', 'success');

  } catch (error) {
    console.error('AI suggestions error:', error);
    notify('Failed to get AI suggestions', 'error');
  } finally {
    button.disabled = false;
    button.innerHTML = '<span id="aiBtnText">Get Suggestions</span>';
  }
}

function displayAISuggestions(suggestions) {
  const suggestionsDiv = document.getElementById('aiSuggestions');
  if (!suggestionsDiv) return;

  suggestionsDiv.innerHTML = '';

  suggestions.forEach((suggestion, index) => {
    const div = document.createElement('div');
    div.className = 'ai-suggestion';
    div.textContent = suggestion;
    div.onclick = () => applySuggestion(suggestion);
    suggestionsDiv.appendChild(div);
  });
}

function applySuggestion(suggestion) {
  // Create a new tile with the suggestion
  const x = Math.random() * 400 + 100;
  const y = Math.random() * 300 + 100;
  const tile = createTile(x, y, 'AI Suggestion', suggestion);
  tiles.push(tile);
  renderCanvas();
  selectTile(tile);
  scheduleSave();
  notify('Suggestion applied', 'success');
}

// Grid functionality
let gridVisible = false;
function toggleGrid() {
  gridVisible = !gridVisible;
  const button = document.querySelector('.grid-toggle-btn');

  if (gridVisible) {
    showGrid();
    button?.classList.add('active');
    button?.setAttribute('title', 'Hide Grid (ON)');
    notify('Grid enabled', 'success');
  } else {
    hideGrid();
    button?.classList.remove('active');
    button?.setAttribute('title', 'Show Grid (OFF)');
    notify('Grid disabled', 'success');
  }
}

function showGrid() {
  // Create grid overlay
  let gridOverlay = document.getElementById('gridOverlay');
  if (!gridOverlay) {
    gridOverlay = document.createElement('div');
    gridOverlay.id = 'gridOverlay';
    gridOverlay.className = 'grid-overlay';
    canvasContent.appendChild(gridOverlay);
  }

  gridOverlay.innerHTML = '';
  const gridSize = 20;
  const canvasRect = canvas.getBoundingClientRect();

  // Vertical lines
  for (let x = 0; x < canvasRect.width; x += gridSize) {
    const line = document.createElement('div');
    line.className = 'grid-line vertical';
    line.style.left = x + 'px';
    gridOverlay.appendChild(line);
  }

  // Horizontal lines
  for (let y = 0; y < canvasRect.height; y += gridSize) {
    const line = document.createElement('div');
    line.className = 'grid-line horizontal';
    line.style.top = y + 'px';
    gridOverlay.appendChild(line);
  }

  gridOverlay.classList.add('show');
}

function hideGrid() {
  const gridOverlay = document.getElementById('gridOverlay');
  if (gridOverlay) {
    gridOverlay.classList.remove('show');
  }
}

// Preset tile selector
function showPresetTileSelector() {
  const modal = document.getElementById('presetTileModal');
  if (modal) {
    modal.classList.add('show');
  } else {
    notify('Preset tile modal not found', 'error');
  }
}

function createPresetTile(type) {
  const modal = document.getElementById('presetTileModal');
  modal?.classList.remove('show');

  const x = Math.random() * 400 + 100;
  const y = Math.random() * 300 + 100;

  let title, content, style = '';

  switch (type) {
    case 'title':
      title = 'Main Title';
      content = 'Enter your main heading here';
      style = 'font-size: 1.2em; font-weight: bold; text-align: center;';
      break;
    case 'notes':
      title = 'Notes';
      content = '• Point 1\n• Point 2\n• Point 3';
      break;
    case 'component':
      title = 'Component';
      content = 'Component description\n\nInputs: \nOutputs: ';
      break;
    case 'custom':
      title = 'Custom Block';
      content = 'Customize this block for your needs';
      break;
    default:
      title = 'New Block';
      content = 'Enter content here';
  }

  const tile = createTile(x, y, title, content);
  if (style) {
    tile.style.cssText += style;
  }

  tiles.push(tile);
  renderCanvas();
  selectTile(tile);
  scheduleSave();
  notify(`${type} tile created`, 'success');
}

// Snap functionality
let snapToGrid = true;
let snapToTiles = true;

function toggleSnapToGrid() {
  snapToGrid = !snapToGrid;
  const button = document.querySelector('.snap-grid-btn');

  if (snapToGrid) {
    button?.classList.add('active');
    button?.setAttribute('title', 'Snap to Grid (ON)');
    notify('Snap to grid enabled', 'success');
  } else {
    button?.classList.remove('active');
    button?.setAttribute('title', 'Snap to Grid (OFF)');
    notify('Snap to grid disabled', 'success');
  }
}

function toggleSnapToTiles() {
  snapToTiles = !snapToTiles;
  const button = document.querySelector('.snap-tiles-btn');

  if (snapToTiles) {
    button?.classList.add('active');
    button?.setAttribute('title', 'Snap to Tiles (ON)');
    notify('Snap to tiles enabled', 'success');
  } else {
    button?.classList.remove('active');
    button?.setAttribute('title', 'Snap to Tiles (OFF)');
    notify('Snap to tiles disabled', 'success');
  }
}

// Share functionality with API integration
function openShareGraphModal() {
  if (!currentGraph) {
    notify('No graph selected', 'warn');
    return;
  }

  const modal = document.getElementById('shareGraphModal');
  if (modal) {
    modal.classList.add('show');
    loadSharedUsers();
  } else {
    notify('Share modal not found', 'error');
  }
}

function closeShareGraphModal() {
  const modal = document.getElementById('shareGraphModal');
  if (modal) {
    modal.classList.remove('show');
  }
}

async function shareGraph() {
  if (!currentGraph) {
    notify('No graph selected', 'error');
    return;
  }

  const emailInput = document.getElementById('shareEmail');
  const email = emailInput?.value.trim();

  if (!email) {
    notify('Please enter an email address', 'error');
    return;
  }

  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    notify('Please enter a valid email address', 'error');
    return;
  }

  const permission = document.querySelector('input[name="permission"]:checked')?.value || 'view';

  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch(`/api/graphs/${currentGraph.id}/share`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        email: email,
        permission: permission === 'view' ? 'viewer' : 'editor'
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to share graph');
    }

    const result = await response.json();
    notify(result.message || 'Graph shared successfully', 'success');
    emailInput.value = '';
    loadSharedUsers(); // Refresh the shared users list

  } catch (error) {
    console.error('Share error:', error);
    notify(error.message || 'Failed to share graph', 'error');
  }
}

async function loadSharedUsers() {
  if (!currentGraph) return;

  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch(`/api/graphs/${currentGraph.id}/shared-users`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.ok) {
      const sharedUsers = await response.json();
      displaySharedUsers(sharedUsers);
    }
  } catch (error) {
    console.error('Error loading shared users:', error);
  }
}

function displaySharedUsers(sharedUsers) {
  const container = document.getElementById('sharedUsersList');
  if (!container) return;

  container.innerHTML = '';

  if (sharedUsers.length === 0) {
    container.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">No users shared with this graph</p>';
    return;
  }

  sharedUsers.forEach(user => {
    const userDiv = document.createElement('div');
    userDiv.className = 'shared-user-item';
    userDiv.innerHTML = `
      <div class="shared-user-info">
        <div class="shared-user-email">${user.email}</div>
        <div class="shared-user-permission">${user.permission}</div>
      </div>
      <div class="shared-user-actions">
        <button class="change-permission-btn" onclick="changeUserPermission('${user.email}', '${user.permission}')">
          Change
        </button>
        <button class="remove-user-btn" onclick="removeSharedUser('${user.email}')">
          Remove
        </button>
      </div>
    `;
    container.appendChild(userDiv);
  });
}

async function changeUserPermission(email, currentPermission) {
  const newPermission = currentPermission === 'viewer' ? 'editor' : 'viewer';

  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch(`/api/graphs/${currentGraph.id}/change-permission`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        email: email,
        permission: newPermission
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to change permission');
    }

    notify(`Permission changed to ${newPermission}`, 'success');
    loadSharedUsers(); // Refresh the list

  } catch (error) {
    console.error('Change permission error:', error);
    notify(error.message || 'Failed to change permission', 'error');
  }
}

async function removeSharedUser(email) {
  if (!confirm(`Remove ${email} from this graph?`)) return;

  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch(`/api/graphs/${currentGraph.id}/remove-user`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        email: email
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to remove user');
    }

    notify('User removed successfully', 'success');
    loadSharedUsers(); // Refresh the list

  } catch (error) {
    console.error('Remove user error:', error);
    notify(error.message || 'Failed to remove user', 'error');
  }
}

// Connection mode functionality
let isConnecting = false;
let connectionStart = null;

function toggleConnectMode(enable) {
  isConnecting = enable;
  const connectBtn = document.getElementById('modeConnect');
  const selectBtn = document.getElementById('modeNone');

  if (enable) {
    connectBtn?.classList.add('active');
    selectBtn?.classList.remove('active');
    canvas.style.cursor = 'crosshair';
    notify('Connection mode enabled - click tiles to connect', 'success');
  } else {
    connectBtn?.classList.remove('active');
    selectBtn?.classList.add('active');
    canvas.style.cursor = 'grab';
    connectionStart = null;
    notify('Selection mode enabled', 'success');
  }
}

// Tile manipulation functions
function duplicateTile() {
  if (!selectedTile) {
    notify('No tile selected', 'warn');
    return;
  }

  const originalX = parseFloat(selectedTile.dataset.x);
  const originalY = parseFloat(selectedTile.dataset.y);
  const title = selectedTile.querySelector('.tile-title')?.value || '';
  const content = selectedTile.querySelector('.tile-content')?.value || '';

  const newTile = createTile(originalX + 20, originalY + 20, title, content);
  tiles.push(newTile);
  renderCanvas();
  selectTile(newTile);
  scheduleSave();
  notify('Tile duplicated', 'success');
}

function bringToFront() {
  if (!selectedTile) {
    notify('No tile selected', 'warn');
    return;
  }

  selectedTile.style.zIndex = '1000';
  notify('Tile brought to front', 'success');
}

function sendToBack() {
  if (!selectedTile) {
    notify('No tile selected', 'warn');
    return;
  }

  selectedTile.style.zIndex = '1';
  notify('Tile sent to back', 'success');
}

// Tile styling functions
function changeTileShape(shape) {
  if (!selectedTile) {
    notify('No tile selected', 'warn');
    return;
  }

  // Remove existing shape classes
  selectedTile.classList.remove('rounded', 'circular', 'hexagon', 'diamond', 'triangle', 'parallelogram');

  if (shape !== 'rectangle') {
    selectedTile.classList.add(shape);
  }

  scheduleSave();
  notify(`Tile shape changed to ${shape}`, 'success');
}

function showColorPicker() {
  if (!selectedTile) {
    notify('No tile selected', 'warn');
    return;
  }

  // Create a simple color picker
  const colors = ['#ffffff', '#f8f9fa', '#e9ecef', '#dee2e6', '#ced4da', '#adb5bd',
                  '#6c757d', '#495057', '#343a40', '#212529', '#007bff', '#6610f2',
                  '#6f42c1', '#e83e8c', '#dc3545', '#fd7e14', '#ffc107', '#28a745',
                  '#20c997', '#17a2b8'];

  const picker = document.createElement('div');
  picker.className = 'color-picker-popout show';
  picker.style.position = 'absolute';
  picker.style.top = '50px';
  picker.style.right = '20px';
  picker.style.zIndex = '10000';

  picker.innerHTML = `
    <div class="color-picker-header">
      <span class="color-picker-title">Choose Color</span>
      <button class="color-picker-close" onclick="this.parentElement.parentElement.remove()">×</button>
    </div>
    <div class="color-picker-grid">
      ${colors.map(color => `
        <div class="color-picker-option" style="background-color: ${color}"
             onclick="applyTileColor('${color}'); this.parentElement.parentElement.remove();"></div>
      `).join('')}
    </div>
  `;

  document.body.appendChild(picker);
}

function applyTileColor(color) {
  if (!selectedTile) return;

  selectedTile.style.backgroundColor = color;
  scheduleSave();
  notify('Tile color changed', 'success');
}

function resetTileColor() {
  if (!selectedTile) {
    notify('No tile selected', 'warn');
    return;
  }

  selectedTile.style.backgroundColor = '';
  scheduleSave();
  notify('Tile color reset', 'success');
}

// Connection management functions
let selectedConnection = null;

function deleteSelectedConnection() {
  if (!selectedConnection) {
    notify('No connection selected', 'warn');
    return;
  }

  const index = connections.indexOf(selectedConnection);
  if (index > -1) {
    connections.splice(index, 1);
    selectedConnection = null;
    renderConnections();
    scheduleSave();
    notify('Connection deleted', 'success');
  }
}

function changeConnectionColor() {
  if (!selectedConnection) {
    notify('No connection selected', 'warn');
    return;
  }

  const colors = ['#007bff', '#dc3545', '#28a745', '#ffc107', '#17a2b8', '#6f42c1'];
  const currentColor = selectedConnection.color || '#007bff';
  const currentIndex = colors.indexOf(currentColor);
  const nextIndex = (currentIndex + 1) % colors.length;
  const newColor = colors[nextIndex];

  selectedConnection.color = newColor;
  renderConnections();
  scheduleSave();
  notify('Connection color changed', 'success');
}

function changeLineStyle(style) {
  if (!selectedConnection) {
    notify('No connection selected', 'warn');
    return;
  }

  selectedConnection.style = style;
  renderConnections();
  scheduleSave();
  notify(`Connection style changed to ${style}`, 'success');
}

function renderConnections() {
  const svg = document.getElementById('connections-svg');
  if (!svg) return;

  // Clear existing connections
  const existingPaths = svg.querySelectorAll('path');
  existingPaths.forEach(path => path.remove());

  connections.forEach(connection => {
    const fromTile = tiles.find(t => t.dataset.tileId === connection.from);
    const toTile = tiles.find(t => t.dataset.tileId === connection.to);

    if (fromTile && toTile) {
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

      const fromRect = fromTile.getBoundingClientRect();
      const toRect = toTile.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();

      const fromX = fromRect.right - canvasRect.left;
      const fromY = fromRect.top + fromRect.height / 2 - canvasRect.top;
      const toX = toRect.left - canvasRect.left;
      const toY = toRect.top + toRect.height / 2 - canvasRect.top;

      const d = `M ${fromX} ${fromY} L ${toX} ${toY}`;
      path.setAttribute('d', d);
      path.setAttribute('stroke', connection.color || '#007bff');
      path.setAttribute('stroke-width', '3');
      path.setAttribute('fill', 'none');
      path.setAttribute('marker-end', 'url(#arrowhead)');

      if (connection.style === 'dashed') {
        path.setAttribute('stroke-dasharray', '5,5');
      } else if (connection.style === 'dotted') {
        path.setAttribute('stroke-dasharray', '2,2');
      }

      path.onclick = () => {
        selectedConnection = connection;
        path.classList.add('selected');
      };

      svg.appendChild(path);
    }
  });
}

// Context menu functionality
function ctxAction(action) {
  const menu = document.getElementById('ctxMenu');
  if (menu) {
    menu.style.display = 'none';
  }

  if (!selectedTile) return;

  switch (action) {
    case 'edit':
      selectedTile.querySelector('.tile-title')?.focus();
      break;
    case 'color':
      showColorPicker();
      break;
    case 'shape':
      // Cycle through shapes
      const shapes = ['rectangle', 'rounded', 'circular', 'hexagon'];
      const currentShape = shapes.find(s => selectedTile.classList.contains(s)) || 'rectangle';
      const currentIndex = shapes.indexOf(currentShape);
      const nextShape = shapes[(currentIndex + 1) % shapes.length];
      changeTileShape(nextShape);
      break;
    case 'duplicate':
      duplicateTile();
      break;
    case 'delete':
      deleteSelected();
      break;
  }
}

// Cache status modal
function closeCacheStatusModal() {
  const modal = document.getElementById('cacheStatusModal');
  if (modal) {
    modal.classList.remove('show');
  }
}

async function showCacheStatus() {
  if (!currentGraph) {
    notify('No graph selected', 'warn');
    return;
  }

  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch(`/api/graphs/${currentGraph.id}/cache-status`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.ok) {
      const status = await response.json();
      updateCacheStatusDisplay(status);
      const modal = document.getElementById('cacheStatusModal');
      if (modal) {
        modal.classList.add('show');
      }
    }
  } catch (error) {
    console.error('Cache status error:', error);
    notify('Failed to get cache status', 'error');
  }
}

function updateCacheStatusDisplay(status) {
  const lastSaveElement = document.getElementById('lastSaveTime');
  const autoSaveElement = document.getElementById('autoSaveStatus');
  const pendingElement = document.getElementById('pendingUpdatesCount');
  const connectionElement = document.getElementById('connectionStatus');

  if (lastSaveElement) {
    lastSaveElement.textContent = status.lastModified ?
      new Date(status.lastModified).toLocaleString() : 'Never';
  }

  if (autoSaveElement) {
    autoSaveElement.textContent = 'Enabled';
  }

  if (pendingElement) {
    pendingElement.textContent = status.dirty ? '1' : '0';
  }

  if (connectionElement) {
    connectionElement.textContent = 'Online';
  }
}

// Force save function
async function forceSave() {
  if (!currentGraph) {
    notify('No graph to save', 'warn');
    return;
  }

  try {
    await saveGraph();

    // Also call the force save API endpoint
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch(`/api/graphs/${currentGraph.id}/save`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.ok) {
      notify('Graph force saved successfully', 'success');
    } else {
      throw new Error('Force save failed');
    }
  } catch (error) {
    console.error('Force save error:', error);
    notify('Failed to force save', 'error');
  }
}

// Share section toggle
function toggleShareSection() {
  const section = document.getElementById('shareSection');
  if (!section) return;

  const isVisible = section.style.display !== 'none';
  section.style.display = isVisible ? 'none' : 'block';

  const button = document.querySelector('.share-toggle');
  if (button) {
    button.textContent = isVisible ? 'Show' : 'Hide';
  }
}

// Enhanced API integration functions
async function loadInbox() {
  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch('/api/graphs/inbox', {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.ok) {
      const invitations = await response.json();
      displayInbox(invitations);
    } else {
      console.error('Failed to load inbox');
    }
  } catch (error) {
    console.error('Inbox error:', error);
  }
}

function displayInbox(invitations) {
  const container = document.getElementById('inboxContent');
  if (!container) return;

  container.innerHTML = '';

  if (invitations.length === 0) {
    container.innerHTML = '<div style="text-align:center;color:var(--text-secondary);padding:20px;">No pending invitations</div>';
    return;
  }

  invitations.forEach(invitation => {
    const div = document.createElement('div');
    div.className = 'inbox-item pending';
    div.innerHTML = `
      <div class="inbox-title">${invitation.graph_title}</div>
      <div class="inbox-meta">Shared by ${invitation.sharer_name} • ${invitation.permission}</div>
      <div class="inbox-actions">
        <button class="inbox-btn accept" onclick="respondToInvitation(${invitation.id}, 'accept')">Accept</button>
        <button class="inbox-btn reject" onclick="respondToInvitation(${invitation.id}, 'reject')">Reject</button>
      </div>
    `;
    container.appendChild(div);
  });
}

async function respondToInvitation(id, action) {
  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch(`/api/graphs/inbox/${id}/${action}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.ok) {
      notify(`Invitation ${action}ed`, 'success');
      loadInbox(); // Refresh inbox
      if (action === 'accept') {
        loadGraphs(); // Refresh graphs list
      }
    } else {
      throw new Error(`Failed to ${action} invitation`);
    }
  } catch (error) {
    console.error(`${action} invitation error:`, error);
    notify(`Failed to ${action} invitation`, 'error');
  }
}

// Graph statistics API integration
async function getGraphStats() {
  if (!currentGraph) {
    notify('No graph selected', 'warn');
    return;
  }

  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch(`/api/graphs/${currentGraph.id}/stats`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.ok) {
      const stats = await response.json();
      displayGraphStats(stats);
    } else {
      throw new Error('Failed to get graph statistics');
    }
  } catch (error) {
    console.error('Graph stats error:', error);
    notify('Failed to get graph statistics', 'error');
  }
}

function displayGraphStats(stats) {
  const message = `
Graph Statistics:
• Tiles: ${stats.tile_count}
• Connections: ${stats.connection_count}
• Characters: ${stats.total_characters}
• Data size: ${Math.round(stats.data_size_bytes / 1024)} KB
• Last updated: ${new Date(stats.last_updated).toLocaleString()}
  `;

  alert(message); // Simple display - could be enhanced with a modal
}

// User profile API integration
async function getUserProfile() {
  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch('/api/user/profile', {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.ok) {
      const profile = await response.json();
      document.getElementById('userName').textContent = profile.name;
      return profile;
    }
  } catch (error) {
    console.error('Profile error:', error);
  }
}

async function updateUserProfile(name) {
  try {
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch('/api/user/profile', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ name })
    });

    if (response.ok) {
      notify('Profile updated successfully', 'success');
      getUserProfile(); // Refresh display
    } else {
      throw new Error('Failed to update profile');
    }
  } catch (error) {
    console.error('Update profile error:', error);
    notify('Failed to update profile', 'error');
  }
}

// Enhanced connection creation
function createConnection(fromTileId, toTileId) {
  const connection = {
    id: 'conn_' + Date.now() + '_' + Math.floor(Math.random() * 1000),
    from: fromTileId,
    to: toTileId,
    style: 'solid',
    color: '#007bff'
  };

  connections.push(connection);
  renderConnections();
  scheduleSave();
  notify('Connection created', 'success');

  return connection;
}

// Enhanced tile click handling for connections
function handleTileClick(tile) {
  if (isConnecting) {
    if (!connectionStart) {
      connectionStart = tile.dataset.tileId;
      tile.style.outline = '3px solid #007bff';
      notify('Select target tile to connect', 'info');
    } else if (connectionStart !== tile.dataset.tileId) {
      createConnection(connectionStart, tile.dataset.tileId);

      // Clear connection start
      const startTile = tiles.find(t => t.dataset.tileId === connectionStart);
      if (startTile) {
        startTile.style.outline = '';
      }
      connectionStart = null;

      // Exit connection mode
      toggleConnectMode(false);
    }
  } else {
    selectTile(tile);
  }
}

// Initialize inbox and enhanced features
function initializeEnhancedFeatures() {
  loadInbox();
  getUserProfile();

  // Add click handlers for connection mode
  document.addEventListener('click', (e) => {
    const tile = e.target.closest('.tile');
    if (tile && isConnecting) {
      e.stopPropagation();
      handleTileClick(tile);
    }
  });

  // Add keyboard shortcuts for new features
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey || e.metaKey) {
      switch (e.key) {
        case 'd':
          e.preventDefault();
          duplicateTile();
          break;
        case 's':
          e.preventDefault();
          forceSave();
          break;
        case 'g':
          e.preventDefault();
          toggleGrid();
          break;
      }
    }
  });
}


/* =========================
   Init
========================= */
document.addEventListener('DOMContentLoaded', init);

async function init(){
  try { await checkAuth(); } catch {}
  await loadGraphs().catch(()=>{});
  await loadInbox().catch(()=>{});
  
  // Load from localStorage only if no graphs loaded from server and no tiles exist
  if (!currentGraph && tiles.length === 0) {
    loadFromLocalStorage();
  }
  
  setupCanvas();
  setupTheme();
  setupRealtimeUpdates();
  setupAutoSave();
  setupGridVisualization();
  setupSnapping();
  setupKeyboardShortcuts();
  addShareEmailListener();
  initializePermissionSelector();
  addCacheStatusButton();
  
  // Set up import file event listener
  const importFile = document.getElementById('importFile');
  if (importFile) {
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const d = JSON.parse(reader.result);
          // load into current graph
          tiles = [];
          connections = [];
          (d.tiles || []).forEach(t => tiles.push(createTile(t.x, t.y, t.title, t.content, t.id, t.shape || 'rectangle', t.preset || 'custom', t.color || '#ffffff')));
          connections = d.connections || [];
          renderCanvas();
          scheduleSave();
          notify('Imported');
        } catch {
          notify('Import failed', 'error');
        }
      };
      reader.readAsText(file);
    });
  }
  loadCollaborators();
  notify('Ready. Press N to add a tile. Hold Alt and drag between tiles to connect.', 'warn', 3500);
}

/* =========================
   Helpers / UI
========================= */
function notify(msg, type='success', ms=2200){
  const n = document.getElementById('notification');
  n.innerHTML = msg;
  n.className = `notification ${type}`;
  n.classList.add('show');
  setTimeout(()=>{ n.classList.remove('show'); }, ms);
}

function toggleFolder(folderId){
  const folder = document.getElementById(folderId);
  const header = folder.previousElementSibling;
  const arrow = header.querySelector('.folder-arrow');
  folder.classList.toggle('expanded');
  arrow.classList.toggle('expanded');
  header.classList.toggle('active');
}

function toggleShareSection(){
  const section = document.getElementById('shareSection');
  const btn = section.querySelector('.share-toggle');
  const visible = section.classList.toggle('show');
  btn.textContent = visible ? 'Hide' : 'Show';
}

/* =========================
   Theme
========================= */
function setupTheme(){
  const saved = localStorage.getItem('flowpad_theme') || 'dark';
  document.documentElement.setAttribute('data-theme', saved);
  updateThemeIcon(saved);
  if (tiles.length) updateTileColorsForTheme(saved);
}
function toggleTheme(){
  const cur = document.documentElement.getAttribute('data-theme');
  const nxt = cur === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', nxt);
  localStorage.setItem('flowpad_theme', nxt);
  updateThemeIcon(nxt);
  updateTileColorsForTheme(nxt);
}
function updateThemeIcon(theme){ document.getElementById('theme-icon').textContent = theme==='dark'?'Moon':'Sun'; }
function updateTileColorsForTheme(theme){
  tiles.forEach(t=>{
    const c = getComputedStyle(t).backgroundColor;
    t.style.backgroundColor = getThemeAdjustedColor(c, theme);
  });
  renderConnections();
}
function toHex(c){
  c = (c||'').trim();
  if (c.startsWith('rgb')) {
    const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if (m){ const [r,g,b]=[m[1],m[2],m[3]].map(n=>+n); return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
  }
  if (/^#([0-9a-f]{3})$/i.test(c)) return '#'+c.slice(1).split('').map(ch=>ch+ch).join('');
  if (/^#([0-9a-f]{6})$/i.test(c)) return c.toLowerCase();
  return '#ffffff';
}
function adjustColorBrightness(hex, factor){
  hex = toHex(hex);
  const r = Math.min(255, Math.max(0, Math.round(parseInt(hex.slice(1,3),16)*factor)));
  const g = Math.min(255, Math.max(0, Math.round(parseInt(hex.slice(3,5),16)*factor)));
  const b = Math.min(255, Math.max(0, Math.round(parseInt(hex.slice(5,7),16)*factor)));
  return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
}
function getThemeAdjustedColor(color, theme){
  color = toHex(color);
  if (color==='#ffffff') return theme==='light' ? '#2d3748' : '#ffffff';
  if (color==='#000000') return theme==='light' ? '#ffffff' : '#2d3748';
  return adjustColorBrightness(color, theme==='light'?1.1:0.9);
}

/* =========================
   Grid / Snap / Zoom
========================= */
function setupGridVisualization(){
  createGridLines();
  window.addEventListener('resize', createGridLines);
}
function createGridLines(){
  // Use requestAnimationFrame for smooth grid rendering
  if (!createGridLines.rafId) {
    createGridLines.rafId = requestAnimationFrame(() => {
      let gridOverlay = document.getElementById('grid-overlay');
      if (!gridOverlay){ gridOverlay = document.createElement('div'); gridOverlay.id='grid-overlay'; gridOverlay.className='grid-overlay'; canvas.appendChild(gridOverlay); }
      gridOverlay.innerHTML = '';
      const rect = canvas.getBoundingClientRect();
      
      // Calculate grid spacing in screen coordinates, accounting for zoom and offset
      const screenGridSize = gridSize * zoom;
      
      // Create grid lines that move with the canvas offset
      for(let x = 0; x <= rect.width + Math.abs(canvasOffset.x); x += screenGridSize){
        const l = document.createElement('div'); 
        l.className='grid-line vertical'; 
        l.style.left = (x - canvasOffset.x) + 'px'; 
        gridOverlay.appendChild(l);
      }
      for(let y = 0; y <= rect.height + Math.abs(canvasOffset.y); y += screenGridSize){
        const l = document.createElement('div'); 
        l.className='grid-line horizontal'; 
        l.style.top = (y - canvasOffset.y) + 'px'; 
        gridOverlay.appendChild(l);
      }
      
      createGridLines.rafId = null;
    });
  }
}
function toggleGrid(){
  showGrid = !showGrid;
  const overlay = document.getElementById('grid-overlay');
  overlay && overlay.classList.toggle('show', showGrid);
  notify(`Grid ${showGrid?'ON':'OFF'}`);
}
function setupSnapping(){
  if (!snapIndicators.length){
    for (let i=0;i<10;i++){ const d=document.createElement('div'); d.className='snap-indicator'; canvas.appendChild(d); snapIndicators.push(d); }
  }
  if (!snapLines.length){
    for (let i=0;i<4;i++){ const l=document.createElement('div'); l.className='grid-snap-line'; canvas.appendChild(l); snapLines.push(l); }
  }
}
function worldToScreen(x,y){ return { x: x*zoom + canvasOffset.x, y: y*zoom + canvasOffset.y }; }
function screenToWorld(x,y){ return { x: (x - canvas.getBoundingClientRect().left - canvasOffset.x)/zoom, y: (y - canvas.getBoundingClientRect().top - canvasOffset.y)/zoom }; }
function getSnapPosition(x,y){ // x,y in world coords
  let sx = x, sy = y; const snapDist = 8/zoom;
  if (snapToGrid){
    const gx = Math.round(x/gridSize)*gridSize, gy = Math.round(y/gridSize)*gridSize;
    if (Math.abs(x-gx)<snapDist){ sx=gx; showSnapLineAt(worldToScreen(gx,0).x,'v'); }
    if (Math.abs(y-gy)<snapDist){ sy=gy; showSnapLineAt(worldToScreen(0,gy).y,'h'); }
  }
  if (snapToTiles){
    tiles.forEach(t=>{
      if (t===selectedTile) return;
      const tx = +t.dataset.baseX||0, ty=+t.dataset.baseY||0, tw=t.offsetWidth, th=t.offsetHeight;
      const edges = [{x:tx},{x:tx+tw},{y:ty},{y:ty+th}];
      edges.forEach(e=>{
        if (e.x!==undefined && Math.abs(x-e.x)<snapDist){ sx=e.x; showSnapLineAt(worldToScreen(e.x,0).x,'v'); }
        if (e.y!==undefined && Math.abs(y-e.y)<snapDist){ sy=e.y; showSnapLineAt(worldToScreen(0,e.y).y,'h'); }
      });
      const cx = tx+tw/2, cy=ty+th/2;
      if (Math.abs(x-cx)<snapDist){ sx=cx; }
      if (Math.abs(y-cy)<snapDist){ sy=cy; }
    });
  }
  showSnapDot(worldToScreen(sx,sy));
  return {x:sx,y:sy};
}
function showSnapDot(p){
  const ind = snapIndicators.find(el=>!el.classList.contains('show'));
  if (!ind) return;
  ind.style.left = p.x+'px'; ind.style.top = p.y+'px'; ind.classList.add('show');
  setTimeout(()=>ind.classList.remove('show'), 180);
}
function showSnapLineAt(pos,orient){
  const l = snapLines.find(el=>!el.classList.contains('show'));
  if (!l) return;
  if (orient==='v'){ l.style.left=pos+'px'; l.style.top='0px'; l.style.width='1px'; l.style.height='100%'; l.className='grid-snap-line vertical show'; }
  else { l.style.top=pos+'px'; l.style.left='0px'; l.style.height='1px'; l.style.width='100%'; l.className='grid-snap-line horizontal show'; }
  setTimeout(()=>l.classList.remove('show'), 220);
}
function clearSnapIndicators(){ 
  // Clear all snap indicators
  snapIndicators.forEach(i=>i.classList.remove('show')); 
  snapLines.forEach(l=>l.classList.remove('show')); 
  
  // Also clear any remaining snap indicators
  document.querySelectorAll('.snap-indicator').forEach(i => i.classList.remove('show'));
  document.querySelectorAll('.grid-snap-line').forEach(l => l.classList.remove('show'));
  
  // Clear any snap dots that might be lingering
  document.querySelectorAll('.snap-dot').forEach(d => d.remove());
  
  // Force hide all snap-related elements
  document.querySelectorAll('[class*="snap"]').forEach(el => {
    if (el.classList.contains('show')) {
      el.classList.remove('show');
    }
  });
}

function zoomIn(){ setZoom(zoom*1.1); }
function zoomOut(){ setZoom(zoom/1.1); }
function zoomReset(){ setZoom(1); }
function setZoom(val){
  zoom = Math.min(3, Math.max(0.25, val));
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
  
  // Recreate grid to maintain alignment
  if (showGrid) {
    createGridLines();
  }
  
  document.querySelectorAll('.toolbar .tool-row button')[1]?.setAttribute('title', `Reset Zoom (${Math.round(zoom*100)}%)`);
}

/* =========================
   Autosave / Realtime
========================= */
function setupAutoSave(){
  autoSaveTimer = setInterval(()=>{ if (isDirty && currentGraph && Date.now()-lastSaveTime>15000) autoSaveGraph(); }, 15000);
}
function setupRealtimeUpdates(){
  setInterval(()=>{ if (pendingUpdates.length && currentGraph) sendRealtimeUpdates(); }, 2000);
}
function markAsDirty(){ isDirty=true; lastSaveTime=Date.now(); pushHistory(); }
async function autoSaveGraph(){
  if (!currentGraph || !isDirty) return;
  
  // Prevent saving for invalid graph IDs (like demo-1 or local_*)
  if (currentGraph.id && (currentGraph.id.toString().startsWith('demo-') || currentGraph.id.toString().startsWith('local_') || currentGraph.id === 'demo-1')) {
    console.log('Skipping auto-save for local/demo graph:', currentGraph.id);
    return;
  }
  const indicator = document.getElementById('autoSaveIndicator');
  const text = document.getElementById('autoSaveText');
  try{
    indicator.classList.add('show','saving'); text.textContent='Saving...';
    const token = localStorage.getItem('flowpad_token');
    const data = serializeGraph();
    
    if (token && currentGraph.id && !currentGraph.id.toString().startsWith('local_') && !currentGraph.id.toString().startsWith('demo-')) {
      // Try to save to server if authenticated and graph ID is valid
      try {
        const res = await fetch(`/api/graphs/${currentGraph.id}`,{
          method:'PUT',
          headers:{'Content-Type':'application/json','Authorization':`Bearer ${token}`},
          body: JSON.stringify({ title: currentGraph.title, data })
        });
        if (res.ok) {
          isDirty=false; lastSaveTime=Date.now();
          indicator.classList.remove('saving'); indicator.classList.add('saved');
          text.textContent = `Saved to server at ${new Date().toLocaleTimeString()}`;
          setTimeout(()=>indicator.classList.remove('show','saved'), 2000);
          return;
        }
      } catch (serverError) {
        console.log('Server save failed, falling back to local storage');
      }
    }
    
    // Fallback to localStorage (demo mode)
    try {
      localStorage.setItem(`flowpad_graph_${currentGraph.id}`, JSON.stringify({
        title: currentGraph.title,
        data: data,
        updated_at: Date.now()
      }));
      isDirty=false; lastSaveTime=Date.now();
      indicator.classList.remove('saving'); indicator.classList.add('saved');
      text.textContent = `Saved locally at ${new Date().toLocaleTimeString()}`;
      setTimeout(()=>indicator.classList.remove('show','saved'), 2000);
    } catch (localError) {
      throw new Error('Local save failed');
    }
  }catch(e){
    indicator.classList.remove('saving'); indicator.classList.add('error');
    text.textContent='Save failed'; setTimeout(()=>indicator.classList.remove('show','error'), 3000);
  }
}
function scheduleSave(){ 
  markAsDirty(); 
  // Don't auto-save while actively editing
  if (!selectedTile && !selectedConnection) {
    clearTimeout(window.saveTimeout); 
    window.saveTimeout=setTimeout(()=>{ if(isDirty) autoSaveGraph(); }, 700); 
  }
}

function saveOnUnselect(){
  if (isDirty) {
    clearTimeout(window.saveTimeout);
    window.saveTimeout = setTimeout(() => { if(isDirty) autoSaveGraph(); }, 100);
  }
}
function addPendingUpdate(type, data){ pendingUpdates.push({type,data,timestamp:Date.now()}); }
function sendRealtimeUpdates(){
  if (!currentGraph || !pendingUpdates.length) return;
  
  // Prevent sending updates for invalid graph IDs (like demo-1 or local_*)
  if (currentGraph.id && (currentGraph.id.toString().startsWith('demo-') || currentGraph.id.toString().startsWith('local_') || currentGraph.id === 'demo-1')) {
    console.log('Skipping realtime updates for local/demo graph:', currentGraph.id);
    pendingUpdates.length = 0; // Clear pending updates
    return;
  }
  
  const updates=[...pendingUpdates]; pendingUpdates=[];
  fetch(`/api/graphs/${currentGraph.id}/realtime`,{
    method:'POST',
    headers:{'Content-Type':'application/json','Authorization':`Bearer ${localStorage.getItem('flowpad_token')}`},
    body: JSON.stringify({ updates })
  }).catch(()=>{ pendingUpdates.unshift(...updates); });
}
function forceSave(){ autoSaveGraph(); }

/* =========================
   Canvas interactions
========================= */
function setupCanvas(){
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('contextmenu', onContextMenu);
  document.addEventListener('click', e => { if (!ctxMenu.contains(e.target)) ctxMenu.classList.remove('show'); });
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
}
function onMouseDown(e){
  const tile = e.target.closest('.tile');
  // Support both Alt key and Option key (Mac) for connections
  if (tile && (e.altKey || e.metaKey)){ startConnectionFromTile(tile, e); return; }
  if (e.target.classList.contains('connection-dot')){ startConnectionFromPort(e.target, e); return; }
  if (tile && e.target.tagName !== 'TEXTAREA'){ startDragging(e, tile); }
  else if (!tile){ startPanning(e); }
}
function onMouseMove(e){
  if (isConnecting && connectionStart) updateConnectionPreview(e);
  else if (isDragging && selectedTile) updateDragging(e);
  else if (isPanning) updatePanning(e);
}
function onMouseUp(e){
  if (isConnecting) finishConnection(e);
  if (isDragging) finishDragging();
  isPanning=false;
}
function onContextMenu(e){
  e.preventDefault();
  const tile = e.target.closest('.tile');
  ctxTargetTile = tile || null;
  openCtxMenu(e.clientX, e.clientY, tile);
}
function openCtxMenu(x,y,tile){
  ctxMenu.style.left = x+'px'; ctxMenu.style.top = y+'px';
  ctxMenu.classList.add('show');
}
function ctxAction(action) {
  if (!selectedTile) return;
  
  switch (action) {
    case 'edit':
      selectedTile.querySelector('.tile-content')?.focus();
      break;
    case 'color':
      openColorPopup(selectedTile, (c) => {
        selectedTile.style.backgroundColor = c;
        scheduleSave();
      });
      break;
    case 'shape':
      // Show shape options
      break;
    case 'duplicate':
      duplicateTile();
      break;
    case 'delete':
      deleteSelected();
      break;
  }
  
  // Hide context menu
  const ctxMenu = document.getElementById('ctxMenu');
  if (ctxMenu) ctxMenu.style.display = 'none';
}

/* Panning */
function startPanning(e){ isPanning=true; panStart.x=e.clientX; panStart.y=e.clientY; }
function updatePanning(e){
  const dx = e.clientX - panStart.x, dy = e.clientY - panStart.y;
  panStart.x = e.clientX; panStart.y = e.clientY;
  canvasOffset.x += dx; canvasOffset.y += dy;
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
  
  // Recreate grid to maintain alignment during panning
  if (showGrid) {
    createGridLines();
  }
}

/* Dragging */
function startDragging(e,tile){
  isDragging=true; selectedTile=tile; selectTile(tile);
  const w = screenToWorld(e.clientX, e.clientY);
  dragOffsetWorld.x = w.x - (+tile.dataset.baseX||0);
  dragOffsetWorld.y = w.y - (+tile.dataset.baseY||0);
}
function updateDragging(e){
  const w = screenToWorld(e.clientX, e.clientY);
  let x = w.x - dragOffsetWorld.x, y = w.y - dragOffsetWorld.y;
  const snap = getSnapPosition(x,y); x=snap.x; y=snap.y;
  
  // Use requestAnimationFrame for smooth updates
  if (!updateDragging.rafId) {
    updateDragging.rafId = requestAnimationFrame(() => {
      // Update tile position immediately for responsive feel
      selectedTile.dataset.baseX = x; 
      selectedTile.dataset.baseY = y;
      selectedTile.style.left = x+'px'; 
      selectedTile.style.top = y+'px';
      
      // Add updating class for visual feedback
      selectedTile.classList.add('tile-updating');
      
      // Re-render connections immediately for responsive feel
      renderConnections();
      
      // Hide tile menu while dragging for cleaner UX
      const tileToolbar = document.getElementById('tileToolbar');
      if (tileToolbar) {
        tileToolbar.classList.remove('show');
      }
      
      // Mark as dirty and schedule save
      addPendingUpdate('tile_move', { tileId:selectedTile.dataset.tileId, x,y });
      markAsDirty();
      
      updateDragging.rafId = null;
    });
  }
}
function finishDragging(){
  if (selectedTile) selectedTile.classList.remove('tile-updating');
  
  // Clean up requestAnimationFrame
  if (updateDragging.rafId) {
    cancelAnimationFrame(updateDragging.rafId);
    updateDragging.rafId = null;
  }
  
  selectedTile=null; isDragging=false; clearSnapIndicators();
}

/* Connections */
function toggleConnectMode(on){
  document.body.classList.toggle('connect-mode', on);
  document.getElementById('connectionMode').style.display = 'block';
  document.getElementById('modeConnect').classList.toggle('active', on);
  document.getElementById('modeNone').classList.toggle('active', !on);
}
function startConnectionFromTile(tile,e){
  isConnecting=true;
  const rect = tile.getBoundingClientRect(), cRect = canvas.getBoundingClientRect();
  connectionStart = {
    tile, fromPort: 'auto',
    sx: rect.left + rect.width/2 - cRect.left,
    sy: rect.top + rect.height/2 - cRect.top
  };
}
function startConnectionFromPort(portEl,e){
  isConnecting=true;
  const tile = portEl.closest('.tile');
  const cRect = canvas.getBoundingClientRect();
  const rx = portEl.getBoundingClientRect();
  connectionStart = {
    tile, fromPort: portEl.dataset.port,
    sx: rx.left + rx.width/2 - cRect.left,
    sy: rx.top + rx.height/2 - cRect.top
  };
}
function updateConnectionPreview(e){
  const prev = document.querySelector('.connection-preview');
  prev && prev.remove();
  const rect = canvas.getBoundingClientRect();
  const endX = e.clientX - rect.left, endY = e.clientY - rect.top;
  const preview = createConnectionSVG(connectionStart.sx, connectionStart.sy, endX, endY, true);
  preview.classList.add('connection-preview');
  canvasContent.appendChild(preview);
}
function finishConnection(e){
  const targetTile = e.target.closest('.tile');
  const preview = document.querySelector('.connection-preview'); preview && preview.remove();
  if (targetTile && targetTile!==connectionStart.tile){
    const ports = findOptimalPort(connectionStart.tile, targetTile, connectionStart.fromPort, null);
    const connection = {
      id:'conn_'+Date.now()+'_'+Math.floor(Math.random()*1000),
      fromTile: connectionStart.tile.dataset.tileId,
      fromDot: ports.fromPort.type,
      toTile: targetTile.dataset.tileId,
      toDot:   ports.toPort.type,
      color: getRandomConnectionColor(),
      style: 'solid',
      marker: 'arrow'
    };
    connections.push(connection);
    addPendingUpdate('connection_create', connection);
    markAsDirty();
    renderCanvas();
    notify('Connection created');
  }
  isConnecting=false; connectionStart=null;
}

function getRandomConnectionColor(){
  const colors = ['#3b82f6','#ef4444','#10b981','#f59e0b','#8b5cf6','#ec4899','#06b6d4','#84cc16','#f97316','#6366f1'];
  return colors[Math.floor(Math.random()*colors.length)];
}

function findOptimalPort(fromTile, toTile, fromDotType, toDotType){
  const fr = getTileWorldRect(fromTile), tr = getTileWorldRect(toTile);
  const fromCenter = {x:fr.x+fr.w/2, y:fr.y+fr.h/2};
  const toCenter   = {x:tr.x+tr.w/2, y:tr.y+tr.h/2};
  let f=fromDotType, t=toDotType;
  if (!f || !t){
    const dx = toCenter.x - fromCenter.x, dy = toCenter.y - fromCenter.y;
    if (Math.abs(dx) > Math.abs(dy)){ f = dx>0?'output':'input'; t = dx>0?'input':'output'; }
    else { f = dy>0?'bottom':'top'; t = dy>0?'top':'bottom'; }
  }
  const fp = portCoords(fromTile, f), tp = portCoords(toTile, t);
  return { fromPort:{x:fp.x,y:fp.y,type:f}, toPort:{x:tp.x,y:tp.y,type:t} };
}
function getTileWorldRect(tile){ return { x:+tile.dataset.baseX||0, y:+tile.dataset.baseY||0, w:tile.offsetWidth, h:tile.offsetHeight }; }
function portCoords(tile, port){
  const r = getTileWorldRect(tile);
  switch(port){
    case 'input':  return { x:r.x, y:r.y+r.h/2 };
    case 'output': return { x:r.x+r.w, y:r.y+r.h/2 };
    case 'top':    return { x:r.x+r.w/2, y:r.y };
    case 'bottom': return { x:r.x+r.w/2, y:r.y+r.h };
    default:       return { x:r.x+r.w/2, y:r.y+r.h/2 };
  }
}

/* =========================
   Tiles
========================= */
function createTile(x=100,y=100,title='',content='',id=null,shape='rectangle',preset='custom',color='#ffffff'){
  const t=document.createElement('div');
  t.className = `tile ${shape}`;
  t.dataset.tileId = id || ('tile_'+Date.now()+'_'+Math.floor(Math.random()*1000));
  t.dataset.baseX = x; t.dataset.baseY = y;
  t.dataset.shape = shape; t.dataset.presetType = preset;
  t.style.left=x+'px'; t.style.top=y+'px'; t.style.width='200px'; t.style.height='120px'; t.style.backgroundColor=color;
  t.innerHTML = `
    <div class="shape-palette">
      <div class="shape-option" title="Rounded" data-shape="rounded">Round</div>
      <div class="shape-option" title="Circle" data-shape="circular">Circle</div>
      <div class="shape-option" title="Diamond" data-shape="diamond">Diamond</div>
      <div class="shape-option" title="Hex" data-shape="hexagon">Hex</div>
      <div class="shape-option" title="Triangle" data-shape="triangle">Triangle</div>
      <div class="shape-option" title="Parallelogram" data-shape="parallelogram">Para</div>
    </div>
    <!-- Color palette removed - now in toolbar -->
    <textarea class="tile-title" placeholder="Title">${title||''}</textarea>
    <textarea class="tile-content" placeholder="Content">${content||''}</textarea>
    <div class="connection-dot input"  data-port="input"></div>
    <div class="connection-dot output" data-port="output"></div>
    <div class="connection-dot top"    data-port="top"></div>
    <div class="connection-dot bottom" data-port="bottom"></div>
  `;
  t.querySelectorAll('.shape-option').forEach(el=>el.addEventListener('click',()=>setTileShape(t, el.dataset.shape)));
  t.querySelectorAll('textarea').forEach(inp=>inp.addEventListener('input', scheduleSave));
  t.addEventListener('click', ()=>selectTile(t));
  t.addEventListener('dblclick', (e)=>openTileToolbar(t, {x:e.clientX,y:e.clientY}));
  t.querySelectorAll('.connection-dot').forEach(el=>el.addEventListener('mousedown', (e)=>startConnectionFromPort(el,e)));
  return t;
}
function addTile(){
  const rect = canvas.getBoundingClientRect();
  openPresets(rect.left + rect.width/2, rect.top + rect.height/2);
}
function setTileShape(tile,shape){
  // Preserve text content before changing shape
  const title = tile.querySelector('.tile-title')?.value || '';
  const content = tile.querySelector('.tile-content')?.value || '';
  
  tile.className = 'tile '+shape;
  tile.dataset.shape = shape;
  
  // Restore text content after shape change
  if (title) tile.querySelector('.tile-title').value = title;
  if (content) tile.querySelector('.tile-content').value = content;
  
  markAsDirty();
  scheduleSave();
}
function setTileColor(tile,color){
  tile.style.backgroundColor = color;
  markAsDirty();
  scheduleSave();
}
function selectTile(tile){
  tiles.forEach(t=>t.classList.remove('selected'));
  tile.classList.add('selected');
  selectedTile = tile;
  selectedConnection = null;
  
  // Add resize handles
  addResizeHandles(tile);
  
  openTileToolbar(tile);
}
function clearSelection(){
  tiles.forEach(t=>{
    t.classList.remove('selected');
    // Remove resize handles
    t.querySelectorAll('.resize-handle').forEach(h => h.remove());
  });
  selectedTile=null; selectedConnection=null;
  hideFloatingToolbars();
  
  // Save when unselecting
  saveOnUnselect();
}
function duplicateTile(tile){
  const x = (+tile.dataset.baseX||0)+20, y=(+tile.dataset.baseY||0)+20;
  const t2 = createTile(x,y,
    tile.querySelector('.tile-title').value,
    tile.querySelector('.tile-content').value,
    null,
    tile.dataset.shape,
    tile.dataset.presetType,
    tile.style.backgroundColor || '#ffffff'
  );
  
  // Copy dimensions from original tile
  if (tile.style.width) t2.style.width = tile.style.width;
  if (tile.style.height) t2.style.height = tile.style.height;
  
  tiles.push(t2); renderCanvas(); scheduleSave(); notify('Duplicated');
}
function deleteSelected(){
  if (selectedConnection){ 
    deleteConnection(selectedConnection.id); 
    clearSelection();
    return; 
  }
  if (!selectedTile) return;
  const id = selectedTile.dataset.tileId;
  selectedTile.remove();
  tiles = tiles.filter(t=>t.dataset.tileId!==id);
  connections = connections.filter(c=>c.fromTile!==id && c.toTile!==id);
  addPendingUpdate('tile_delete', {tileId:id});
  markAsDirty(); 
  clearSelection(); 
  renderCanvas(); 
  notify('Tile deleted');
}

/* Floating toolbar for tile & connection */
const floatTB = document.createElement('div'); floatTB.className='floating-toolbar'; document.body.appendChild(floatTB);
function hideFloatingToolbars(){ floatTB.classList.remove('show'); }
function openTileToolbar(tile, at=null, force=false, focusSection=null){
  if (!tile && !force) return;
  
  // Close other menus first
  closeAllTileMenus();
  
  const toolbar = document.getElementById('tileToolbar');
  if (!toolbar) return;
  
  const pos = at || { 
    x: (tile.getBoundingClientRect().left + tile.getBoundingClientRect().right) / 2,
    y: tile.getBoundingClientRect().top - 50 // Position farther from tile
  };
  
  toolbar.innerHTML = `
    <div class="toolbar-section">
      <div class="toolbar-section-title">Tile Actions</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="duplicateTile()" title="Duplicate">Copy</button>
        <button class="toolbar-button" onclick="deleteSelected()" title="Delete">Delete</button>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Shape</div>
      <div class="toolbar-dropdown">
        <button class="toolbar-dropdown-btn" onclick="toggleShapeDropdown()">${shapeIcon(tile?.dataset.shape || 'rectangle')} Shape ▼</button>
        <div class="toolbar-dropdown-content" id="shapeDropdown">
          ${['rectangle','rounded','circular','diamond','hexagon','triangle','parallelogram']
            .map(s=>`<div class="dropdown-item ${tile?.dataset.shape===s?'active':''}" onclick="changeTileShape('${s}')" data-shape="${s}">${shapeIcon(s)} ${s.charAt(0).toUpperCase() + s.slice(1)}</div>`).join('')}
        </div>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Color</div>
      <div class="toolbar-row color-options">
        ${['#ffffff','#fef3c7','#fde68a','#fca5a5','#c7d2fe','#bae6fd','#bbf7d0','#e9d5ff','#fecaca','#d1fae5']
          .map(c=>`<div class="color-option ${tile.style.backgroundColor===c?'selected':''}" onclick="setTileColor(selectedTile,'${c}')" style="background:${c}" title="Set color"></div>`).join('')}
      </div>
    </div>
  `;
  
  // Position the toolbar
  toolbar.style.left = pos.x + 'px';
  toolbar.style.top = pos.y + 'px';
  toolbar.classList.add('show');
  
  // Store reference to tile for color changes
  toolbar.dataset.tileId = tile.dataset.tileId;
}
function openConnectionToolbar(conn, at){
  selectedConnection = conn;
  
  const toolbar = document.getElementById('connectionToolbar');
  if (!toolbar) return;
  
  toolbar.innerHTML = `
    <div class="toolbar-section">
      <div class="toolbar-section-title">Connection</div>
      <div class="toolbar-row">
        <div class="toolbar-color" id="connColorPick" title="Color"></div>
        <button class="toolbar-button" onclick="changeLineStyle('solid')" title="Solid">—</button>
        <button class="toolbar-button" onclick="changeLineStyle('dashed')" title="Dashed">- -</button>
        <button class="toolbar-button" onclick="changeLineStyle('dotted')" title="Dotted">⋯</button>
        <button class="toolbar-button" onclick="changeLineStyle('dash-dot')" title="Dash-dot">-⋅-</button>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Head</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="changeConnectionMarker('arrow')" title="Arrow">➤</button>
        <button class="toolbar-button" onclick="changeConnectionMarker('line')" title="Line">—</button>
        <button class="toolbar-button" onclick="changeConnectionMarker('dot')" title="Dot">•</button>
        <button class="toolbar-button" onclick="changeConnectionMarker('diamond')" title="Diamond">Diamond</button>
        <button class="toolbar-button" onclick="deleteSelectedConnection()" title="Delete">Delete</button>
      </div>
    </div>
  `;
  
  // Position the toolbar
  toolbar.style.left = at.x + 'px';
  toolbar.style.top = at.y + 'px';
  toolbar.classList.add('show');
  
  // Add color picker functionality
  const colorBtn = toolbar.querySelector('#connColorPick');
  if (colorBtn) {
    colorBtn.onclick = () => openColorPopup(colorBtn, (c) => {
      conn.color = c;
      scheduleSave();
      renderCanvas();
    });
  }
}
function shapeIcon(s){ return ({rectangle:'Rect', rounded:'Round', circular:'Circle', diamond:'Diamond', hexagon:'Hex', triangle:'Triangle', parallelogram:'Para'})[s]||'Rect'; }

/* Color popup (secondary) */
function openColorPopup(anchorEl, onPick){
  const pop = document.createElement('div');
  pop.className='preset-popup'; // reuse styling
  pop.style.left = (anchorEl.getBoundingClientRect().left)+'px';
  pop.style.top  = (anchorEl.getBoundingClientRect().bottom+6)+'px';
  pop.innerHTML = `
    <div style="display:grid;grid-template-columns:repeat(10,1fr);gap:6px;">
      ${['#ffffff','#f8fafc','#e2e8f0','#cbd5e0','#94a3b8','#fef3c7','#fde68a','#fca5a5','#fda4af','#fbbf24','#86efac','#10b981','#93c5fd','#60a5fa','#a78bfa','#f472b6','#22d3ee','#f59e0b','#ef4444','#3b82f6']
       .map(c=>`<div style="width:22px;height:22px;border-radius:6px;border:1px solid var(--border-primary);background:${c};cursor:pointer" data-c="${c}"></div>`).join('')}
    </div>`;
  document.body.appendChild(pop);
  pop.classList.add('show');
  pop.querySelectorAll('[data-c]').forEach(el=>el.onclick=()=>{ onPick(el.dataset.c); document.body.removeChild(pop); });
  const close = (ev)=>{ if (!pop.contains(ev.target)){ document.body.removeChild(pop); document.removeEventListener('mousedown', close); } };
  setTimeout(()=>document.addEventListener('mousedown', close), 0);
}

/* =========================
   Presets / Templates
========================= */
function openPresets(cx=null, cy=null){
  // Use the existing preset tile modal instead of the missing presetPopup
  const modal = document.getElementById('presetTileModal');
  if (!modal) return;
  
  // Position the modal in the center of the screen
  modal.style.display = 'flex';
  modal.classList.add('show');
  
  // Set up click handlers for preset tiles
  const presetTiles = modal.querySelectorAll('.preset-tile');
  presetTiles.forEach(tile => {
    tile.onclick = () => {
      const type = tile.classList.contains('title') ? 'title' :
                   tile.classList.contains('notes') ? 'notes' :
                   tile.classList.contains('component') ? 'component' : 'custom';
      
      // Calculate center position for the new tile
      const r = canvas.getBoundingClientRect();
      const centerX = cx || (r.left + r.width / 2);
      const centerY = cy || (r.top + r.height / 2);
      
      // Convert screen coordinates to world coordinates
      const worldX = (centerX - r.left - canvasOffset.x) / zoom;
      const worldY = (centerY - r.top - canvasOffset.y) / zoom;
      
      addPresetTile(type, worldX, worldY);
      
      // Close the modal after creating the tile
      modal.classList.remove('show');
      modal.style.display = 'none';
      
      // Hide any floating toolbars
      hideFloatingToolbars();
    };
  });
  
  // Add click outside to close functionality
  modal.onclick = (e) => {
    if (e.target === modal) {
      modal.classList.remove('show');
      modal.style.display = 'none';
    }
  };
}
function addPresetTile(type, x, y){
  const presets = {
    title:     { title:'Title', content:'', shape:'rounded', color:'#ffffff' },
    notes:     { title:'Note', content:'Type your note…', shape:'rectangle', color:'#fff7ed' },
    component: { title:'Component', content:'• Input\n• Process\n• Output', shape:'hexagon', color:'#e0f2fe' },
    custom:    { title:'New tile', content:'', shape:'rectangle', color:'#ffffff' }
  };
  const p = presets[type] || presets.custom;
  const t = createTile(x,y,p.title,p.content,null,p.shape,type,p.color);
  tiles.push(t); renderCanvas(); scheduleSave(); notify(`${type[0].toUpperCase()+type.slice(1)} tile added`);
}

/* =========================
   Rendering / Connections
========================= */
function renderCanvas(){
  canvasContent.innerHTML='';
  // grid overlay (scaled with content)
  let gridOverlay = document.getElementById('grid-overlay');
  if (gridOverlay) canvasContent.appendChild(gridOverlay);
  // tiles
  tiles.forEach(t=>{
    const x=+t.dataset.baseX||0, y=+t.dataset.baseY||0;
    t.style.left = x+'px'; t.style.top = y+'px';
    canvasContent.appendChild(t);
  });
  renderConnections();
}
function createConnectionSVG(fromX, fromY, toX, toY, isPreview=false, connObj=null){
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.style.position='absolute'; svg.style.left='0'; svg.style.top='0'; svg.style.width='100%'; svg.style.height='100%';
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  const d = createSmartPath(fromX, fromY, toX, toY);
  path.setAttribute('d', d);
  path.setAttribute('fill','none');
  const color = connObj?.color || (isPreview?'#999':'var(--accent-primary)');
  path.setAttribute('stroke', color);
  path.setAttribute('stroke-width', isPreview?'2':'3');
  if (!isPreview){
    const marker = connObj?.marker || 'arrow';
    path.setAttribute('marker-end', marker==='line' ? '' : `url(#${marker==='dot'?'dotmarker':marker==='diamond'?'diamondmarker':'arrowhead'})`);
    const style = connObj?.style || 'solid';
    const dash = {solid:'',dashed:'5,5',dotted:'2,2', 'dash-dot':'10,2,2,2'}[style] || '';
    if (dash) path.setAttribute('stroke-dasharray', dash);
    path.classList.add('connection-line');
    path.addEventListener('click', (e)=>{
      e.stopPropagation();
      selectedConnection = connObj;
      openConnectionToolbar(connObj, {x:e.clientX, y:e.clientY});
    });
    path.addEventListener('dblclick', (e)=>{ e.stopPropagation(); deleteConnection(connObj.id); });
  }
  svg.appendChild(path);
  return svg;
}
function renderConnections(){
  let svg = document.getElementById('connections-svg-live');
  if (!svg){
    svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.id='connections-svg-live';
    svg.style.position='absolute'; svg.style.left='0'; svg.style.top='0'; svg.style.width='100%'; svg.style.height='100%'; svg.style.zIndex='5';
    canvasContent.appendChild(svg);
  }
  // clear previous
  while (svg.firstChild) svg.removeChild(svg.firstChild);
  // draw
  const groups = {};
  connections.forEach(c=>{ const k=`${c.fromTile}__${c.toTile}`; (groups[k] ||= []).push(c); });
  Object.values(groups).forEach(group=>{
    group.forEach((conn, idx)=>{
      const fromTile = tiles.find(t=>t.dataset.tileId===conn.fromTile);
      const toTile   = tiles.find(t=>t.dataset.tileId===conn.toTile);
      if (!fromTile || !toTile) return;
      const {fromPort,toPort} = findOptimalPort(fromTile,toTile,conn.fromDot,conn.toDot);
      // screen coords
      const s1 = worldToScreen(fromPort.x, fromPort.y);
      const s2 = worldToScreen(toPort.x, toPort.y);
      // offset for parallel lines
      const dx = s2.x - s1.x, dy = s2.y - s1.y, len = Math.max(1, Math.hypot(dx,dy));
      const ox = (-dy/len) * (idx? (idx-0.5)*8 : 0), oy = (dx/len) * (idx? (idx-0.5)*8 : 0);
      const path = createConnectionSVG(s1.x+ox, s1.y+oy, s2.x+ox, s2.y+oy, false, conn);
      svg.appendChild(path.firstChild);
    });
  });
}
function createSmartPath(fromX,fromY,toX,toY){
  // Create S-shaped path with 90-degree angles and rounded bends
  const halfTileWidth = 100; // Half of typical tile width
  const halfTileHeight = 60; // Half of typical tile height
  
  const dx = Math.abs(toX - fromX);
  const dy = Math.abs(toY - fromY);
  
  let path = `M ${fromX} ${fromY}`;
  
  if (dx > dy) {
    // More horizontal than vertical - S-shape with horizontal first
    const midX1 = fromX + (toX > fromX ? halfTileWidth : -halfTileWidth);
    const midX2 = toX + (toX > fromX ? -halfTileWidth : halfTileWidth);
    const midY = fromY + (toY - fromY) / 2;
    
    path += ` L ${midX1} ${fromY}`;
    path += ` L ${midX1} ${midY}`;
    path += ` L ${midX2} ${midY}`;
    path += ` L ${midX2} ${toY}`;
    path += ` L ${toX} ${toY}`;
  } else {
    // More vertical than horizontal - S-shape with vertical first
    const midY1 = fromY + (toY > fromY ? halfTileHeight : -halfTileHeight);
    const midY2 = toY + (toY > fromY ? -halfTileHeight : halfTileHeight);
    const midX = fromX + (toX - fromX) / 2;
    
    path += ` L ${fromX} ${midY1}`;
    path += ` L ${midX} ${midY1}`;
    path += ` L ${midX} ${midY2}`;
    path += ` L ${toX} ${midY2}`;
    path += ` L ${toX} ${toY}`;
  }
  
  return path;
}
function deleteConnection(id){
  const i = connections.findIndex(c=>c.id===id);
  if (i>-1){ connections.splice(i,1); addPendingUpdate('connection_delete',{connectionId:id}); markAsDirty(); renderCanvas(); notify('Connection deleted'); }
}

/* =========================
   Tabs / Graphs
========================= */
function createTab(graph){
  const tab = document.createElement('div');
  tab.className='tab'; tab.dataset.graphId = graph.id;
  tab.innerHTML = `${graph.title||'Untitled'} <button class="tab-close" title="Close tab">×</button>`;
  tab.addEventListener('click', (e)=>{ if (!e.target.classList.contains('tab-close')) switchToTab(graph.id); });
  tab.querySelector('.tab-close').addEventListener('click', (e)=>{ e.stopPropagation(); closeTab(graph.id); });
  openTabs.push({id:graph.id, element:tab, graph});
  tabContainer.appendChild(tab);
  return tab;
}
function closeTab(id){
  const i=openTabs.findIndex(t=>t.id===id); if (i===-1) return;
  openTabs[i].element.remove(); openTabs.splice(i,1);
  if (activeTabId===id){ if (openTabs.length) switchToTab(openTabs[0].id); else { activeTabId=null; currentGraph=null; tiles=[]; connections=[]; renderCanvas(); document.getElementById('shareSection').style.display='none'; } }
}
function switchToTab(id){
  const tab=openTabs.find(t=>t.id===id); if (!tab) return;
  openTabs.forEach(t=>t.element.classList.remove('active')); tab.element.classList.add('active');
  activeTabId=id; loadGraph(tab.graph, true); centerCanvas();
}
async function loadGraphs(){
  const token = localStorage.getItem('flowpad_token');
  const res = await fetch('/api/graphs',{ headers:{Authorization:`Bearer ${token}`} }).catch(()=>null);
  if (!res || !res.ok){ // No demo graph creation
    console.log('Failed to load graphs from server');
    return;
  }
  const data = await res.json();
  renderGraphList(data.filter(g=>g.type==='own'), 'ownGraphs');
  renderGraphList(data.filter(g=>g.type==='shared'), 'sharedGraphs');
}
function renderGraphList(list, target){
  const container = (target==='sharedGraphs' ? document.getElementById('sharedGraphsContent') : document.getElementById(target));
  container.innerHTML='';
  list.forEach(g=>{
    const item=document.createElement('div');
    item.className='graph-item'; item.dataset.graphId=g.id;
    item.draggable = true;
    item.innerHTML=`<div class="graph-title">${g.title}</div>
                    <div class="graph-meta">Updated: ${new Date(g.updated_at||Date.now()).toLocaleString()}</div>
                    <button class="graph-delete" onclick="deleteGraph('${g.id}')" title="Delete graph">×</button>`;
    
    // Click to load graph
    item.addEventListener('click', (e)=>{ if (!e.target.classList.contains('graph-delete')) loadGraph(g); });
    
    // Drag and drop functionality
    item.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', g.id);
      e.dataTransfer.setData('application/json', JSON.stringify(g));
      item.classList.add('dragging');
    });
    
    item.addEventListener('dragend', () => {
      item.classList.remove('dragging');
    });
    
    container.appendChild(item);
  });
}
function loadGraph(graph, skipTab=false){
  tiles=[]; connections=[]; canvasContent.innerHTML='';
  currentGraph = graph;
  (graph.data?.tiles||[]).forEach(t=>{
    const tile = createTile(t.x,t.y,t.title,t.content,t.id,t.shape||'rectangle',t.preset||'custom',t.color||'#ffffff');
    
    // Set custom dimensions if they exist in the saved data
    if (t.width) tile.style.width = t.width + 'px';
    if (t.height) tile.style.height = t.height + 'px';
    
    tiles.push(tile);
  });
  connections = graph.data?.connections || [];
  if (!openTabs.find(t=>t.id===graph.id)) createTab(graph);
  if (!skipTab) switchToTab(graph.id);
  document.getElementById('shareSection').style.display='block';
  renderCanvas(); isDirty=false; updateTileColorsForTheme(document.documentElement.getAttribute('data-theme'));
  pushHistory(true);
}
function deleteGraph(id){
  if (!confirm('Delete this graph?')) return;
  fetch(`/api/graphs/${id}`,{method:'DELETE', headers:{Authorization:`Bearer ${localStorage.getItem('flowpad_token')}`}})
    .then(r=>{ if (!r.ok) throw new Error(); notify('Deleted'); loadGraphs(); if (currentGraph?.id===id){ currentGraph=null; tiles=[]; connections=[]; renderCanvas(); }})
    .catch(()=>notify('Failed to delete','error'));
}
async function createNewGraph(){
  const modal = document.getElementById('newGraphModal');
  const input = document.getElementById('newGraphTitle');
  input.value=''; modal.classList.add('show'); input.focus();
  input.onkeydown = (e)=>{ if (e.key==='Enter') confirmNewGraph(); else if (e.key==='Escape') closeNewGraphModal(); };
  modal.onclick = (e)=>{ if (e.target===modal) closeNewGraphModal(); };
}
function closeNewGraphModal(){ document.getElementById('newGraphModal').classList.remove('show'); }
async function confirmNewGraph(){
  const title = document.getElementById('newGraphTitle').value.trim() || 'Untitled';
  const token = localStorage.getItem('flowpad_token');
  const res = await fetch('/api/graphs',{
    method:'POST',
    headers:{'Content-Type':'application/json', Authorization:`Bearer ${token}`},
    body: JSON.stringify({ title, data:{ tiles:[], connections:[] } })
  }).catch(()=>null);
  if (res && res.ok){
    const g = await res.json(); await loadGraphs(); loadGraph(g); closeNewGraphModal(); notify('Graph created');
  }else{
    // local fallback
    const g = { id:'local_'+Date.now(), title, updated_at:Date.now(), data:{ tiles:[], connections:[] }, type:'own' };
    renderGraphList([g], 'ownGraphs'); loadGraph(g); closeNewGraphModal(); notify('Graph created (local)');
  }
}

/* =========================
   Inbox / Sharing / Presence
========================= */
async function loadInbox(){
  const token = localStorage.getItem('flowpad_token');
  const res = await fetch('/api/graphs/inbox', { headers:{Authorization:`Bearer ${token}`} }).catch(()=>null);
  if (res && res.ok) renderInbox(await res.json());
  else document.getElementById('inboxContent').innerHTML = '<div style="text-align:center;color:var(--text-secondary);padding:20px;">No pending invitations</div>';
}
function renderInbox(items){
  const container=document.getElementById('inboxContent'); container.innerHTML='';
  if (!items?.length){
    container.innerHTML='<div style="text-align:center;color:var(--text-secondary);padding:20px;">No pending invitations</div>'; return;
  }
  items.forEach(it=>{
    const el=document.createElement('div');
    el.className=`inbox-item ${it.status||'pending'}`;
    el.innerHTML=`<div class="inbox-title">${it.graphTitle}</div>
      <div class="inbox-meta">From: ${it.sharerName} • ${new Date(it.sharedAt).toLocaleString()}</div>
      ${it.status==='pending'?`<div class="inbox-actions">
        <button class="inbox-btn accept" onclick="respondToInvitation('${it.id}','accept')">Accept</button>
        <button class="inbox-btn reject" onclick="respondToInvitation('${it.id}','reject')">Reject</button></div>`:''}`;
    container.appendChild(el);
  });
}
async function respondToInvitation(id, action){
  const res = await fetch(`/api/graphs/inbox/${id}/${action}`, {method:'POST', headers:{Authorization:`Bearer ${localStorage.getItem('flowpad_token')}`}}).catch(()=>null);
  if (res && res.ok){ notify(`Invitation ${action}ed`); loadInbox(); if(action==='accept') loadGraphs(); }
  else notify(`Failed to ${action} invitation`,'error');
}
function shareGraph(){
  if (!currentGraph) return;
  
  // Prevent sharing local graphs
  if (currentGraph.id && (currentGraph.id.toString().startsWith('local_') || currentGraph.id.toString().startsWith('demo-'))) {
    notify('Cannot share local graphs. Please save to server first.', 'error');
    return;
  }
  
  const email = document.getElementById('shareEmail').value.trim();
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return notify('Invalid email','error');
  fetch(`/api/graphs/${currentGraph.id}/share`,{
    method:'POST',
    headers:{'Content-Type':'application/json', Authorization:`Bearer ${localStorage.getItem('flowpad_token')}`},
    body: JSON.stringify({ email })
  }).then(r=>{ notify(r.ok?'Shared':'Share failed', r.ok?'success':'error'); if (r.ok) document.getElementById('shareEmail').value=''; })
  .catch(()=>notify('Share failed','error'));
}
function addShareEmailListener(){
  const el=document.getElementById('shareEmail'); if (!el) return;
  el.addEventListener('input', ()=>{/* button enabled by HTML5 pattern; noop */});
}
function initializePermissionSelector(){
  document.querySelectorAll('.permission-option').forEach(opt=>{
    opt.addEventListener('click', ()=>{
      document.querySelectorAll('.permission-option').forEach(o=>o.classList.remove('selected'));
      opt.classList.add('selected');
      const input = opt.querySelector('input[type="radio"]'); if (input) input.checked=true;
    });
  });
}
function loadCollaborators(){
  // Prevent loading collaborators for local graphs
  if (currentGraph?.id && (currentGraph.id.toString().startsWith('local_') || currentGraph.id.toString().startsWith('demo-'))) {
    showCollaborators([]);
    return;
  }
  
  // Try API; else demo presence
  fetch(`/api/graphs/${currentGraph?.id||'none'}/collaborators`, { headers:{Authorization:`Bearer ${localStorage.getItem('flowpad_token')}`} })
    .then(r=>r.ok?r.json():Promise.reject())
    .then(showCollaborators)
    .catch(()=>showCollaborators([{email:'alex@example.com',name:'Alex',status:'online'},{email:'sam@example.com',name:'Sam',status:'away'}]));
}
function showCollaborators(list){
  const wrap = document.getElementById('collaboratorsList');
  const cnt = document.getElementById('collaboratorsContent');
  document.getElementById('collaboratorsCount').textContent = list.length;
  cnt.innerHTML='';
  list.forEach(u=>{
    const item=document.createElement('div'); item.className='collaborator-item';
    item.innerHTML=`<div class="collaborator-avatar">${(u.name||u.email||'?').slice(0,2).toUpperCase()}</div>
      <div class="collaborator-name">${u.name||u.email}</div>
      <div class="collaborator-status ${u.status==='online'?'status-online':u.status==='away'?'status-away':'status-offline'}"></div>`;
    cnt.appendChild(item);
  });
  wrap.classList.add('show');
}
function addCacheStatusButton(){
  // Updates cache/sync status and online/offline
  window.addEventListener('online', ()=>notify('Online','success'));
  window.addEventListener('offline', ()=>notify('Offline','warn'));
}
function showCacheStatus(){
  const status = navigator.onLine ? 'Online' : 'Offline';
  const queued = pendingUpdates.length;
  notify(`Status: <b>${status}</b><div class="small">Pending updates: ${queued}</div>`, navigator.onLine ? 'success' : 'warn', 2500);
}

/* =========================
   Import / Export / Versioning
========================= */
function serializeGraph(){
  return {
    tiles: tiles.map(t=>({
      id:t.dataset.tileId, x:+t.dataset.baseX||0, y:+t.dataset.baseY||0,
      title:t.querySelector('.tile-title').value||'',
      content:t.querySelector('.tile-content').value||'',
      color:t.style.backgroundColor || '#ffffff',
      shape:t.dataset.shape||'rectangle',
      preset:t.dataset.presetType||'custom',
      width:parseInt(t.style.width) || 200,
      height:parseInt(t.style.height) || 120
    })),
    connections:[...connections]
  };
}
function exportJSON(){
  const data = serializeGraph();
  const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=(currentGraph?.title||'diagram')+'.json'; a.click();
  URL.revokeObjectURL(url); notify('Exported JSON');
}
// Import file event listener will be set up in init function

/* Undo / Redo */
function pushHistory(init=false){
  const snapshot = JSON.stringify(serializeGraph());
  if (init || !historyStack.length || historyStack[historyStack.length-1]!==snapshot){
    historyStack.push(snapshot); if (!init) futureStack = []; // clear redo
  }
}
function undo(){
  if (historyStack.length<=1) return;
  const cur = historyStack.pop();
  futureStack.push(cur);
  const prev = JSON.parse(historyStack[historyStack.length-1]);
  restoreFrom(prev);
}
function redo(){
  if (!futureStack.length) return;
  const next = JSON.parse(futureStack.pop());
  historyStack.push(JSON.stringify(next));
  restoreFrom(next);
}
function restoreFrom(d){
  tiles=[]; connections=[];
  (d.tiles||[]).forEach(t=>{
    const tile = createTile(t.x,t.y,t.title,t.content,t.id,t.shape||'rectangle',t.preset||'custom',t.color||'#ffffff');
    
    // Restore custom dimensions if they exist
    if (t.width) tile.style.width = t.width + 'px';
    if (t.height) tile.style.height = t.height + 'px';
    
    tiles.push(tile);
  });
  connections=d.connections||[];
  renderCanvas();
}

/* =========================
   Keyboard Shortcuts
========================= */
function setupKeyboardShortcuts(){
  document.addEventListener('keydown', (e)=>{
    if (e.ctrlKey && e.key.toLowerCase()==='s'){ e.preventDefault(); forceSave(); }
    else if (e.ctrlKey && e.key.toLowerCase()==='e'){ e.preventDefault(); exportJSON(); }
    else if (e.ctrlKey && e.key.toLowerCase()==='i'){ e.preventDefault(); document.getElementById('importFile').click(); }
    else if (e.ctrlKey && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
    else if (e.ctrlKey && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); }
    else if (e.key==='Delete' || e.key==='Backspace'){ if (selectedTile || selectedConnection){ e.preventDefault(); deleteSelected(); } }
    else if (e.key.toLowerCase()==='n' && !e.target.matches('input, textarea, [contenteditable]')){ addTile(); }
    else if (e.key.toLowerCase()==='p'){ openPresets(); }
    else if (e.key.toLowerCase()==='g'){ toggleGrid(); }
    else if (e.key.toLowerCase()==='t'){ toggleSnapTiles(document.querySelector('.snap-tiles-btn')); }
    else if (e.key==='+'){ zoomIn(); }
    else if (e.key==='-'){ zoomOut(); }
    else if (e.key==='0'){ zoomReset(); }
    else if (e.shiftKey && e.key.toLowerCase()==='g'){ toggleSnapGrid(document.querySelector('.snap-grid-btn')); }
  });
}
function toggleSnapGrid(btn){ snapToGrid = !snapToGrid; btn?.classList.toggle('active', snapToGrid); notify(`Snap to grid ${snapToGrid?'ON':'OFF'}`); }
function toggleSnapTiles(btn){ snapToTiles = !snapToTiles; btn?.classList.toggle('active', snapToTiles); notify(`Snap to tiles ${snapToTiles?'ON':'OFF'}`); }

/* =========================
   Auth / User
========================= */
async function checkAuth(){
  const token = localStorage.getItem('flowpad_token');
  const user = localStorage.getItem('flowpad_user');
  currentUser = user ? JSON.parse(user) : { name:'User' };
  document.getElementById('userName').textContent = currentUser.name || 'User';
  if (!token) return; // continue in demo mode if no token
  const ok = await fetch('/api/graphs', { headers:{Authorization:`Bearer ${token}`} }).then(r=>r.ok).catch(()=>false);
  if (!ok){ /* optionally redirect */ }
}
function signOut(){ localStorage.clear(); window.location.reload(); }

/* =========================
   AI Suggestions (optional backend)
========================= */
function toggleAIPanel(){ document.getElementById('aiPanel').classList.toggle('show'); }
async function getAISuggestions(){
  if (!currentGraph || !selectedTile) return notify('Select a tile first','error');
  const input = document.getElementById('aiInput').value.trim(); if (!input) return notify('Type a prompt','error');
  const btn = document.getElementById('aiBtn'), text = document.getElementById('aiBtnText'); btn.disabled=true; text.innerHTML='<span class="loading"></span>Working...';
  try{
    const token = localStorage.getItem('flowpad_token');
    const response = await fetch('/api/ai-suggestions',{
      method:'POST',
      headers:{'Content-Type':'application/json','Authorization':`Bearer ${token}`},
      body: JSON.stringify({
        prompt: input,
        targetTile:{ id:selectedTile.dataset.tileId, content:selectedTile.querySelector('.tile-content').value },
        existingTiles: tiles.map(t=>({ id:t.dataset.tileId, content:t.querySelector('.tile-content').value })),
        connections
      })
    });
    const data = response.ok ? await response.json() : { suggestions:[`• Related item to "${input}"`,`• Another thought`,`• Edge case`] };
    displayAISuggestions(data);
  }catch{ notify('AI call failed','error'); }
  finally{ btn.disabled=false; text.textContent='Get Suggestions'; }
}
function displayAISuggestions(s){
  const c=document.getElementById('aiSuggestions'); c.innerHTML='';
  const arr = Array.isArray(s?.suggestions)?s.suggestions:Array.isArray(s)?s:[s.text||s.content||s.description||'No suggestions'];
  arr.forEach(v=>{
    const d=document.createElement('div'); d.className='ai-suggestion'; d.textContent = typeof v==='string'?v:JSON.stringify(v);
    d.onclick=()=>{ if(!selectedTile) return; selectedTile.querySelector('.tile-content').value=(typeof v==='string'?v:JSON.stringify(v)); scheduleSave(); notify('Applied'); };
    c.appendChild(d);
  });
}

/* =========================
   Utilities / Demo
========================= */
// function demoTemplateGraph(){
//   const g = { id:'demo-1', title:'Demo Diagram', updated_at:Date.now(), type:'own',
//     data:{ tiles:[
//       { id:'a', x:120,y:140, title:'Input', content:'Incoming data', color:'#e0f2fe', shape:'rounded', preset:'component' },
//       { id:'b', x:380,y:140, title:'Process', content:'Transform', color:'#fff7ed', shape:'hexagon', preset:'component' },
//       { id:'c', x:640,y:140, title:'Output', content:'Result', color:'#e9d5ff', shape:'rounded', preset:'component' }
//     ], connections:[
//       { id:'ab', fromTile:'a',toTile:'b',fromDot:'output',toDot:'input',color:'#3b82f6',style:'solid',marker:'arrow' },
//       { id:'bc', fromTile:'b',toTile:'c',fromDot:'output',toDot:'input',color:'#10b981',style:'dashed',marker:'dot' }
//     ] }};
//   return g;
// }

// ------------ Stubs (safe no-ops) ------------
function loadCollaborators() {
  if (!currentGraph || !currentGraph.sharedUsers) return;
  
  const container = document.getElementById('collaboratorsContent');
  const countEl = document.getElementById('collaboratorsCount');
  
  if (!container || !countEl) return;
  
  countEl.textContent = currentGraph.sharedUsers.length;
  container.innerHTML = '';
  
  currentGraph.sharedUsers.forEach(user => {
    const item = document.createElement('div');
    item.className = 'collaborator-item';
    item.innerHTML = `
      <div class="collaborator-avatar">${user.name.charAt(0).toUpperCase()}</div>
      <div class="collaborator-name">${user.name}</div>
      <div class="collaborator-status ${user.status || 'online'}"></div>
    `;
    container.appendChild(item);
  });
  
  document.getElementById('collaboratorsList').classList.add('show');
}

function addCacheStatusButton() {
  // This function is now handled by the toolbar buttons
  // The cache status functionality is implemented in showCacheStatus()
}

// ------------ New Functions for Complete Functionality ------------

// Preset Tile System
function showPresetTileSelector() {
  const modal = document.getElementById('presetTileModal');
  modal.classList.add('show');
  modal.onclick = (e) => { if (e.target === modal) closePresetTileModal(); };
}

function closePresetTileModal() {
  document.getElementById('presetTileModal').classList.remove('show');
}

function createPresetTile(presetType) {
  const canvasRect = canvas.getBoundingClientRect();
  const centerX = canvasRect.width / 2;
  const centerY = canvasRect.height / 2;
  const x = Math.max(20, Math.round(centerX - 90));
  const y = Math.max(20, Math.round(centerY - 60));
  
  let title = '', content = '', shape = 'rectangle';
  
  switch(presetType) {
    case 'title':
      title = 'Title';
      content = ''; // Title tiles don't have mini text
      shape = 'rounded';
      break;
    case 'notes':
      title = ''; // Notes don't have a title
      content = 'Enter your notes here';
      shape = 'rectangle';
      break;
    case 'component':
      title = 'Component';
      content = 'Component description';
      shape = 'hexagon';
      break;
    case 'custom':
      title = 'Custom';
      content = 'Enter custom content';
      shape = 'rectangle';
      break;
  }
  
  const tile = createTile(x, y, title, content, null, shape, presetType);
  
  // Hide title field for notes, hide content field for titles
  if (presetType === 'notes') {
    const titleField = tile.querySelector('.tile-title');
    if (titleField) titleField.style.display = 'none';
  } else if (presetType === 'title') {
    const contentField = tile.querySelector('.tile-content');
    if (contentField) contentField.style.display = 'none';
  }
  
  tiles.push(tile);
  renderCanvas();
  scheduleSave();
  closePresetTileModal();
  notify(`${presetType.charAt(0).toUpperCase() + presetType.slice(1)} tile added`, 'success');
}

// Snap to Grid/Tiles Toggle
function toggleSnapToGrid() {
  snapToGrid = !snapToGrid;
  const btn = document.querySelector('.snap-grid-btn');
  btn.classList.toggle('active', snapToGrid);
  btn.title = snapToGrid ? 'Snap to Grid (ON)' : 'Snap to Grid (OFF)';
  notify(`Snap to Grid: ${snapToGrid ? 'ON' : 'OFF'}`, 'success');
}

function toggleSnapToTiles() {
  snapToTiles = !snapToTiles;
  const btn = document.querySelector('.snap-tiles-btn');
  btn.classList.toggle('active', snapToTiles);
  btn.title = snapToTiles ? 'Snap to Tiles (ON)' : 'Snap to Tiles (OFF)';
  notify(`Snap to Tiles: ${snapToTiles ? 'ON' : 'OFF'}`, 'success');
}

// Force Save
async function forceSave() {
  if (!currentGraph) return notify('No graph to save', 'error');
  await autoSaveGraph();
  notify('Force save completed', 'success');
}

// Cache Status
function showCacheStatus() {
  const modal = document.getElementById('cacheStatusModal');
  updateCacheStatusDisplay();
  modal.classList.add('show');
  modal.onclick = (e) => { if (e.target === modal) closeCacheStatusModal(); };
}

function closeCacheStatusModal() {
  document.getElementById('cacheStatusModal').classList.remove('show');
}

function updateCacheStatusDisplay() {
  const lastSaveEl = document.getElementById('lastSaveTime');
  const autoSaveEl = document.getElementById('autoSaveStatus');
  const pendingEl = document.getElementById('pendingUpdatesCount');
  const connectionEl = document.getElementById('connectionStatus');

  if (lastSaveEl) {
    lastSaveEl.textContent = lastSaveTime ? new Date(lastSaveTime).toLocaleTimeString() : 'Never';
  }
  if (autoSaveEl) {
    autoSaveEl.textContent = autoSaveTimer ? 'Enabled' : 'Disabled';
  }
  if (pendingEl) {
    pendingEl.textContent = pendingUpdates.length;
  }
  if (connectionEl) {
    connectionEl.textContent = navigator.onLine ? 'Online' : 'Offline';
    connectionEl.style.color = navigator.onLine ? 'var(--inbox-accepted)' : 'var(--inbox-rejected)';
  }
}

// Floating Toolbar for Tiles
function showTileToolbar(tile, event) {
  const toolbar = document.getElementById('tileToolbar');
  const rect = tile.getBoundingClientRect();
  const canvasRect = canvas.getBoundingClientRect();
  
  toolbar.style.left = (rect.left - canvasRect.left + rect.width / 2) + 'px';
  toolbar.style.top = (rect.top - canvasRect.top - 10) + 'px';
  toolbar.classList.add('show');
  
  // Update color picker
  const colorPicker = toolbar.querySelector('.toolbar-color-picker');
  if (colorPicker) {
    const color = tile.style.backgroundColor || '#ffffff';
    colorPicker.style.setProperty('--tile-color', color);
  }
}

function hideTileToolbar() {
  document.getElementById('tileToolbar').classList.remove('show');
}

// Tile Operations
function duplicateTile() {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  const rect = selectedTile.getBoundingClientRect();
  const canvasRect = canvas.getBoundingClientRect();
  const x = rect.left - canvasRect.left + 20;
  const y = rect.top - canvasRect.top + 20;
  
  const title = selectedTile.querySelector('.tile-title').value;
  const content = selectedTile.querySelector('.tile-content').value;
  const shape = selectedTile.dataset.shape || 'rectangle';
  const color = selectedTile.style.backgroundColor || '#ffffff';
  
  const newTile = createTile(x, y, title, content, null, shape);
  newTile.style.backgroundColor = color;
  tiles.push(newTile);
  
  renderCanvas();
  scheduleSave();
  notify('Tile duplicated', 'success');
}

function bringToFront() {
  if (!selectedTile) return notify('No tile selected', 'error');
  selectedTile.style.zIndex = '1000';
  notify('Tile brought to front', 'success');
}

function sendToBack() {
  if (!selectedTile) return notify('No tile selected', 'error');
  selectedTile.style.zIndex = '1';
  notify('Tile sent to back', 'success');
}

function changeTileShape(shape) {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  // Remove existing shape classes
  selectedTile.classList.remove('rounded', 'circular', 'hexagon', 'diamond', 'triangle', 'parallelogram');
  
  // Add new shape class
  if (shape !== 'rectangle') {
    selectedTile.classList.add(shape);
  }
  
  selectedTile.dataset.shape = shape;
  scheduleSave();
  notify(`Shape changed to ${shape}`, 'success');
}

function showColorPicker() {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  // Create color picker popup
  const popup = document.createElement('div');
  popup.className = 'color-picker-popout show';
  popup.innerHTML = `
    <div class="color-picker-header">
      <div class="color-picker-title">Choose Color</div>
      <button class="color-picker-close" onclick="this.parentElement.parentElement.remove()">×</button>
    </div>
    <div class="color-picker-grid">
      <div class="color-picker-option" style="background:#ff6b6b" onclick="changeTileColor('#ff6b6b')"></div>
      <div class="color-picker-option" style="background:#4ecdc4" onclick="changeTileColor('#4ecdc4')"></div>
      <div class="color-picker-option" style="background:#45b7d1" onclick="changeTileColor('#45b7d1')"></div>
      <div class="color-picker-option" style="background:#96ceb4" onclick="changeTileColor('#96ceb4')"></div>
      <div class="color-picker-option" style="background:#feca57" onclick="changeTileColor('#feca57')"></div>
      <div class="color-picker-option" style="background:#ff9ff3" onclick="changeTileColor('#ff9ff3')"></div>
      <div class="color-picker-option" style="background:#54a0ff" onclick="changeTileColor('#54a0ff')"></div>
      <div class="color-picker-option" style="background:#5f27cd" onclick="changeTileColor('#5f27cd')"></div>
      <div class="color-picker-option" style="background:#00d2d3" onclick="changeTileColor('#00d2d3')"></div>
      <div class="color-picker-option" style="background:#ff9f43" onclick="changeTileColor('#ff9f43')"></div>
      <div class="color-picker-option" style="background:#10ac84" onclick="changeTileColor('#10ac84')"></div>
      <div class="color-picker-option" style="background:#ee5253" onclick="changeTileColor('#ee5253')"></div>
    </div>
  `;
  
  const rect = selectedTile.getBoundingClientRect();
  popup.style.left = rect.left + 'px';
  popup.style.top = (rect.top - 200) + 'px';
  
  document.body.appendChild(popup);
}

function changeTileColor(color) {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  selectedTile.style.backgroundColor = color;
  scheduleSave();
  
  // Update color picker in toolbar
  const colorPicker = document.querySelector('.toolbar-color-picker');
  if (colorPicker) {
    colorPicker.style.setProperty('--tile-color', color);
  }
  
  // Remove color picker popup
  const popup = document.querySelector('.color-picker-popout');
  if (popup) popup.remove();
  
  notify('Tile color changed', 'success');
}

function resetTileColor() {
  if (!selectedTile) return notify('No tile selected', 'error');
  
  const defaultColor = document.documentElement.getAttribute('data-theme') === 'light' ? '#2d3748' : '#ffffff';
  selectedTile.style.backgroundColor = defaultColor;
  scheduleSave();
  
  // Update color picker in toolbar
  const colorPicker = document.querySelector('.toolbar-color-picker');
  if (colorPicker) {
    colorPicker.style.setProperty('--tile-color', defaultColor);
  }
  
  notify('Tile color reset', 'success');
}

    // Connection Operations
    function deleteSelectedConnection() {
      if (!selectedConnection) return notify('No connection selected', 'error');
      
      const connectionId = selectedConnection.dataset.connectionId;
      deleteConnection(connectionId);
      selectedConnection = null;
      hideConnectionToolbar();
      notify('Connection deleted', 'success');
    }

function changeConnectionColor() {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  // Simple color change for now
  const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6'];
  const randomColor = colors[Math.floor(Math.random() * colors.length)];
  
  // Find and update the connection
  const connectionId = selectedConnection.dataset.connectionId;
  const connection = connections.find(c => c.id === connectionId);
  if (connection) {
    connection.color = randomColor;
    renderConnections();
    scheduleSave();
    notify('Connection color changed', 'success');
  }
}

function changeLineStyle(style) {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  selectedConnection.style.strokeDasharray = style === 'solid' ? 'none' : 
                                           style === 'dashed' ? '5,5' : 
                                           style === 'dotted' ? '2,2' : '10,2,2,2';
  
  scheduleSave();
  renderCanvas();
  notify(`Line style changed to ${style}`);
}

function changeConnectionMarker(marker) {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  // Update the connection marker
  const path = selectedConnection.querySelector('path');
  if (path) {
    path.setAttribute('marker-end', marker === 'line' ? '' : `url(#${marker === 'dot' ? 'dotmarker' : marker === 'diamond' ? 'diamondmarker' : 'arrowhead'})`);
  }
  
  scheduleSave();
  renderCanvas();
  notify(`Connection marker changed to ${marker}`);
}

// Enhanced Tile Creation with Connection Dots - using existing createTile function

// Enhanced Tile Selection with Toolbar - using existing selectTile function

    // Connection Selection - using existing functions

// Enhanced Connection Rendering with Line Styles
function createConnectionLineWithSeparation(fromTile, toTile, index, connObj) {
  const { fromPort, toPort } = findOptimalPort(fromTile, toTile, connObj?.fromDot, connObj?.toDot);
  let fx = fromPort.x, fy = fromPort.y, tx = toPort.x, ty = toPort.y;
  const dx = tx - fx, dy = ty - fy, len = Math.max(1, Math.hypot(dx, dy));
  const perpX = -dy / len, perpY = dx / len;
  const bump = (index ? (index - 0.5) * 8 : 0);
  fx += perpX * bump; fy += perpY * bump;
  tx += perpX * bump; ty += perpY * bump;

  const d = createSmartPath(fx, fy, tx, ty);
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', d);
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke', connObj?.color || 'var(--accent-primary)');
  path.setAttribute('stroke-width', '3');
  path.setAttribute('marker-end', 'url(#arrowhead)');
  
  // Apply line style
  if (connObj?.lineStyle) {
    path.classList.add(`line-style-${connObj.lineStyle}`);
  }
  
  path.classList.add('connection-line');
  path.style.pointerEvents = 'stroke';
  path.dataset.connectionId = connObj.id;
  
  path.addEventListener('click', (e) => {
    e.stopPropagation();
    selectConnection(path);
  });
  
  path.addEventListener('mouseenter', () => { 
    path.style.strokeWidth = '4'; 
    path.style.filter = 'drop-shadow(0 0 3px currentColor)'; 
  });
  path.addEventListener('mouseleave', () => { 
    path.style.strokeWidth = '3'; 
    path.style.filter = 'none'; 
  });
  
  return path;
}

// Keyboard Shortcuts
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'TEXTAREA') return; // Don't interfere with text editing
  
  switch(e.key) {
    case 'Delete':
    case 'Backspace':
      if (e.ctrlKey || e.metaKey) break;
      deleteSelected();
      break;
    case 'n':
    case 'N':
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        createNewGraph();
      }
      break;
    case 's':
    case 'S':
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        forceSave();
      }
      break;
    case 'Escape':
      clearSelection();
      hideTileToolbar();
      hideConnectionToolbar();
      break;
    case 'g':
    case 'G':
      if (e.shiftKey) {
        e.preventDefault();
        toggleGrid();
      }
      break;
  }
});

// Enhanced Canvas Click Handler
function handleCanvasClick(e) {
  if (e.target === canvas) {
    clearSelection();
    hideTileToolbar();
    hideConnectionToolbar();
  }
}

// Enhanced Clear Selection
function clearSelection() {
  if (selectedTile) {
    selectedTile.classList.remove('selected');
    selectedTile = null;
  }
  if (selectedConnection) {
    selectedConnection.classList.remove('selected');
    selectedConnection = null;
  }
}

// Initialize enhanced functionality
function initializeEnhancedFeatures() {
  // Set initial states for snap buttons
  document.querySelector('.snap-grid-btn').classList.toggle('active', snapToGrid);
  document.querySelector('.snap-tiles-btn').classList.toggle('active', snapToTiles);
  
  // Add connection dot event listeners
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('connection-dot')) {
      e.stopPropagation();
      // Handle connection dot click
      const tile = e.target.closest('.tile');
      if (tile) {
        startConnectionFromTile(tile, e);
      }
    }
  });
}

// Call enhanced initialization
document.addEventListener('DOMContentLoaded', () => {
  init();
  initializeEnhancedFeatures();
});

// ------------ Missing Functions ------------

function centerCanvas() {
  if (tiles.length === 0) return;
  
  // Calculate the bounding box of all tiles
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  
  tiles.forEach(tile => {
    const x = parseFloat(tile.dataset.baseX || 0);
    const y = parseFloat(tile.dataset.baseY || 0);
    const rect = tile.getBoundingClientRect();
    
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + rect.width);
    maxY = Math.max(maxY, y + rect.height);
  });
  
  // Calculate center point
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  
  // Get canvas dimensions
  const canvasRect = canvas.getBoundingClientRect();
  const targetX = canvasRect.width / 2 - centerX;
  const targetY = canvasRect.height / 2 - centerY;
  
  // Update canvas offset
  canvasOffset.x = targetX;
  canvasOffset.y = targetY;
  
  // Apply transform
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  
  // Render connections
  renderConnections();
  
  notify('Canvas centered');
}

function zoomIn() {
  zoom = Math.min(zoom * 1.2, 3);
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
}

function zoomOut() {
  zoom = Math.max(zoom / 1.2, 0.3);
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
}

function zoomReset() {
  zoom = 1;
  canvasContent.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
  renderConnections();
}

function forceSave() {
  if (!currentGraph) return notify('No graph to save', 'error');
  
  const indicator = document.getElementById('autoSaveIndicator');
  const text = document.getElementById('autoSaveText');
  
  indicator.classList.add('show', 'saving');
  text.textContent = 'Saving...';
  
  // Force immediate save
  autoSaveGraph().then(() => {
    indicator.classList.remove('saving');
    indicator.classList.add('saved');
    text.textContent = 'Saved!';
    setTimeout(() => indicator.classList.remove('show', 'saved'), 2000);
  });
}

function showCacheStatus() {
  const modal = document.getElementById('cacheStatusModal');
  if (!modal) return;
  
  // Update status information
  const lastSaveTimeEl = document.getElementById('lastSaveTime');
  const autoSaveStatusEl = document.getElementById('autoSaveStatus');
  const pendingUpdatesCountEl = document.getElementById('pendingUpdatesCount');
  const connectionStatusEl = document.getElementById('connectionStatus');
  
  if (lastSaveTimeEl) {
    lastSaveTimeEl.textContent = lastSaveTime ? new Date(lastSaveTime).toLocaleTimeString() : 'Never';
  }
  
  if (autoSaveStatusEl) {
    autoSaveStatusEl.textContent = autoSaveTimer ? 'Enabled' : 'Disabled';
  }
  
  if (pendingUpdatesCountEl) {
    pendingUpdatesCountEl.textContent = pendingUpdates.length;
  }
  
  if (connectionStatusEl) {
    connectionStatusEl.textContent = navigator.onLine ? 'Online' : 'Offline';
  }
  
  modal.classList.add('show');
  modal.onclick = (e) => { if (e.target === modal) closeCacheStatusModal(); };
}

function closeCacheStatusModal() {
  const modal = document.getElementById('cacheStatusModal');
  if (modal) modal.classList.remove('show');
}

function showPresetTileSelector() {
  const modal = document.getElementById('presetTileModal');
  if (modal) modal.classList.add('show');
}

function closePresetTileModal() {
  const modal = document.getElementById('presetTileModal');
  if (modal) modal.classList.remove('show');
}

function toggleSnapToGrid() {
  snapToGrid = !snapToGrid;
  const btn = document.querySelector('.snap-grid-btn');
  if (btn) btn.classList.toggle('active', snapToGrid);
  notify(`Snap to grid ${snapToGrid ? 'ON' : 'OFF'}`);
}

function toggleSnapToTiles() {
  snapToTiles = !snapToTiles;
  const btn = document.querySelector('.snap-tiles-btn');
  if (btn) btn.classList.toggle('active', snapToTiles);
  notify(`Snap to tiles ${snapToTiles ? 'ON' : 'OFF'}`);
}

function toggleGrid() {
  showGrid = !showGrid;
  const btn = document.querySelector('.grid-toggle-btn');
  if (btn) {
    btn.classList.toggle('active', showGrid);
    btn.title = `Show Grid (${showGrid ? 'ON' : 'OFF'})`;
  }
  
  const overlay = document.getElementById('grid-overlay');
  if (overlay) overlay.classList.toggle('show', showGrid);
  
  notify(`Grid ${showGrid ? 'ON' : 'OFF'}`);
}

function duplicateTile() {
  if (!selectedTile) return notify('Select a tile first', 'error');
  
  const x = parseFloat(selectedTile.dataset.baseX || 0) + 20;
  const y = parseFloat(selectedTile.dataset.baseY || 0) + 20;
  
  const newTile = createTile(
    x, y,
    selectedTile.querySelector('.tile-title')?.value || '',
    selectedTile.querySelector('.tile-content')?.value || '',
    null,
    selectedTile.dataset.shape || 'rectangle',
    selectedTile.dataset.presetType || 'custom',
    selectedTile.style.backgroundColor || '#ffffff'
  );
  
  tiles.push(newTile);
  renderCanvas();
  scheduleSave();
  notify('Tile duplicated');
}

function bringToFront() {
  if (!selectedTile) return;
  selectedTile.style.zIndex = '1000';
  notify('Tile brought to front');
}

function sendToBack() {
  if (!selectedTile) return;
  selectedTile.style.zIndex = '1';
  notify('Tile sent to back');
}

function changeTileShape(shape) {
  if (!selectedTile) return;
  setTileShape(selectedTile, shape);
  notify(`Shape changed to ${shape}`);
}

function resetTileColor() {
  if (!selectedTile) return;
  selectedTile.style.backgroundColor = '#ffffff';
  scheduleSave();
  notify('Color reset');
}

function showColorPicker() {
  // This will be handled by the existing color picker functionality
  notify('Color picker opened');
}

function deleteSelectedConnection() {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  const connectionId = selectedConnection.dataset.connectionId;
  deleteConnection(connectionId);
  selectedConnection = null;
  hideConnectionToolbar();
  notify('Connection deleted');
}

function changeConnectionColor() {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  // Open color picker for connection
  openColorPopup(document.querySelector('#connColorPick'), (color) => {
    selectedConnection.style.stroke = color;
    scheduleSave();
    renderCanvas();
    notify('Connection color changed');
  });
}

function changeLineStyle(style) {
  if (!selectedConnection) return notify('No connection selected', 'error');
  
  selectedConnection.style.strokeDasharray = style === 'solid' ? 'none' : 
                                           style === 'dashed' ? '5,5' : 
                                           style === 'dotted' ? '2,2' : '10,2,2,2';
  
  scheduleSave();
  renderCanvas();
  notify(`Line style changed to ${style}`);
}

function openTileToolbar(tile, at = null, force = false, focusSection = null) {
  if (!tile && !force) return;
  
  const pos = at || { 
    x: (tile.getBoundingClientRect().left + tile.getBoundingClientRect().right) / 2,
    y: tile.getBoundingClientRect().top - 8 
  };
  
  const floatTB = document.getElementById('tileToolbar');
  if (!floatTB) return;
  
  floatTB.innerHTML = `
    <div class="toolbar-section">
      <div class="toolbar-section-title">Tile</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="duplicateTile()" title="Duplicate">Copy</button>
        <button class="toolbar-button" onclick="deleteSelected()" title="Delete">Delete</button>
        <div class="toolbar-color" id="tileColorPick" title="Color"></div>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Shape</div>
      <div class="toolbar-row">
        ${['rectangle','rounded','circular','diamond','hexagon','triangle','parallelogram']
          .map(s=>`<button class="toolbar-button ${tile?.dataset.shape===s?'active':''}" onclick="changeTileShape('${s}')">${shapeIcon(s)}</button>`).join('')}
      </div>
    </div>
  `;
  
  floatTB.style.left = pos.x + 'px';
  floatTB.style.top = pos.y + 'px';
  floatTB.classList.add('show');
  
  // Add color picker functionality
  const colorPick = floatTB.querySelector('#tileColorPick');
  if (colorPick) {
    colorPick.onclick = () => openColorPopup(colorPick, (c) => {
      tile.style.backgroundColor = c;
      scheduleSave();
    });
  }
}

function openConnectionToolbar(conn, at) {
  // Close other menus first
  closeAllTileMenus();
  
  const floatTB = document.getElementById('connectionToolbar');
  if (!floatTB) return;
  
  floatTB.innerHTML = `
    <div class="toolbar-section">
      <div class="toolbar-section-title">Connection</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="deleteSelectedConnection()" title="Delete">Delete</button>
        <button class="toolbar-button" onclick="changeConnectionColor()" title="Color">Color</button>
      </div>
    </div>
    <div class="toolbar-section">
      <div class="toolbar-section-title">Style</div>
      <div class="toolbar-row">
        <button class="toolbar-button" onclick="changeLineStyle('solid')" title="Solid">━</button>
        <button class="toolbar-button" onclick="changeLineStyle('dashed')" title="Dashed">┅</button>
        <button class="toolbar-button" onclick="changeLineStyle('dotted')" title="Dotted">┄</button>
      </div>
    </div>
  `;
  
  floatTB.style.left = at.x + 'px';
  floatTB.style.top = at.y + 'px';
  floatTB.classList.add('show');
}

function hideConnectionToolbar() {
  const floatTB = document.getElementById('connectionToolbar');
  if (floatTB) floatTB.classList.remove('show');
}

function hideFloatingToolbars() {
  const tileTB = document.getElementById('tileToolbar');
  const connTB = document.getElementById('connectionToolbar');
  
  if (tileTB) tileTB.classList.remove('show');
  if (connTB) connTB.classList.remove('show');
}

function scheduleSave() {
  if (autoSaveTimer) clearTimeout(autoSaveTimer);
  autoSaveTimer = setTimeout(autoSaveGraph, 2000);
  markAsDirty();
}

function markAsDirty() {
  isDirty = true;
  lastSaveTime = Date.now();
  pushHistory();
}

function addPendingUpdate(type, data) {
  pendingUpdates.push({ type, data, timestamp: Date.now() });
}

function ctxAction(action) {
  if (!selectedTile) return;
  
  switch (action) {
    case 'edit':
      selectedTile.querySelector('.tile-content')?.focus();
      break;
    case 'color':
      openColorPopup(selectedTile, (c) => {
        selectedTile.style.backgroundColor = c;
        scheduleSave();
      });
      break;
    case 'shape':
      // Show shape options
      break;
    case 'duplicate':
      duplicateTile();
      break;
    case 'delete':
      deleteSelected();
      break;
  }
  
  // Hide context menu
  const ctxMenu = document.getElementById('ctxMenu');
  if (ctxMenu) ctxMenu.style.display = 'none';
}

// Add missing functions
function addTileClickHandler(tile) {
  tile.addEventListener('click', () => selectTile(tile));
  tile.addEventListener('dblclick', (e) => openTileToolbar(tile, { x: e.clientX, y: e.clientY }));
  
  // Add connection dot event listeners
  tile.querySelectorAll('.connection-dot').forEach(el => {
    el.addEventListener('mousedown', (e) => startConnectionFromPort(el, e));
  });
}


function loadFromLocalStorage() {
  // Look for any saved graphs in localStorage
  const savedGraphs = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.startsWith('flowpad_graph_')) {
      try {
        const graphData = JSON.parse(localStorage.getItem(key));
        if (graphData && graphData.title && graphData.data) {
          savedGraphs.push({
            id: key.replace('flowpad_graph_', ''),
            title: graphData.title,
            updated_at: graphData.updated_at || Date.now(),
            data: graphData.data,
            type: 'local'
          });
        }
      } catch (e) {
        console.log('Failed to parse saved graph:', key);
      }
    }
  }
  
  if (savedGraphs.length > 0) {
    // Sort by most recently updated
    savedGraphs.sort((a, b) => (b.updated_at || 0) - (a.updated_at || 0));
    
    // Load the most recent graph
    const mostRecent = savedGraphs[0];
    currentGraph = mostRecent;
    
    // Create tiles and connections
    tiles = [];
    connections = [];
    (mostRecent.data.tiles || []).forEach(t => {
      const tile = createTile(t.x, t.y, t.title, t.content, t.id, t.shape || 'rectangle', t.preset || 'custom', t.color || '#ffffff');
      
      // Restore custom dimensions if they exist
      if (t.width) tile.style.width = t.width + 'px';
      if (t.height) tile.style.height = t.height + 'px';
      
      tiles.push(tile);
    });
    connections = mostRecent.data.connections || [];
    
    // Create a tab for the loaded graph
    if (!openTabs.find(t => t.id === mostRecent.id)) {
      createTab(mostRecent);
    }
    switchToTab(mostRecent.id);
    
    // Render the canvas
    renderCanvas();
    isDirty = false;
    updateTileColorsForTheme(document.documentElement.getAttribute('data-theme'));
    pushHistory(true);
    
    notify(`Loaded "${mostRecent.title}" from local storage`, 'success');
  } else if (tiles.length === 0) {
    // Don't create demo graph - let user create their own
    notify('No saved graphs found. Create a new graph to get started.', 'info');
  }
}

function addResizeHandles(tile) {
  // Remove existing handles
  tile.querySelectorAll('.resize-handle').forEach(h => h.remove());
  
  // Create resize handles for each edge (4 dots on each side) and corners
  const handles = [
    // North edge - 4 dots
    { class: 'n1', cursor: 'n-resize', position: '25%' },
    { class: 'n2', cursor: 'n-resize', position: '50%' },
    { class: 'n3', cursor: 'n-resize', position: '75%' },
    // South edge - 4 dots
    { class: 's1', cursor: 's-resize', position: '25%' },
    { class: 's2', cursor: 's-resize', position: '50%' },
    { class: 's3', cursor: 's-resize', position: '75%' },
    // East edge - 4 dots
    { class: 'e1', cursor: 'e-resize', position: '25%' },
    { class: 'e2', cursor: 'e-resize', position: '50%' },
    { class: 'e3', cursor: 'e-resize', position: '75%' },
    // West edge - 4 dots
    { class: 'w1', cursor: 'w-resize', position: '25%' },
    { class: 'w2', cursor: 'w-resize', position: '50%' },
    { class: 'w3', cursor: 'w-resize', position: '75%' },
    // Corners
    { class: 'nw', cursor: 'nw-resize', position: 'corner' },
    { class: 'ne', cursor: 'ne-resize', position: 'corner' },
    { class: 'sw', cursor: 'sw-resize', position: 'corner' },
    { class: 'se', cursor: 'se-resize', position: 'corner' }
  ];
  
  handles.forEach(handle => {
    const div = document.createElement('div');
    div.className = `resize-handle ${handle.class}`;
    div.style.cursor = handle.cursor;
    div.dataset.handle = handle.class;
    
    // Add event listeners for resizing
    div.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      startResizing(tile, handle.class, e);
    });
    
    tile.appendChild(div);
  });
}

function startResizing(tile, handleType, e) {
  e.preventDefault();
  
  const startX = e.clientX;
  const startY = e.clientY;
  const startWidth = tile.offsetWidth;
  const startHeight = tile.offsetHeight;
  const startLeft = parseFloat(tile.style.left) || 0;
  const startTop = parseFloat(tile.style.top) || 0;
  
  const isResizing = true;
  
  function onMouseMove(e) {
    const deltaX = e.clientX - startX;
    const deltaY = e.clientY - startY;
    
    let newWidth = startWidth;
    let newHeight = startHeight;
    let newLeft = startLeft;
    let newTop = startTop;
    
    // Handle different resize directions
    switch (handleType) {
      // North edge handles
      case 'n1': case 'n2': case 'n3':
        newHeight = Math.max(100, startHeight - deltaY);
        newTop = startTop + (startHeight - newHeight);
        break;
      // South edge handles
      case 's1': case 's2': case 's3':
        newHeight = Math.max(100, startHeight + deltaY);
        break;
      // East edge handles
      case 'e1': case 'e2': case 'e3':
        newWidth = Math.max(150, startWidth + deltaX);
        break;
      // West edge handles
      case 'w1': case 'w2': case 'w3':
        newWidth = Math.max(150, startWidth - deltaX);
        newLeft = startLeft + (startWidth - newWidth);
        break;
      case 'nw': // Northwest corner
        newWidth = Math.max(150, startWidth - deltaX);
        newHeight = Math.max(100, startHeight - deltaY);
        newLeft = startLeft + (startWidth - newWidth);
        newTop = startTop + (startHeight - newHeight);
        break;
      case 'ne': // Northeast corner
        newWidth = Math.max(150, startWidth + deltaX);
        newHeight = Math.max(100, startHeight - deltaY);
        newTop = startTop + (startHeight - newHeight);
        break;
      case 'sw': // Southwest corner
        newWidth = Math.max(150, startWidth - deltaX);
        newHeight = Math.max(100, startHeight + deltaY);
        newLeft = startLeft + (startWidth - newWidth);
        break;
      case 'se': // Southeast corner
        newWidth = Math.max(150, startWidth + deltaX);
        newHeight = Math.max(100, startHeight + deltaY);
        break;
    }
    
    // Apply new dimensions
    tile.style.width = newWidth + 'px';
    tile.style.height = newHeight + 'px';
    tile.style.left = newLeft + 'px';
    tile.style.top = newTop + 'px';
    
    // Update tile data
    tile.dataset.baseX = newLeft;
    tile.dataset.baseY = newTop;
    
    // Mark as dirty and schedule save
    markAsDirty();
    scheduleSave();
    
    // Re-render connections
    renderConnections();
  }
  
  function onMouseUp() {
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
    
    // Final save
    scheduleSave();
  }
  
  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
}

function openShareGraphModal() {
  const modal = document.getElementById('shareGraphModal');
  if (!modal) return;
  
  // Reset form
  document.getElementById('shareEmail').value = '';
  document.querySelector('input[name="permission"][value="view"]').checked = true;
  
  modal.classList.add('show');
  modal.style.display = 'flex';
}

function closeShareGraphModal() {
  const modal = document.getElementById('shareGraphModal');
  if (!modal) return;
  
  modal.classList.remove('show');
  modal.style.display = 'none';
}

function shareGraph() {
  if (!currentGraph) return;
  
  const email = document.getElementById('shareEmail').value.trim();
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    return notify('Invalid email address', 'error');
  }
  
  const permission = document.querySelector('input[name="permission"]:checked').value;
  
  // Here you would typically send the share request to your server
  // For now, we'll just show a success message
  notify(`Graph shared with ${email} (${permission} access)`, 'success');
  closeShareGraphModal();
  
  // In a real implementation, you would call:
  // fetch(`/api/graphs/${currentGraph.id}/share`, {
  //   method: 'POST',
  //   headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${localStorage.getItem('flowpad_token')}` },
  //   body: JSON.stringify({ email, permission })
  // });
}

function handleDragOver(e) {
  e.preventDefault();
  e.currentTarget.classList.add('drag-over');
}

function handleDragLeave(e) {
  e.currentTarget.classList.remove('drag-over');
}

function handleDrop(e, targetFolder) {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-over');
  
  const graphId = e.dataTransfer.getData('text/plain');
  const graphData = e.dataTransfer.getData('application/json');
  
  if (!graphId || !graphData) return;
  
  try {
    const graph = JSON.parse(graphData);
    
    // Remove from current folder
    const currentFolder = findGraphFolder(graphId);
    if (currentFolder && currentFolder !== targetFolder) {
      removeGraphFromFolder(graphId, currentFolder);
    }
    
    // Add to target folder
    addGraphToFolder(graph, targetFolder);
    
    notify(`Graph "${graph.title}" moved to ${targetFolder}`, 'success');
    
  } catch (error) {
    notify('Failed to move graph', 'error');
  }
}

function findGraphFolder(graphId) {
  // Find which folder currently contains this graph
  const folders = ['myGraphs', 'sharedGraphs', 'inbox'];
  for (const folder of folders) {
    const container = document.getElementById(folder === 'myGraphs' ? 'ownGraphs' : folder === 'sharedGraphs' ? 'sharedGraphsContent' : 'inboxContent');
    if (container.querySelector(`[data-graph-id="${graphId}"]`)) {
      return folder;
    }
  }
  return null;
}

function removeGraphFromFolder(graphId, folderId) {
  const container = document.getElementById(folderId === 'myGraphs' ? 'ownGraphs' : folderId === 'sharedGraphs' ? 'sharedGraphsContent' : 'inboxContent');
  const graphElement = container.querySelector(`[data-graph-id="${graphId}"]`);
  if (graphElement) {
    graphElement.remove();
  }
}

function addGraphToFolder(graph, folderId) {
  const container = document.getElementById(folderId === 'myGraphs' ? 'ownGraphs' : folderId === 'sharedGraphs' ? 'sharedGraphsContent' : 'inboxContent');
  
  const item = document.createElement('div');
  item.className = 'graph-item';
  item.dataset.graphId = graph.id;
  item.draggable = true;
  item.innerHTML = `
    <div class="graph-title">${graph.title}</div>
    <div class="graph-meta">Updated: ${new Date(graph.updated_at || Date.now()).toLocaleString()}</div>
    <button class="graph-delete" onclick="deleteGraph('${graph.id}')" title="Delete graph">×</button>
  `;
  
  // Click to load graph
  item.addEventListener('click', (e) => { 
    if (!e.target.classList.contains('graph-delete')) loadGraph(graph); 
  });
  
  // Drag and drop functionality
  item.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', graph.id);
    e.dataTransfer.setData('application/json', JSON.stringify(graph));
    item.classList.add('dragging');
  });
  
  item.addEventListener('dragend', () => {
    item.classList.remove('dragging');
  });
  
  container.appendChild(item);
}

function updateTileMenuPosition() {
  if (selectedTile) {
    const toolbar = document.getElementById('tileToolbar');
    if (toolbar && toolbar.classList.contains('show')) {
      const rect = selectedTile.getBoundingClientRect();
      const pos = {
        x: (rect.left + rect.right) / 2,
        y: rect.top - 8
      };
      toolbar.style.left = pos.x + 'px';
      toolbar.style.top = pos.y + 'px';
    }
  }
}

function closeAllTileMenus() {
  const tileToolbar = document.getElementById('tileToolbar');
  const connectionToolbar = document.getElementById('connectionToolbar');
  
  if (tileToolbar) {
    tileToolbar.classList.remove('show');
  }
  if (connectionToolbar) {
    connectionToolbar.classList.remove('show');
  }
  
  // Also close preset modal if open
  const presetModal = document.getElementById('presetTileModal');
  if (presetModal && presetModal.classList.contains('show')) {
    presetModal.classList.remove('show');
    presetModal.style.display = 'none';
  }
}

// Add click outside listener to close menus
document.addEventListener('click', (e) => {
  if (!e.target.closest('.toolbar') && !e.target.closest('.tile') && !e.target.closest('.connection-dot')) {
    closeAllTileMenus();
  }
});

function toggleShapeDropdown() {
  const dropdown = document.getElementById('shapeDropdown');
  if (dropdown) {
    dropdown.classList.toggle('show');
  }
}

// Close dropdowns when clicking outside
document.addEventListener('click', (e) => {
  if (!e.target.closest('.toolbar-dropdown')) {
    const dropdowns = document.querySelectorAll('.toolbar-dropdown-content');
    dropdowns.forEach(d => d.classList.remove('show'));
  }
});

// Function to create new text rectangles on tiles
function createTextRectangle() {
  const canvasRect = canvas.getBoundingClientRect();
  const centerX = canvasRect.width / 2;
  const centerY = canvasRect.height / 2;
  const x = Math.max(20, Math.round(centerX - 75));
  const y = Math.max(20, Math.round(centerY - 25));
  
  const tile = createTile(x, y, '', 'Text', null, 'rectangle', 'text');
  
  // Make text rectangles smaller and more suitable for labels
  tile.style.width = '150px';
  tile.style.height = '50px';
  
  // Focus on the content field for immediate editing
  const contentField = tile.querySelector('.tile-content');
  if (contentField) {
    contentField.focus();
    contentField.select();
  }
  
  tiles.push(tile);
  renderCanvas();
  scheduleSave();
  notify('Text rectangle added', 'success');
}
</script>
</body>
</html>

