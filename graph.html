<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flowpad - Dashboard</title>
  <style>
    :root {
      --bg-primary: #1a1a1a;
      --bg-secondary: #2d2d2d;
      --bg-tertiary: rgba(0,0,0,0.9);
      --bg-sidebar: rgba(0,0,0,0.8);
      --bg-tile: #fff;
      --bg-tile-hover: #f8f9fa;
      --text-primary: #fff;
      --text-secondary: #ccc;
      --text-tile: #000;
      --border-primary: #333;
      --border-secondary: #555;
      --accent-primary: #007AFF;
      --accent-secondary: #0056CC;
      --shadow-primary: rgba(0,0,0,0.3);
      --shadow-secondary: rgba(0,0,0,0.2);
      --grid-color: rgba(255,255,255,0.03);
      --tab-active: #007AFF;
      --tab-inactive: #444;
      --tab-hover: #555;
      --inbox-pending: #FF9500;
      --inbox-accepted: #34C759;
      --inbox-rejected: #FF3B30;
    }

    :root[data-theme="light"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9fa;
      --bg-tertiary: rgba(255,255,255,0.95);
      --bg-sidebar: rgba(255,255,255,0.95);
      --bg-tile: #ffffff;
      --bg-tile-hover: #f8f9fa;
      --text-primary: #2d3748;
      --text-secondary: #4a5568;
      --text-tile: #000000;
      --border-primary: #e2e8f0;
      --border-secondary: #cbd5e0;
      --shadow-primary: rgba(0,0,0,0.1);
      --shadow-secondary: rgba(0,0,0,0.05);
      --grid-color: rgba(0,0,0,0.03);
      --tab-active: #007AFF;
      --tab-inactive: #ddd;
      --tab-hover: #e2e8f0;
      --inbox-pending: #FF9500;
      --inbox-accepted: #34C759;
      --inbox-rejected: #FF3B30;
    }

    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;background:var(--bg-primary);background-image:linear-gradient(var(--grid-color) 1px,transparent 1px),linear-gradient(90deg,var(--grid-color) 1px,transparent 1px);background-size:20px 20px;color:var(--text-primary);overflow:hidden;transition:all 0.3s ease}
    
    .header{position:fixed;inset:0 0 auto 0;height:60px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border-bottom:1px solid var(--border-primary);display:flex;align-items:center;justify-content:space-between;padding:0 20px;z-index:1000;transition:all 0.3s ease;box-shadow:0 4px 20px var(--shadow-primary)}
    .logo{font-size:1.5rem;font-weight:400;background:linear-gradient(45deg,var(--text-primary),var(--text-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .user-info{display:flex;align-items:center;gap:15px}
    .signout-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 16px;border-radius:6px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .signout-btn:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    .theme-toggle{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 12px;border-radius:6px;cursor:pointer;margin-right:10px;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .theme-toggle:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    .sidebar{position:fixed;left:0;top:60px;bottom:0;width:300px;background:var(--bg-sidebar);backdrop-filter:blur(20px);border-right:1px solid var(--border-primary);overflow-y:auto;transition:all 0.3s ease;box-shadow:4px 0 20px var(--shadow-primary)}
    .sidebar-content{padding:20px}
    .section-title{font-size:1.1rem;font-weight:400;margin-bottom:15px;color:var(--text-primary);text-shadow:0 1px 2px var(--shadow-primary)}
    .new-graph-btn{background:var(--accent-primary);color:#fff;border:none;padding:12px 20px;border-radius:8px;cursor:pointer;width:100%;font-size:1rem;margin-bottom:20px;transition:all 0.3s ease;box-shadow:0 4px 12px var(--shadow-primary)}
    .new-graph-btn:hover{background:var(--accent-secondary);box-shadow:0 6px 16px var(--shadow-secondary)}
    
    .folder-section{margin-bottom:25px;border:1px solid var(--border-secondary);border-radius:8px;overflow:hidden;box-shadow:0 2px 8px var(--shadow-primary)}
    .folder-header{background:var(--bg-secondary);padding:12px 15px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border-secondary);transition:all 0.3s ease}
    .folder-header:hover{background:var(--border-primary)}
    .folder-header.active{background:var(--accent-primary);color:#fff}
    .folder-icon{margin-right:8px;font-size:1.1rem}
    .folder-arrow{transition:transform 0.3s ease}
    .folder-arrow.expanded{transform:rotate(90deg)}
    .folder-content{padding:10px;background:var(--bg-tertiary);display:none}
    .folder-content.expanded{display:block}
    
    .graph-item{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:12px;margin-bottom:8px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary);position:relative}
    .graph-item:hover{background:var(--border-primary);box-shadow:0 4px 12px var(--shadow-secondary);transform:translateX(5px)}
    .graph-item.active{background:var(--accent-primary);color:#fff;border-color:var(--accent-primary)}
    .graph-title{font-weight:400;margin-bottom:5px;color:inherit;font-size:0.95rem}
    .graph-meta{font-size:.75rem;color:inherit;opacity:0.8}
    .graph-delete{position:absolute;top:8px;right:8px;background:rgba(255,0,0,0.8);color:#fff;border:none;border-radius:4px;width:20px;height:20px;cursor:pointer;font-size:12px;opacity:0;transition:opacity 0.3s ease}
    .graph-item:hover .graph-delete{opacity:1}
    .graph-delete:hover{background:rgba(255,0,0,1)}
    
    .inbox-item{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:12px;margin-bottom:8px;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary);position:relative}
    .inbox-item.pending{border-left:4px solid var(--inbox-pending)}
    .inbox-item.accepted{border-left:4px solid var(--inbox-accepted)}
    .inbox-item.rejected{border-left:4px solid var(--inbox-rejected)}
    .inbox-title{font-weight:400;margin-bottom:5px;color:var(--text-primary);font-size:0.95rem}
    .inbox-meta{font-size:.75rem;color:var(--text-secondary);margin-bottom:10px}
    .inbox-actions{display:flex;gap:8px}
    .inbox-btn{flex:1;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;font-size:0.8rem;transition:all 0.3s ease;box-shadow:0 2px 4px var(--shadow-primary)}
    .inbox-btn.accept{background:var(--inbox-accepted);color:#fff}
    .inbox-btn.accept:hover{box-shadow:0 4px 8px var(--shadow-secondary)}
    .inbox-btn.reject{background:var(--inbox-rejected);color:#fff}
    .inbox-btn.reject:hover{box-shadow:0 4px 8px var(--shadow-secondary)}
    
    .canvas-container{position:fixed;left:300px;top:60px;right:0;bottom:0;overflow:hidden}
    .canvas{width:100%;height:100%;background-image:linear-gradient(var(--grid-color) 1px,transparent 1px),linear-gradient(90deg,var(--grid-color) 1px,transparent 1px);background-size:20px 20px;position:relative;cursor:grab}

    
    .tile{position:absolute;background:var(--bg-tile);color:var(--text-tile);border:2px solid var(--border-primary);border-radius:12px;padding:20px;min-width:150px;min-height:100px;cursor:move;user-select:none;box-shadow:0 8px 25px var(--shadow-primary);transition:all 0.3s ease;resize:both;overflow:hidden}
    .tile:hover{background:var(--bg-tile-hover);box-shadow:0 12px 35px var(--shadow-secondary)}
    .tile.selected{border-color:var(--accent-primary);box-shadow:0 0 0 3px rgba(0, 122, 255, 0.3)}
    .tile-title,.tile-content{border:none;background:transparent;width:100%;outline:none;font-family:inherit;resize:none;font-weight:400}
    .tile-title{font-weight:400;margin-bottom:12px;font-size:1rem;color:var(--text-tile)}
    .tile-content{font-size:0.9rem;line-height:1.5;min-height:50px;color:var(--text-tile);font-weight:400}
    
    /* Resize handles - bigger and better positioned */
    .tile::after{content:'';position:absolute;bottom:0;right:0;width:30px;height:30px;cursor:se-resize;background:linear-gradient(-45deg,transparent 30%,var(--border-primary) 30%,var(--border-primary) 40%,transparent 40%,transparent 60%,var(--border-primary) 60%,var(--border-primary) 70%,transparent 70%);border-radius:0 0 12px 0}
    .tile::before{content:'';position:absolute;top:0;left:0;width:30px;height:30px;cursor:nw-resize;background:linear-gradient(45deg,transparent 30%,var(--border-primary) 30%,var(--border-primary) 40%,transparent 40%,transparent 60%,var(--border-primary) 60%,var(--border-primary) 70%,transparent 70%);border-radius:12px 0 0 0}
    
    .color-palette{position:absolute;top:10px;right:10px;display:grid;grid-template-columns:repeat(5,1fr);gap:4px;opacity:0;transition:opacity 0.3s ease;width:120px;z-index:1000}
    .tile:hover .color-palette{opacity:1}
    .color-option{width:20px;height:20px;border-radius:50%;border:2px solid var(--border-primary);cursor:pointer;transition:all 0.3s ease}
    .color-option:hover{transform:scale(1.2);border-color:var(--accent-primary)}
    .color-option.selected{border-color:var(--accent-primary);box-shadow:0 0 0 2px var(--accent-primary)}
    
    /* Color picker popout */
    .color-picker-popout{position:absolute;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:15px;box-shadow:0 10px 25px var(--shadow-primary);z-index:1001;display:none;min-width:200px;backdrop-filter:blur(20px)}
    .color-picker-popout.show{display:block}
    .color-picker-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid var(--border-secondary)}
    .color-picker-title{font-weight:500;color:var(--text-primary);font-size:0.9rem}
    .color-picker-close{background:none;border:none;color:var(--text-secondary);cursor:pointer;font-size:16px;padding:2px;border-radius:4px;transition:all 0.3s ease}
    .color-picker-close:hover{color:var(--text-primary);background:var(--border-primary)}
    .color-picker-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;margin-bottom:15px}
    .color-picker-option{width:30px;height:30px;border-radius:50%;border:2px solid var(--border-primary);cursor:pointer;transition:all 0.3s ease;position:relative}
    .color-picker-option:hover{transform:scale(1.1);border-color:var(--accent-primary)}
    .color-picker-option.selected{border-color:var(--accent-primary);box-shadow:0 0 0 3px var(--accent-primary)}
    .color-picker-option.selected::after{content:'✓';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:12px;font-weight:bold;text-shadow:0 1px 2px rgba(0,0,0,0.5)}
    .color-picker-recent{display:grid;grid-template-columns:repeat(5,1fr);gap:5px}
    .color-picker-recent-title{font-size:0.8rem;color:var(--text-secondary);margin-bottom:8px;text-align:center}
    .color-picker-recent-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:5px}
    
    /* Collaborative users list */
    .collaborators-list{position:fixed;bottom:20px;right:20px;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:12px;box-shadow:0 8px 25px var(--shadow-primary);z-index:1000;min-width:180px;backdrop-filter:blur(20px);display:none}
    .collaborators-list.show{display:block}
    .collaborators-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--border-secondary)}
    .collaborators-title{font-size:0.8rem;font-weight:500;color:var(--text-primary)}
    .collaborators-count{background:var(--accent-primary);color:#fff;border-radius:10px;padding:2px 8px;font-size:0.7rem;font-weight:500}
    .collaborator-item{display:flex;align-items:center;gap:8px;padding:6px 0;border-bottom:1px solid var(--border-secondary);font-size:0.8rem}
    .collaborator-item:last-child{border-bottom:none}
    .collaborator-avatar{width:24px;height:24px;border-radius:50%;background:var(--accent-primary);color:#fff;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:500}
    .collaborator-name{color:var(--text-primary);flex:1}
    .collaborator-status{width:8px;height:8px;border-radius:50%;background:var(--inbox-accepted)}
    .collaborator-status.away{background:var(--inbox-pending)}
    .collaborator-status.offline{background:var(--inbox-rejected)}
    
    .connection-dot{position:absolute;width:20px;height:20px;background:var(--accent-primary);border:3px solid #fff;border-radius:50%;cursor:crosshair;z-index:10;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .connection-dot:hover{transform:scale(1.2);background:var(--accent-secondary)}
    .connection-dot.input{left:-10px;top:50%;transform:translateY(-50%)}
    .connection-dot.output{right:-10px;top:50%;transform:translateY(-50%)}
    .connection-dot.top{top:-10px;left:50%;transform:translateX(-50%)}
    .connection-dot.bottom{bottom:-10px;left:50%;transform:translateX(-50%)}
    
    .connection{position:absolute;pointer-events:none;z-index:5}
    .connection-line{stroke:var(--accent-primary);stroke-width:3;fill:none;marker-end:url(#arrowhead);filter:drop-shadow(0 2px 4px var(--shadow-primary))}
    .connection-line:hover{stroke:var(--accent-secondary);stroke-width:4}
    
    .toolbar{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:15px;z-index:1000;min-width:200px;transition:all 0.3s ease;box-shadow:0 8px 25px var(--shadow-primary)}
    .tool-label{color:var(--text-secondary);font-size:.8rem;margin-bottom:8px;text-align:center;font-weight:400}
    .tool-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px;border-radius:6px;cursor:pointer;margin:2px;width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;font-size:1rem;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .tool-btn:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    .tool-btn.active{background:var(--accent-primary);color:#fff}
    .tool-btn.cache-status-btn{background:var(--accent-primary);color:#fff}
    .tool-btn.cache-status-btn:hover{background:var(--accent-secondary)}
    .tool-btn.force-save-btn{background:var(--inbox-pending);color:#fff}
    .tool-btn.force-save-btn:hover{background:var(--inbox-accepted)}
    .tool-btn.snap-grid-btn{background:var(--accent-primary);color:#fff}
    .tool-btn.snap-grid-btn:hover{background:var(--accent-secondary)}
    .tool-btn.snap-grid-btn:not(.active){background:var(--border-primary);color:var(--text-primary)}
    .tool-btn.snap-tiles-btn{background:var(--accent-primary);color:#fff}
    .tool-btn.snap-tiles-btn:hover{background:var(--accent-secondary)}
    .tool-btn.snap-tiles-btn:not(.active){background:var(--border-primary);color:var(--text-primary)}
    
    .ai-panel{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:20px;z-index:1000;width:300px;display:none;transition:all 0.3s ease;box-shadow:0 8px 25px var(--shadow-primary)}
    .ai-panel.show{display:block}
    .ai-title{font-size:1.1rem;font-weight:400;margin-bottom:15px;color:var(--text-primary)}
    .ai-input{width:100%;padding:10px;border:1px solid var(--border-secondary);border-radius:6px;background:var(--bg-secondary);color:var(--text-primary);margin-bottom:15px;resize:vertical;min-height:80px;font-weight:400}
    .ai-btn{background:var(--accent-primary);color:#fff;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;width:100%;transition:all 0.3s ease;box-shadow:0 4px 12px var(--shadow-primary)}
    .ai-btn:hover{background:var(--accent-secondary);box-shadow:0 6px 16px var(--shadow-secondary)}
    .ai-btn:disabled{background:var(--border-secondary);cursor:not-allowed;box-shadow:none}
    .ai-suggestions{margin-top:15px;max-height:200px;overflow-y:auto}
    .ai-suggestion{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:10px;margin-bottom:8px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary);font-weight:400}
    .ai-suggestion:hover{background:var(--border-primary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    .notification{position:fixed;top:80px;right:20px;background:var(--accent-primary);color:#fff;padding:12px 20px;border-radius:8px;box-shadow:0 8px 25px var(--shadow-primary);z-index:10000;transform:translateX(400px);transition:.3s transform;max-width:300px}
    .notification.show{transform:translateX(0)}
    .notification.error{background:#f44336}
    
    .connection-mode{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:15px;z-index:1000;margin-bottom:10px;box-shadow:0 8px 25px var(--shadow-primary)}
    .connection-mode-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 16px;border-radius:6px;cursor:pointer;margin:2px;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .connection-mode-btn:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    .connection-mode-btn.active{background:var(--accent-primary);color:#fff}
    
    .loading{display:inline-block;width:16px;height:16px;border:2px solid transparent;border-top:2px solid currentColor;border-radius:50%;animation:spin 1s linear infinite;margin-right:8px}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
    
    .modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);backdrop-filter:blur(5px);z-index:10000;display:none;align-items:center;justify-content:center}
    .modal-overlay.show{display:flex}
    .modal{background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:12px;padding:30px;min-width:400px;max-width:600px;box-shadow:0 20px 40px var(--shadow-primary)}
    .modal-title{font-size:1.3rem;font-weight:400;margin-bottom:20px;color:var(--text-primary)}
    .modal-input{width:100%;padding:15px;border:1px solid var(--border-secondary);border-radius:8px;background:var(--bg-secondary);color:var(--text-primary);font-size:1rem;margin-bottom:20px;outline:none;transition:border-color 0.3s ease;font-weight:400}
    .modal-input:focus{border-color:var(--accent-primary)}
    .modal-buttons{display:flex;gap:10px;justify-content:flex-end}
    .modal-btn{padding:12px 24px;border:none;border-radius:8px;cursor:pointer;font-size:1rem;transition:all 0.3s ease;box-shadow:0 4px 12px var(--shadow-primary)}
    .modal-btn.primary{background:var(--accent-primary);color:#fff}
    .modal-btn.primary:hover{background:var(--accent-secondary);box-shadow:0 6px 16px var(--shadow-secondary)}
    .modal-btn.secondary{background:var(--border-primary);color:var(--text-primary)}
    .modal-btn.secondary:hover{background:var(--border-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    .recent-colors-popup{position:absolute;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:10px;box-shadow:0 10px 25px var(--shadow-primary);z-index:1000;display:grid;grid-template-columns:repeat(5,1fr);gap:5px;min-width:200px}
    .recent-colors-popup .color-option{width:25px;height:25px;border-radius:4px;cursor:pointer;border:2px solid transparent;transition:all 0.2s ease}
    .recent-colors-popup .color-option:hover{border-color:var(--accent-primary);transform:scale(1.1)}
    
    /* Share section styling */
    .share-section{display:none;margin-top:20px;padding:15px;background:var(--bg-secondary);border-radius:8px;border:1px solid var(--border-secondary);box-shadow:0 2px 8px var(--shadow-primary)}
    .share-section.show{display:block}
    .share-toggle{background:var(--accent-primary);color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:0.9rem;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .share-toggle:hover{background:var(--accent-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    .share-toggle.off{background:var(--border-primary);color:var(--text-primary)}
    .share-toggle.off:hover{background:var(--border-secondary)}
    .share-email{width:100%;padding:8px;border-radius:6px;border:1px solid var(--border-secondary);background:var(--bg-tertiary);color:var(--text-primary);margin-top:10px;font-weight:400}
    .share-btn{margin-top:8px;background:var(--accent-primary);color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;width:100%;transition:all 0.3s ease;box-shadow:0 2px 6px var(--shadow-primary)}
    .share-btn:hover{background:var(--accent-secondary);box-shadow:0 4px 12px var(--shadow-secondary)}
    
    /* Smooth animations for real-time updates */
    .tile-updating{transition:all 0.1s ease-out}
    .connection-updating{transition:all 0.1s ease-out}
    
    /* Browser-like tab interface */
    .tab-container{display:flex;background:var(--bg-secondary);border-bottom:1px solid var(--border-primary);overflow-x:auto;padding:0 20px}
    .tab{background:var(--tab-inactive);color:var(--text-secondary);border:none;padding:12px 20px;cursor:pointer;transition:all 0.3s ease;border-radius:8px 8px 0 0;margin-right:2px;font-weight:400;position:relative;min-width:120px;text-align:center}
    .tab:hover{background:var(--tab-hover);color:var(--text-primary)}
    .tab.active{background:var(--tab-active);color:#fff}
    .tab-close{position:absolute;top:8px;right:8px;background:rgba(255,255,255,0.2);color:inherit;border:none;border-radius:50%;width:16px;height:16px;cursor:pointer;font-size:10px;opacity:0;transition:opacity 0.3s ease}
    .tab:hover .tab-close{opacity:1}
    .tab-close:hover{background:rgba(255,255,255,0.3)}
    
    /* Auto-save indicator */
    .auto-save-indicator{position:fixed;bottom:20px;left:320px;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:8px 12px;box-shadow:0 4px 12px var(--shadow-primary);z-index:1000;font-size:0.8rem;color:var(--text-secondary);transition:all 0.3s ease;opacity:0;transform:translateY(20px)}
    .auto-save-indicator.show{opacity:1;transform:translateY(0)}
    .auto-save-indicator.saving{color:var(--inbox-pending)}
    .auto-save-indicator.saved{color:var(--inbox-accepted)}
    .auto-save-indicator.error{color:var(--inbox-rejected)}
    
    /* Snap to grid and other tiles */
    .snap-indicator{position:absolute;width:2px;height:2px;background:var(--accent-primary);border-radius:50%;pointer-events:none;z-index:1000;opacity:0;transition:opacity 0.2s ease}
    .snap-indicator.show{opacity:1}
    .snap-indicator.grid{background:var(--accent-primary)}
    .snap-indicator.tile{background:var(--inbox-accepted)}
    
    /* Shape palette */
    .shape-palette{position:absolute;top:10px;left:10px;display:grid;grid-template-columns:repeat(3,1fr);gap:4px;opacity:0;transition:opacity 0.3s ease;z-index:1000}
    .tile:hover .shape-palette{opacity:1}
    .shape-option{width:24px;height:24px;border:2px solid var(--border-primary);border-radius:4px;cursor:pointer;transition:all 0.3s ease;background:var(--bg-secondary);display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--text-secondary)}
    .shape-option:hover{transform:scale(1.1);border-color:var(--accent-primary)}
    .shape-option.selected{border-color:var(--accent-primary);background:var(--accent-primary);color:#fff}
    
    /* Different tile shapes */
    .tile.rounded{border-radius:20px}
    .tile.circular{border-radius:50%;min-width:120px;min-height:120px}
    .tile.hexagon{clip-path:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)}
    .tile.diamond{clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)}
    .tile.triangle{clip-path:polygon(50% 0%, 0% 100%, 100% 100%)}
    .tile.parallelogram{clip-path:polygon(25% 0%, 100% 0%, 75% 100%, 0% 100%)}
    
    /* Grid snapping visual feedback */
    .grid-snap-line{position:absolute;background:var(--accent-primary);opacity:0.3;pointer-events:none;z-index:999;transition:opacity 0.2s ease}
    .grid-snap-line.show{opacity:0.6}
    .grid-snap-line.vertical{width:1px}
    .grid-snap-line.horizontal{height:1px}
    
    /* Grid visualization */
    .grid-overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:50;opacity:0.1;transition:opacity 0.3s ease}
    .grid-overlay.show{opacity:0.2}
    .grid-line{position:absolute;background:var(--accent-primary);opacity:0.3}
    .grid-line.vertical{width:1px;height:100%}
    .grid-line.horizontal{height:1px;width:100%}
    
    /* Grid toggle button */
    .tool-btn.grid-toggle-btn{background:var(--accent-primary);color:#fff}
    .tool-btn.grid-toggle-btn:hover{background:var(--accent-secondary)}
    .tool-btn.grid-toggle-btn:not(.active){background:var(--border-primary);color:var(--text-primary)}
    
    /* Floating Toolbar System */
    .floating-toolbar{position:absolute;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.15);padding:8px;display:none;z-index:1000;pointer-events:auto;min-width:200px;transform:translateY(-50%)}
    .floating-toolbar.show{display:block}
    .floating-toolbar.tile-toolbar{min-width:180px;transform:translateY(-50%)}
    .floating-toolbar.connection-toolbar{min-width:160px;transform:translateY(-50%)}
    
    .toolbar-section{display:flex;flex-direction:column;gap:4px;margin-bottom:8px}
    .toolbar-section:last-child{margin-bottom:0}
    .toolbar-section-title{font-size:11px;color:var(--text-secondary);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px;font-weight:500}
    
    .toolbar-row{display:flex;gap:4px;align-items:center}
    .toolbar-button{width:32px;height:32px;border:1px solid var(--border-primary);border-radius:6px;background:var(--bg-primary);color:var(--text-primary);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px;transition:all 0.2s ease}
    .toolbar-button:hover{background:var(--bg-tertiary);border-color:var(--accent-primary)}
    .toolbar-button.active{background:var(--accent-primary);color:#fff;border-color:var(--accent-primary)}
    .toolbar-button.small{width:28px;height:28px;font-size:12px}
    
    .toolbar-color-picker{width:32px;height:32px;border:1px solid var(--border-primary);border-radius:6px;cursor:pointer;position:relative;overflow:hidden}
    .toolbar-color-picker::before{content:'';position:absolute;top:2px;left:2px;right:2px;bottom:2px;background:var(--tile-color, #ffffff);border-radius:4px}
    
    /* Secondary Popup System */
    .secondary-popup{position:absolute;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.15);padding:12px;display:none;z-index:1001;pointer-events:auto;min-width:240px}
    .secondary-popup.show{display:block}
    
    .popup-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border-primary)}
    .popup-title{font-size:14px;font-weight:500;color:var(--text-primary)}
    .popup-close{width:24px;height:24px;border:none;background:none;color:var(--text-secondary);cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;border-radius:4px;transition:all 0.2s ease}
    .popup-close:hover{background:var(--bg-tertiary);color:var(--text-primary)}
    
    .popup-content{display:grid;grid-template-columns:repeat(auto-fit, minmax(40px, 1fr));gap:8px}
    .popup-option{width:40px;height:40px;border:2px solid var(--border-primary);border-radius:6px;cursor:pointer;transition:all 0.2s ease;display:flex;align-items:center;justify-content:center;font-size:16px;background:var(--bg-primary)}
    .popup-option:hover{transform:scale(1.05);border-color:var(--accent-primary)}
    .popup-option.selected{border-color:var(--accent-primary);background:var(--accent-primary);color:#fff}
    
    /* Improved Line Routing */
    .connection-line{stroke:var(--connection-color, #007AFF);stroke-width:2;fill:none;cursor:pointer;transition:all 0.2s ease}
    .connection-line:hover{stroke-width:3;stroke:var(--connection-hover-color, #0056CC)}
    .connection-line.selected{stroke-width:3;stroke:var(--accent-primary);stroke-dasharray:5,5}
    
    /* Line Style Options */
    .line-style-solid{stroke-dasharray: none}
    .line-style-dashed{stroke-dasharray: 5,5}
    .line-style-dotted{stroke-dasharray: 2,2}
    .line-style-dash-dot{stroke-dasharray: 10,2,2,2}
    
    /* Connection Types */
    .connection-type-arrow{marker-end: url(#arrowhead)}
    .connection-type-line{marker-end: none}
    .connection-type-dot{marker-end: url(#dotmarker)}
    .connection-type-diamond{marker-end: url(#diamondmarker)}
    
    /* Remove old tile controls */
    .tile .color-picker-trigger{display:none}
    .tile .shape-palette{display:none}
    .tile .connection-dot{display:none}
    
    /* Preset Tile Types */
    .preset-tile{position:relative;cursor:pointer;transition:all 0.3s ease}
    .preset-tile:hover{transform:scale(1.05)}
    .preset-tile.selected{transform:scale(1.1);box-shadow:0 0 20px var(--accent-primary)}
    
    .preset-tile.title{background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:#fff;border-radius:12px}
    .preset-tile.notes{background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%);color:#fff;border-radius:12px}
    .preset-tile.component{background:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);color:#fff;border-radius:12px}
    .preset-tile.custom{background:linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);color:#fff;border-radius:12px}
    
    .preset-tile-icon{font-size:24px;margin-bottom:8px}
    .preset-tile-label{font-size:12px;font-weight:500;text-align:center}
    
    /* Improved Toolbar Positioning */
    .floating-toolbar{position:absolute;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.15);padding:8px;display:none;z-index:1000;pointer-events:auto;min-width:200px;transform:translateY(-50%)}
    .floating-toolbar.show{display:block}
    .floating-toolbar.tile-toolbar{min-width:180px;transform:translateY(-50%)}
    .floating-toolbar.connection-toolbar{min-width:160px;transform:translateY(-50%)}
    
    /* Long Press Indicator */
    .long-press-indicator{position:absolute;width:60px;height:60px;border:3px solid var(--accent-primary);border-radius:50%;pointer-events:none;z-index:1001;opacity:0;transition:all 0.3s ease;display:flex;align-items:center;justify-content:center;color:var(--accent-primary);font-size:20px;background:rgba(0,122,255,0.1)}
    .long-press-indicator.show{opacity:1;transform:scale(1.2)}
    .long-press-indicator.pulse{animation:pulse 1s infinite}
    
    @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}
    
    /* Preset Selection Popup */
    .preset-popup{position:absolute;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.2);padding:16px;display:none;z-index:1002;pointer-events:auto;min-width:280px}
    .preset-popup.show{display:block}
    
    .preset-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:12px}
    .preset-item{display:flex;flex-direction:column;align-items:center;padding:16px;border:2px solid var(--border-primary);border-radius:8px;cursor:pointer;transition:all 0.3s ease;background:var(--bg-primary)}
    .preset-item:hover{transform:translateY(-2px);border-color:var(--accent-primary);box-shadow:0 4px 15px rgba(0,122,255,0.2)}
    .preset-item.selected{border-color:var(--accent-primary);background:rgba(0,122,255,0.1)}
    
    .preset-item-icon{font-size:32px;margin-bottom:8px}
    .preset-item-label{font-size:14px;font-weight:500;color:var(--text-primary);text-align:center}
    .preset-item-desc{font-size:11px;color:var(--text-secondary);text-align:center;margin-top:4px}
    
    /* Add CSS for preset buttons */
    .tool-btn.preset-btn {
      background: var(--accent-primary);
      color: #fff;
      transition: all 0.3s ease;
    }
    .tool-btn.preset-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    
    /* Sharing Permission System */
    .share-permission-selector{display:flex;gap:8px;margin-bottom:12px;align-items:center}
    .permission-option{display:flex;align-items:center;gap:6px;padding:8px 12px;border:2px solid var(--border-primary);border-radius:6px;cursor:pointer;transition:all 0.3s ease;background:var(--bg-primary)}
    .permission-option:hover{border-color:var(--accent-primary);background:var(--bg-tertiary)}
    .permission-option.selected{border-color:var(--accent-primary);background:var(--accent-primary);color:#fff}
    .permission-option input[type="radio"]{display:none}
    .permission-icon{font-size:16px}
    .permission-label{font-size:14px;font-weight:500}
    .permission-description{font-size:11px;color:var(--text-secondary);margin-top:2px}
    
    .share-section{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:8px;padding:16px;margin-top:16px;display:none}
    .share-section.show{display:block}
    .share-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
    .share-title{font-size:16px;font-weight:500;color:var(--text-primary)}
    .share-toggle{background:var(--accent-primary);color:#fff;border:none;border-radius:6px;padding:8px 16px;cursor:pointer;font-size:14px;transition:all 0.3s ease}
    .share-toggle:hover{background:var(--accent-secondary)}
    .share-toggle.active{background:var(--inbox-pending)}
    
    .share-email-section{display:flex;gap:8px;margin-bottom:12px}
    .share-email{flex:1;padding:8px 12px;border:1px solid var(--border-primary);border-radius:6px;background:var(--bg-primary);color:var(--text-primary);font-size:14px}
    .share-email:focus{outline:none;border-color:var(--accent-primary)}
    .share-btn{background:var(--accent-primary);color:#fff;border:none;border-radius:6px;padding:8px 16px;cursor:pointer;font-size:14px;transition:all 0.3s ease}
    .share-btn:hover{background:var(--accent-secondary)}
    .share-btn:disabled{background:var(--border-primary);color:var(--text-secondary);cursor:not-allowed}
    
    .shared-users-list{margin-top:16px}
    .shared-user-item{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:6px;margin-bottom:8px}
    .shared-user-info{display:flex;flex-direction:column}
    .shared-user-email{font-size:14px;color:var(--text-primary);font-weight:500}
    .shared-user-permission{font-size:12px;color:var(--text-secondary)}
    .shared-user-actions{display:flex;gap:4px}
    .remove-user-btn{background:var(--inbox-rejected);color:#fff;border:none;border-radius:4px;padding:4px 8px;cursor:pointer;font-size:12px;transition:all 0.3s ease}
    .remove-user-btn:hover{background:var(--accent-secondary)}
    .change-permission-btn{background:var(--accent-primary);color:#fff;border:none;border-radius:4px;padding:4px 8px;cursor:pointer;font-size:12px;transition:all 0.3s ease}
    .change-permission-btn:hover{background:var(--accent-secondary)}

    /* Delete Confirmation Modal */
    .modal.danger .modal-title {
      color: #dc3545;
    }

    .modal.danger .modal-btn.danger {
      background: #dc3545;
      color: white;
      border-color: #dc3545;
    }

    .modal.danger .modal-btn.danger:hover {
      background: #c82333;
      border-color: #bd2130;
    }

    .warning-text {
      color: #dc3545;
      font-weight: 500;
      margin-top: 8px;
    }

    /* Grid and Snap Fixes */
    /* Keep layers sensible */
    #connections-svg{ z-index:5 }
    .tile{ z-index:10 }
    .floating-toolbar{ z-index:11000 }       /* above tiles */
    .popover{ position:fixed; z-index:99999; background:var(--bg-tertiary);
      border:1px solid var(--border-primary); border-radius:10px; box-shadow:0 12px 30px var(--shadow-primary);
      padding:10px; pointer-events:auto; backdrop-filter:blur(20px); min-width:200px }
    .modal-overlay{ z-index:120000 }          /* over everything */
    .notification{ z-index:130000 }           /* toast wins */
    
    /* Ensure canvas and other elements don't interfere with popups */
    .canvas-container{ z-index:1 }
    .canvas{ z-index:1 }
    .tab-container{ z-index:2 }
    
    /* Additional popup styling to ensure they're visible */
    .popover {
      position: fixed !important;
      z-index: 99999 !important;
      background: var(--bg-tertiary) !important;
      border: 1px solid var(--border-primary) !important;
      border-radius: 10px !important;
      box-shadow: 0 12px 30px var(--shadow-primary) !important;
      padding: 10px !important;
      pointer-events: auto !important;
      backdrop-filter: blur(20px) !important;
      min-width: 200px !important;
      max-width: 90vw !important;
      max-height: 90vh !important;
      overflow: auto !important;
    }
    
    /* Ensure color picker popup is visible */
    .color-picker-popout {
      z-index: 99999 !important;
      position: fixed !important;
    }
    
    /* Ensure floating toolbar is visible */
    .floating-toolbar {
      z-index: 99999 !important;
      position: fixed !important;
    }
    
    /* Ensure all modals and overlays are on top */
    .modal, .modal-overlay, .notification {
      z-index: 99999 !important;
      position: fixed !important;
    }
    
    /* Ensure color picker grid is visible */
    .color-picker-grid, .color-picker-recent-grid {
      z-index: 99999 !important;
    }
    
    /* Ensure popup options are visible */
    .popup-option, .popup-content {
      z-index: 99999 !important;
    }
    
    /* Additional popup visibility fixes */
    .popover * {
      z-index: inherit !important;
    }
    
    /* Ensure color picker options are visible */
    .color-picker-option {
      z-index: 99999 !important;
      position: relative !important;
    }
    
    /* Force popups to be above everything */
    .popover, .color-picker-popout, .floating-toolbar {
      position: fixed !important;
      z-index: 99999 !important;
      pointer-events: auto !important;
      background: var(--bg-tertiary) !important;
      border: 1px solid var(--border-primary) !important;
      box-shadow: 0 12px 30px var(--shadow-primary) !important;
    }
    
    /* Specific styling for floating toolbar */
    .floating-toolbar {
      background: var(--bg-secondary) !important;
      border: 2px solid var(--accent-primary) !important;
      border-radius: 12px !important;
      padding: 8px !important;
      min-width: 120px !important;
      box-shadow: 0 8px 25px rgba(0,0,0,0.3) !important;
    }
    
    .floating-toolbar .toolbar-button {
      background: var(--bg-tertiary) !important;
      border: 1px solid var(--border-primary) !important;
      border-radius: 6px !important;
      padding: 8px !important;
      margin: 2px !important;
      cursor: pointer !important;
      font-size: 16px !important;
      transition: all 0.2s ease !important;
    }
    
    .floating-toolbar .toolbar-button:hover {
      background: var(--accent-primary) !important;
      color: white !important;
      transform: scale(1.1) !important;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">Flowpad</div>
    <div class="user-info">
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <span id="theme-icon">🌙</span>
      </button>
      <span id="userName">User</span>
      <button class="signout-btn" onclick="signOut()">Sign Out</button>
    </div>
  </div>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-content">
      <button class="new-graph-btn" onclick="createNewGraph()">+ New Graph</button>
      
      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('myGraphs')">
          <span><span class="folder-icon">📁</span>My Graphs</span>
          <span class="folder-arrow">▶</span>
        </div>
        <div class="folder-content expanded" id="myGraphs">
      <div id="ownGraphs"></div>
        </div>
      </div>
      
      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('sharedGraphs')">
          <span><span class="folder-icon">👥</span>Shared With Me</span>
          <span class="folder-arrow">▶</span>
        </div>
        <div class="folder-content" id="sharedGraphs">
          <div id="sharedGraphsContent"></div>
        </div>
      </div>
      
      <div class="folder-section">
        <div class="folder-header" onclick="toggleFolder('inbox')">
          <span><span class="folder-icon">📥</span>Inbox</span>
          <span class="folder-arrow">▶</span>
        </div>
        <div class="folder-content" id="inbox">
          <div id="inboxContent"></div>
        </div>
      </div>
      
      <div class="share-section" id="shareSection">
        <div class="share-header">
          <div class="share-title">Share Graph</div>
          <button class="share-toggle" onclick="toggleShareSection()">Hide</button>
        </div>
        
        <div class="share-permission-selector">
          <label class="permission-option" data-permission="viewer">
            <input type="radio" name="permission" value="viewer" checked>
            <div class="permission-icon">👁️</div>
            <div class="permission-info">
              <div class="permission-label">Viewer</div>
              <div class="permission-description">Can view only</div>
            </div>
          </label>
          <label class="permission-option" data-permission="editor">
            <input type="radio" name="permission" value="editor">
            <div class="permission-icon">✏️</div>
            <div class="permission-info">
              <div class="permission-label">Editor</div>
              <div class="permission-description">Can view and edit</div>
            </div>
          </label>
        </div>
        
        <div class="share-email-section">
          <input type="email" class="share-email" id="shareEmail" placeholder="Enter email address" />
          <button class="share-btn" onclick="shareGraph()">Share</button>
        </div>
        
        <div class="shared-users-list" id="sharedUsersList">
          <!-- Shared users will be populated here -->
        </div>
      </div>
    </div>
  </div>
  
  <div class="canvas-container">
    <div class="tab-container" id="tabContainer">
      <!-- Tabs will be dynamically added here -->
    </div>
    <div class="canvas" id="canvas"></div>
  </div>
  
  <div class="connection-mode" id="connectionMode" style="display:none;">
    <div style="color:var(--text-secondary);font-size:0.8rem;margin-bottom:8px;text-align:center;">Connection Mode</div>
    <button class="connection-mode-btn" onclick="setConnectionMode('none')" id="modeNone">Select</button>
    <button class="connection-mode-btn active" onclick="setConnectionMode('connect')" id="modeConnect">Connect</button>
  </div>
  
  <div class="toolbar" id="toolbar" style="display:none;">
    <div class="tool-label">Tools</div>
    <button class="tool-btn" onclick="addTile()" title="Add Tile">+</button>
    <button class="tool-btn" onclick="deleteSelected()" title="Delete Selected">DEL</button>
    <button class="tool-btn" onclick="centerCanvas()" title="Center Canvas">⌂</button>
    <button class="tool-btn" onclick="toggleAIPanel()" title="AI Suggestions">AI</button>
  </div>
  
  <div class="ai-panel" id="aiPanel">
    <div class="ai-title">AI Suggestions</div>
    <textarea class="ai-input" id="aiInput" placeholder="Describe what you want to add or connect..."></textarea>
    <button class="ai-btn" onclick="getAISuggestions()" id="aiBtn">
      <span id="aiBtnText">Get Suggestions</span>
    </button>
    <div class="ai-suggestions" id="aiSuggestions"></div>
  </div>
  
  <div id="notification" class="notification"></div>

  <!-- Collaborative Users List -->
  <div class="collaborators-list" id="collaboratorsList">
    <div class="collaborators-header">
      <span class="collaborators-title">Collaborators</span>
      <span class="collaborators-count" id="collaboratorsCount">0</span>
    </div>
    <div id="collaboratorsContent"></div>
  </div>

  <!-- Auto-save Indicator -->
  <div class="auto-save-indicator" id="autoSaveIndicator">
    <span id="autoSaveText">Ready</span>
  </div>

  <!-- New Graph Modal -->
  <div class="modal-overlay" id="newGraphModal">
    <div class="modal">
      <div class="modal-title">Create New Graph</div>
      <input type="text" class="modal-input" id="newGraphTitle" placeholder="Enter graph title..." maxlength="100">
      <div class="modal-buttons">
        <button class="modal-btn secondary" onclick="closeNewGraphModal()">Cancel</button>
        <button class="modal-btn primary" onclick="confirmNewGraph()">Create</button>
      </div>
    </div>
  </div>

  <svg style="position:absolute;width:0;height:0;pointer-events:none">
        <defs>
      <marker id="arrowhead" markerWidth="12" markerHeight="8" refX="10" refY="4" orient="auto">
        <polygon points="0 0, 12 4, 0 8" fill="var(--accent-primary)"></polygon>
          </marker>
        </defs>
      </svg>

  <script>
    let currentUser = null, currentGraph = null, tiles = [], connections = [], selectedTile = null, isDragging = false, dragOffset = {x: 0, y: 0};
    let connectionMode = 'connect';
    let isConnecting = false;
    let connectionStart = null;
    let hoveredTile = null;
    let isPanning = false;
    let panStart = {x: 0, y: 0};
    let canvasOffset = {x: 0, y: 0};
    let openTabs = [];
    let activeTabId = null;
    let realtimeUpdateTimer = null;
    let pendingUpdates = [];
    let autoSaveTimer = null;
    let lastSaveTime = 0;
    let isDirty = false;
    let snapToGrid = true;
    let snapToTiles = true;
    let gridSize = 20;
    let showGrid = false;
    let snapIndicators = [];
    let snapLines = [];
    let gridLines = [];
    
    // === Generic popover utilities ==============================================
    function getRect(target){
      if (!target) return {left:0, top:0, width:0, height:0};
      if (target.getBoundingClientRect) return target.getBoundingClientRect();
      // allow passing a plain rect
      return target;
    }

    /**
     * openPopover(triggerElOrRect, htmlOrEl, opts)
     * Places a .popover near the trigger, keeps it inside the viewport,
     * and repositions on scroll/resize. Returns {el, close, updatePosition}.
     */
    function openPopover(trigger, content, opts={}){
      const {prefer='bottom', offset=8, className='', autoClose=true} = opts;
      const pop = document.createElement('div');
      pop.className = `popover ${className}`.trim();

      if (typeof content === 'string'){ pop.innerHTML = content; }
      else if (content instanceof Element){ pop.appendChild(content); }

      document.body.appendChild(pop);

      function place(){
        const tr = getRect(trigger);
        const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        const pr = pop.getBoundingClientRect();

        // Try to center the popup in the viewport first
        let x = (vw - pr.width) / 2;
        let y = (vh - pr.height) / 2;
        
        // If centering would make it go off-screen, fall back to smart positioning
        if (x < 8 || y < 8 || (x + pr.width) > (vw - 8) || (y + pr.height) > (vh - 8)) {
          // candidate positions (x,y) in viewport coords
          const cand = {
            bottom: { x: tr.left + tr.width/2 - pr.width/2, y: tr.bottom + offset },
            top:    { x: tr.left + tr.width/2 - pr.width/2, y: tr.top - pr.height - offset },
            right:  { x: tr.right + offset,                 y: tr.top + tr.height/2 - pr.height/2 },
            left:   { x: tr.left - pr.width - offset,       y: tr.top + tr.height/2 - pr.height/2 },
          };

          // try prefer, then fallbacks
          const order = [prefer, 'bottom','top','right','left'].filter((v,i,a)=>a.indexOf(v)===i);
          let best = cand[order[0]];
          for (const key of order){
            const p = cand[key];
            const fits = p.x >= 8 && p.y >= 8 && (p.x+pr.width) <= (vw-8) && (p.y+pr.height) <= (vh-8);
            if (fits){ best = p; break; }
          }
          x = best.x;
          y = best.y;
        }
        
        // clamp to viewport with small padding
        const pad = 8;
        x = Math.min(Math.max(x, pad), vw - pr.width - pad);
        y = Math.min(Math.max(y, pad), vh - pr.height - pad);

        // fixed positioning uses viewport coords (no scroll math needed)
        pop.style.left = `${Math.round(x)}px`;
        pop.style.top  = `${Math.round(y)}px`;
      }

      const onScroll = () => place();
      const onResize = () => place();
      const onKey = (e)=>{ if (e.key === 'Escape') close(); };
      const onClickAway = (e)=>{ if (!pop.contains(e.target)) close(); };

      function close(){
        window.removeEventListener('scroll', onScroll, true);
        window.removeEventListener('resize', onResize);
        window.removeEventListener('keydown', onKey);
        document.removeEventListener('mousedown', onClickAway, true);
        pop.remove();
      }

      window.addEventListener('scroll', onScroll, true);
      window.addEventListener('resize', onResize);
      window.addEventListener('keydown', onKey);
      document.addEventListener('mousedown', onClickAway, true);

      // Auto-close after a delay if specified
      if (autoClose) {
        setTimeout(() => {
          if (pop.parentNode) {
            close();
          }
        }, 10000); // Auto-close after 10 seconds
      }

      // initial place after append so size is known
      place();
      return { el: pop, close, updatePosition: place };
    }
    
    const canvas = document.getElementById('canvas');
    const tabContainer = document.getElementById('tabContainer');

    document.addEventListener('DOMContentLoaded', init);

    async function init() {
      await checkAuth();
      await loadGraphs();
      await loadInbox();
      setupCanvas();
      setupTheme();
      setupRealtimeUpdates();
      setupAutoSave();
      setupSnapping();
      setupGridVisualization();
      initializePermissionSelector();
      addShareEmailListener();
    }

    // Add share email input listener for real-time validation
    function addShareEmailListener() {
      const shareEmail = document.getElementById('shareEmail');
      if (shareEmail) {
        shareEmail.addEventListener('input', () => {
          updateShareButtonState();
        });
      }
    }

    function setupGridVisualization() {
      // Check if grid overlay already exists
      let gridOverlay = document.getElementById('grid-overlay');
      if (!gridOverlay) {
        // Create grid overlay only if it doesn't exist
        gridOverlay = document.createElement('div');
        gridOverlay.className = 'grid-overlay';
        gridOverlay.id = 'grid-overlay';
        canvas.appendChild(gridOverlay);
      }
      
      // Create grid lines
      createGridLines();
      
      // Update grid when canvas resizes
      window.addEventListener('resize', createGridLines);
    }

    function createGridLines() {
      // Clear existing grid lines
      gridLines.forEach(line => line.remove());
      gridLines = [];
      
      const gridOverlay = document.getElementById('grid-overlay');
      if (!gridOverlay) return;
      
      const canvasRect = canvas.getBoundingClientRect();
      const width = canvasRect.width;
      const height = canvasRect.height;
      
      // Create vertical grid lines
      for (let x = 0; x <= width; x += gridSize) {
        const line = document.createElement('div');
        line.className = 'grid-line vertical';
        line.style.left = x + 'px';
        gridOverlay.appendChild(line);
        gridLines.push(line);
      }
      
      // Create horizontal grid lines
      for (let y = 0; y <= height; y += gridSize) {
        const line = document.createElement('div');
        line.className = 'grid-line horizontal';
        line.style.top = y + 'px';
        gridOverlay.appendChild(line);
        gridLines.push(line);
      }
    }

    function toggleGrid() {
      showGrid = !showGrid;
      const gridOverlay = document.getElementById('grid-overlay');
      const btn = document.querySelector('.grid-toggle-btn');
      
      if (gridOverlay) {
        gridOverlay.classList.toggle('show', showGrid);
      }
      
      if (btn) {
        btn.classList.toggle('active', showGrid);
        btn.title = showGrid ? 'Hide Grid (ON)' : 'Show Grid (OFF)';
      }
      
      notify(`Grid: ${showGrid ? 'ON' : 'OFF'}`, 'success');
    }

    function setupSnapping() {
      // Check if snap indicators already exist
      if (snapIndicators.length === 0) {
        // Create snap indicators only if they don't exist
        for (let i = 0; i < 10; i++) {
          const indicator = document.createElement('div');
          indicator.className = 'snap-indicator';
          indicator.id = `snap-indicator-${i}`;
          canvas.appendChild(indicator);
          snapIndicators.push(indicator);
        }
      }
      
      // Check if snap lines already exist
      if (snapLines.length === 0) {
        // Create snap lines only if they don't exist
        for (let i = 0; i < 6; i++) {
          const line = document.createElement('div');
          line.className = 'grid-snap-line';
          line.id = `snap-line-${i}`;
          canvas.appendChild(line);
          snapLines.push(line);
        }
      }
    }

    function getSnapPosition(x, y) {
      let snappedX = x;
      let snappedY = y;
      let snapDistance = 10; // Distance within which to snap
      
      // Snap to grid
      if (snapToGrid) {
        const gridX = Math.round(x / gridSize) * gridSize;
        const gridY = Math.round(y / gridSize) * gridSize;
        
        if (Math.abs(x - gridX) < snapDistance) {
          snappedX = gridX;
          showSnapIndicator(gridX, y, 'grid');
        }
        if (Math.abs(y - gridY) < snapDistance) {
          snappedY = gridY;
          showSnapIndicator(x, gridY, 'grid');
        }
      }
      
      // Snap to other tiles
      if (snapToTiles) {
        tiles.forEach(tile => {
          if (tile === selectedTile) return;
          
          const tileRect = tile.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          const tileX = tileRect.left - canvasRect.left;
          const tileY = tileRect.top - canvasRect.top;
          const tileWidth = tileRect.width;
          const tileHeight = tileRect.height;
          
          // Snap to tile edges
          const edges = [
            { x: tileX, y: y, type: 'left' },
            { x: tileX + tileWidth, y: y, type: 'right' },
            { x: x, y: tileY, type: 'top' },
            { x: x, y: tileY + tileHeight, type: 'bottom' }
          ];
          
          edges.forEach(edge => {
            if (Math.abs(x - edge.x) < snapDistance) {
              snappedX = edge.x;
              showSnapIndicator(edge.x, y, 'tile');
              showSnapLine(edge.x, 'vertical');
            }
            if (Math.abs(y - edge.y) < snapDistance) {
              snappedY = edge.y;
              showSnapIndicator(x, edge.y, 'tile');
              showSnapLine(edge.y, 'horizontal');
            }
          });
          
          // Snap to tile center
          const centerX = tileX + tileWidth / 2;
          const centerY = tileY + tileHeight / 2;
          
          if (Math.abs(x - centerX) < snapDistance) {
            snappedX = centerX;
            showSnapIndicator(centerX, y, 'tile');
          }
          if (Math.abs(y - centerY) < snapDistance) {
            snappedY = centerY;
            showSnapIndicator(x, centerY, 'tile');
          }
        });
      }
      
      return { x: snappedX, y: snappedY };
    }

    function showSnapIndicator(x, y, type) {
      const indicator = snapIndicators.find(ind => !ind.classList.contains('show'));
      if (indicator) {
        indicator.style.left = (x + canvasOffset.x) + 'px';
        indicator.style.top = (y + canvasOffset.y) + 'px';
        indicator.className = `snap-indicator show ${type}`;
        
        // Hide after a short time
        setTimeout(() => {
          indicator.classList.remove('show');
        }, 200);
      }
    }

    function showSnapLine(position, orientation) {
      const line = snapLines.find(l => !l.classList.contains('show'));
      if (line) {
        if (orientation === 'vertical') {
          line.style.left = (position + canvasOffset.x) + 'px';
          line.style.top = '0px';
          line.style.height = '100%';
          line.className = 'grid-snap-line show vertical';
        } else {
          line.style.top = (position + canvasOffset.y) + 'px';
          line.style.left = '0px';
          line.style.width = '100%';
          line.className = 'grid-snap-line show horizontal';
        }
        
        // Hide after a short time
        setTimeout(() => {
          line.classList.remove('show');
        }, 300);
      }
    }

    function clearSnapIndicators() {
      snapIndicators.forEach(ind => ind.classList.remove('show'));
      snapLines.forEach(line => line.classList.remove('show'));
    }

    function setupAutoSave() {
      // Set up automatic saving every 15 seconds
      autoSaveTimer = setInterval(() => {
        if (isDirty && currentGraph && Date.now() - lastSaveTime > 15000) {
          autoSaveGraph();
        }
      }, 15000);
    }

    function setupRealtimeUpdates() {
      // Set up real-time updates every 2 seconds
      setInterval(() => {
        if (pendingUpdates.length > 0 && currentGraph) {
          sendRealtimeUpdates();
        }
      }, 2000);
    }

    function markAsDirty() {
      isDirty = true;
      lastSaveTime = Date.now();
    }

    async function autoSaveGraph() {
      if (!currentGraph || !isDirty) return;
      
      const indicator = document.getElementById('autoSaveIndicator');
      const text = document.getElementById('autoSaveText');
      
      try {
        // Show saving indicator
        indicator.classList.add('show', 'saving');
        text.textContent = 'Saving...';
        
        const token = localStorage.getItem('flowpad_token');
        const data = {
          tiles: tiles.map(t => ({
            id: t.dataset.tileId,
            x: parseInt(t.dataset.baseX) || 0,
            y: parseInt(t.dataset.baseY) || 0,
            title: t.querySelector('.tile-title').value || '',
            content: t.querySelector('.tile-content').value || '',
            color: t.style.background || '#ffffff'
          })),
          connections: connections
        };
        
        const res = await fetch(`/api/graphs/${currentGraph.id}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ title: currentGraph.title, data })
        });
        
        if (res.ok) {
          isDirty = false;
          lastSaveTime = Date.now();
          
          // Show saved indicator
          indicator.classList.remove('saving');
          indicator.classList.add('saved');
          text.textContent = `Saved at ${new Date().toLocaleTimeString()}`;
          
          // Hide after 3 seconds
          setTimeout(() => {
            indicator.classList.remove('show', 'saved');
          }, 3000);
          
          console.log('Auto-saved graph successfully');
        } else {
          throw new Error('Save failed');
        }
      } catch (error) {
        console.error('Auto-save failed:', error);
        
        // Show error indicator
        indicator.classList.remove('saving');
        indicator.classList.add('error');
        text.textContent = 'Save failed';
        
        // Hide after 5 seconds
        setTimeout(() => {
          indicator.classList.remove('show', 'error');
        }, 5000);
      }
    }

    function scheduleSave() {
      markAsDirty();
      // Debounced save - only save after 500ms of inactivity
      clearTimeout(window.saveTimeout);
      window.saveTimeout = setTimeout(() => {
        if (isDirty) {
          autoSaveGraph();
        }
      }, 500);
    }

    function setupTheme() {
      const savedTheme = localStorage.getItem('flowpad_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      updateThemeIcon(savedTheme);
      
      // Apply tile colors for the current theme if tiles exist
      if (tiles.length > 0) {
        updateTileColorsForTheme(savedTheme);
      }
    }

    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('flowpad_theme', newTheme);
      updateThemeIcon(newTheme);
      
      // Update tile colors for the new theme
      updateTileColorsForTheme(newTheme);
    }

    function updateThemeIcon(theme) {
      const icon = document.getElementById('theme-icon');
      icon.textContent = theme === 'dark' ? '🌙' : '☀️';
    }

    function toggleFolder(folderId) {
      const folder = document.getElementById(folderId);
      const header = folder.previousElementSibling;
      const arrow = header.querySelector('.folder-arrow');
      
      folder.classList.toggle('expanded');
      arrow.classList.toggle('expanded');
      header.classList.toggle('active');
    }

    function toggleShareSection() {
      const section = document.getElementById('shareSection');
      const btn = section.querySelector('.share-toggle');
      const visible = section.classList.toggle('show');
      btn.textContent = visible ? 'Hide' : 'Show';
    }

    function toggleSharing() {
      const toggle = document.querySelector('.share-toggle');
      const email = document.getElementById('shareEmail');
      const shareBtn = document.querySelector('.share-btn');
      
      if (toggle.textContent === 'ON') {
        toggle.textContent = 'OFF';
        toggle.classList.add('off');
        email.style.display = 'none';
        shareBtn.style.display = 'none';
        // Turn off sharing
        if (currentGraph) {
          currentGraph.sharingEnabled = false;
        }
      } else {
        toggle.textContent = 'ON';
        toggle.classList.remove('off');
        email.style.display = 'block';
        shareBtn.style.display = 'block';
        // Turn on sharing
        if (currentGraph) {
          currentGraph.sharingEnabled = true;
        }
      }
    }

    function createTab(graph) {
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.dataset.graphId = graph.id;
      tab.innerHTML = `
        ${graph.title || 'Untitled Graph'}
        <button class="tab-close" title="Close tab">×</button>
      `;
      
      // Add click handler for tab selection
      tab.addEventListener('click', (e) => {
        if (!e.target.classList.contains('tab-close')) {
          if (graph.id !== activeTabId) {
            switchToTab(graph.id);
          }
        }
      });
      
      // Add click handler for close button
      const closeBtn = tab.querySelector('.tab-close');
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent tab selection
        closeTab(graph.id);
      });
      
      openTabs.push({ id: graph.id, element: tab, graph: graph });
      tabContainer.appendChild(tab);
      
      return tab;
    }

    function closeTab(graphId) {
      const tabIndex = openTabs.findIndex(tab => tab.id === graphId);
      if (tabIndex === -1) return;
      
      const tab = openTabs[tabIndex];
      tab.element.remove();
      openTabs.splice(tabIndex, 1);
      
      if (activeTabId === graphId) {
        if (openTabs.length > 0) {
          switchToTab(openTabs[0].id);
        } else {
          // No tabs left, show empty state
          activeTabId = null;
          currentGraph = null;
          tiles = [];
          connections = [];
          renderCanvas();
          document.getElementById('shareSection').style.display = 'none';
        }
      }
    }

    function switchToTab(graphId) {
      const tab = openTabs.find(t => t.id === graphId);
      if (!tab) return;
      
      // Update active tab styling
      openTabs.forEach(t => t.element.classList.remove('active'));
      tab.element.classList.add('active');
      activeTabId = graphId;
      
      // Load the graph but skip tab switching to prevent recursion
      loadGraph(tab.graph, true);
      
      // Auto-scroll to center the graph
      centerCanvas();
    }

    async function loadInbox() {
      const token = localStorage.getItem('flowpad_token');
      try {
        const res = await fetch('/api/graphs/inbox', { headers: { Authorization: `Bearer ${token}` } });
        if (res.ok) {
          const inboxItems = await res.json();
          renderInbox(inboxItems);
        }
      } catch (error) {
        console.error('Failed to load inbox:', error);
      }
    }

    function renderInbox(inboxItems) {
      const container = document.getElementById('inboxContent');
      container.innerHTML = '';
      
      if (inboxItems.length === 0) {
        container.innerHTML = '<div style="text-align:center;color:var(--text-secondary);padding:20px;">No pending invitations</div>';
        return;
      }
      
      inboxItems.forEach(item => {
        const inboxItem = document.createElement('div');
        inboxItem.className = `inbox-item ${item.status}`;
        
        inboxItem.innerHTML = `
          <div class="inbox-title">${item.graphTitle}</div>
          <div class="inbox-meta">From: ${item.sharerName} • ${new Date(item.sharedAt).toLocaleString()}</div>
          ${item.status === 'pending' ? `
            <div class="inbox-actions">
              <button class="inbox-btn accept" onclick="respondToInvitation('${item.id}', 'accept')">Accept</button>
              <button class="inbox-btn reject" onclick="respondToInvitation('${item.id}', 'reject')">Reject</button>
            </div>
          ` : ''}
        `;
        
        container.appendChild(inboxItem);
      });
    }

    async function respondToInvitation(invitationId, response) {
      const token = localStorage.getItem('flowpad_token');
      try {
        const res = await fetch(`/api/graphs/inbox/${invitationId}/${response}`, { 
          method: 'POST', 
          headers: { Authorization: `Bearer ${token}` } 
        });
        
        if (res.ok) {
          notify(`Invitation ${response}ed successfully`, 'success');
          await loadInbox(); // Refresh inbox
          if (response === 'accept') {
            await loadGraphs(); // Refresh graphs list
          }
        } else {
          notify(`Failed to ${response} invitation`, 'error');
        }
      } catch (error) {
        notify(`Failed to ${response} invitation: ${error.message}`, 'error');
      }
    }

    function deleteGraph(graphId) {
      // Show custom delete confirmation modal
      showDeleteConfirmation(graphId);
    }

    function showDeleteConfirmation(graphId) {
      // Create modal if it doesn't exist
      let modal = document.getElementById('deleteConfirmModal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'deleteConfirmModal';
        modal.className = 'modal danger';
        modal.innerHTML = `
          <div class="modal-content">
            <div class="modal-title danger">Delete Graph</div>
            <div class="modal-body">
              <p>Are you sure you want to delete this graph?</p>
              <p class="warning-text">This action cannot be undone.</p>
            </div>
            <div class="modal-actions">
              <button class="modal-btn secondary" onclick="closeDeleteConfirmation()">Cancel</button>
              <button class="modal-btn danger" id="confirmDeleteBtn">Delete</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }
      
      // Set up delete confirmation
      const confirmBtn = modal.querySelector('#confirmDeleteBtn');
      confirmBtn.onclick = () => confirmDeleteGraph(graphId);
      
      // Show modal
      modal.classList.add('show');
    }

    function closeDeleteConfirmation() {
      const modal = document.getElementById('deleteConfirmModal');
      if (modal) {
        modal.classList.remove('show');
      }
    }

    async function confirmDeleteGraph(graphId) {
      try {
        const token = localStorage.getItem('flowpad_token');
        const res = await fetch(`/api/graphs/${graphId}`, {
          method: 'DELETE',
          headers: { Authorization: `Bearer ${token}` }
        });
        
        if (!res.ok) {
          notify('Failed to delete graph', 'error');
          return;
        }
        
        // Remove from UI after successful API call
        const graphElement = document.querySelector(`[data-graph-id="${graphId}"]`);
        if (graphElement) {
          graphElement.remove();
        }
        
        // Close tab if open
        if (openTabs.find(tab => tab.id === graphId)) {
          closeTab(graphId);
        }
        
        // Remove from arrays
        if (currentGraph && currentGraph.id === graphId) {
          currentGraph = null;
          tiles = [];
          connections = [];
          renderCanvas();
          document.getElementById('shareSection').style.display = 'none';
        }
        
        notify('Graph deleted successfully', 'success');
        
        // Refresh graphs list
      await loadGraphs();
        
      } catch (error) {
        console.error('Error deleting graph:', error);
        notify('Failed to delete graph', 'error');
      }
      
      // Close modal
      closeDeleteConfirmation();
    }

    function renderGraphList(list, id) {
      const container = id === 'sharedGraphs' ? document.getElementById('sharedGraphsContent') : document.getElementById(id);
      container.innerHTML = '';
      
      list.forEach(g => {
        const item = document.createElement('div');
        item.className = 'graph-item';
        item.dataset.graphId = g.id;
        
        item.innerHTML = `
          <div class="graph-title">${g.title}</div>
          <div class="graph-meta">Updated: ${new Date(g.updated_at).toLocaleString()}</div>
          <button class="graph-delete" onclick="deleteGraph('${g.id}')" title="Delete graph">×</button>
        `;
        
        item.addEventListener('click', (e) => {
          if (!e.target.classList.contains('graph-delete')) {
            loadGraph(g);
            // Auto-scroll to center the graph
            centerCanvas();
          }
        });
        
        container.appendChild(item);
      });
    }

    function loadGraph(graph, skipTabSwitch = false) {
      // Clear existing content first
      tiles = [];
      connections = [];
      
      // Clear the canvas completely
      if (canvas) {
        canvas.innerHTML = '';
      }
      
      currentGraph = graph;
      tiles = (graph.data?.tiles || []).map(t => {
        const tile = createTile(t.x, t.y, t.title, t.content, t.id);
        if (t.color) {
          tile.style.background = t.color;
        }
        return tile;
      });
      connections = graph.data?.connections || [];
      
      // Create or update tab, but only switch if not already loading
      if (!openTabs.find(tab => tab.id === graph.id)) {
        createTab(graph);
      }
      
      // Only switch tabs if not already in the process of loading
      if (!skipTabSwitch) {
        switchToTab(graph.id);
      }
      
      // Show share section
      document.getElementById('shareSection').style.display = 'block';
      if (graph.sharingEnabled !== false) {
        document.querySelector('.share-toggle').textContent = 'ON';
        document.querySelector('.share-toggle').classList.remove('off');
        document.getElementById('shareEmail').style.display = 'block';
        document.querySelector('.share-btn').style.display = 'block';
      } else {
        document.querySelector('.share-toggle').textContent = 'OFF';
        document.querySelector('.share-toggle').classList.add('off');
        document.getElementById('shareEmail').style.display = 'none';
        document.querySelector('.share-btn').style.display = 'none';
      }
      
      renderCanvas();
      
      // Load collaborators only if there are any
      if (graph.sharedUsers && graph.sharedUsers.length > 0) {
        loadCollaborators();
      }
      
      // Add cache status buttons
      addCacheStatusButton();
      
      // Reset dirty state
      isDirty = false;
      
      // Apply theme colors to loaded tiles
      const currentTheme = document.documentElement.getAttribute('data-theme');
      updateTileColorsForTheme(currentTheme);
    }

    function addPendingUpdate(type, data) {
      pendingUpdates.push({ type, data, timestamp: Date.now() });
    }

    function sendRealtimeUpdates() {
      if (pendingUpdates.length === 0 || !currentGraph) return;
      
      const updates = [...pendingUpdates];
      pendingUpdates = [];
      
      // Send updates to server
      fetch(`/api/graphs/${currentGraph.id}/realtime`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('flowpad_token')}`
        },
        body: JSON.stringify({ updates })
      }).catch(error => {
        console.error('Failed to send real-time updates:', error);
        // Re-add failed updates
        pendingUpdates.unshift(...updates);
      });
    }

    function updateDragging(e) {
      // More responsive dragging with direct mouse coordinates
      let x = e.clientX - dragOffset.x - canvasOffset.x;
      let y = e.clientY - dragOffset.y - canvasOffset.y;
      
      // Apply snapping
      const snapped = getSnapPosition(x, y);
      x = snapped.x;
      y = snapped.y;
      
      // Update base coordinates and current position
      selectedTile.dataset.baseX = x;
      selectedTile.dataset.baseY = y;
      selectedTile.style.left = (x + canvasOffset.x) + 'px';
      selectedTile.style.top = (y + canvasOffset.y) + 'px';
      
      // Add smooth animation class
      selectedTile.classList.add('tile-updating');
      
      // Update connections immediately when tile moves
      renderConnections();
      
      // Add to pending updates for real-time sync
      addPendingUpdate('tile_move', {
        tileId: selectedTile.dataset.tileId,
        x: x,
        y: y
      });
      
      // Mark as dirty for auto-save
      markAsDirty();
    }

    function finishDragging() {
      if (selectedTile) {
        selectedTile.classList.remove('tile-updating');
        selectedTile = null;
      }
      isDragging = false;
      
      // Clear snap indicators
      clearSnapIndicators();
    }

    function deleteSelected() {
      if (selectedTile) {
        // Delete the tile
        const tileId = selectedTile.dataset.tileId;
        selectedTile.remove();
        tiles = tiles.filter(t => t.dataset.tileId !== tileId);
        
        // Remove connections involving this tile
        connections = connections.filter(conn => 
          conn.fromTile !== tileId && conn.toTile !== tileId
        );
        
        // Add to pending updates
        addPendingUpdate('tile_delete', { tileId });
        
        // Mark as dirty
        markAsDirty();
        
        clearSelection();
        renderCanvas();
        notify('Tile deleted', 'success');
      }
    }

    function deleteConnection(connectionId) {
      connections = connections.filter(conn => conn.id !== connectionId);
      
      // Add to pending updates
      addPendingUpdate('connection_delete', { connectionId });
      
      // Mark as dirty
      markAsDirty();
      
      renderConnections();
      notify('Connection deleted', 'success');
    }

    function setupCanvas() {
      canvas.addEventListener('mousedown', handleCanvasMouseDown);
      canvas.addEventListener('mousemove', handleCanvasMouseMove);
      canvas.addEventListener('mouseup', handleCanvasMouseUp);
      canvas.addEventListener('click', handleCanvasClick);
    }

    function handleCanvasMouseDown(e) {
      const tile = e.target.closest('.tile');
      const dot = e.target.closest('.connection-dot');
      
      if (dot) {
        startConnection(e, dot);
      } else if (tile && e.target.tagName !== 'TEXTAREA') {
        // Only start dragging if not clicking on textarea
        startDragging(e, tile);
      } else if (!tile) {
        // Start panning when clicking on empty canvas
        startPanning(e);
      }
    }

    function handleCanvasMouseMove(e) {
      if (isConnecting && connectionStart) {
        updateConnectionPreview(e);
      } else if (isDragging && selectedTile) {
        updateDragging(e);
      } else if (isPanning) {
        updatePanning(e);
      }
    }

    function handleCanvasMouseUp(e) {
      if (isConnecting) {
        finishConnection(e);
      }
      if (isDragging) {
        finishDragging();
      }
      isPanning = false;
    }

    function handleCanvasClick(e) {
      if (e.target === canvas) {
        hideFloatingToolbar();
        // Other canvas click handling...
      }
    }

    function startConnection(e, dot) {
      isConnecting = true;
      connectionStart = {
        tile: dot.closest('.tile'),
        dot: dot,
        x: e.clientX,
        y: e.clientY
      };
      e.stopPropagation();
    }

    function updateConnectionPreview(e) {
      // Remove existing preview
      const existingPreview = document.querySelector('.connection-preview');
      if (existingPreview) existingPreview.remove();
      
      // Create preview line
      const rect = canvas.getBoundingClientRect();
      const startX = connectionStart.x - rect.left;
      const startY = connectionStart.y - rect.top;
      const endX = e.clientX - rect.left;
      const endY = e.clientY - rect.top;
      
      const preview = createConnectionLine(startX, startY, endX, endY, true);
      preview.classList.add('connection-preview');
      canvas.appendChild(preview);
    }

    function finishConnection(e) {
      const targetTile = e.target.closest('.tile');
      const targetDot = e.target.closest('.connection-dot');
      
      if (targetTile && targetTile !== connectionStart.tile) {
        // Use automatic port selection if no specific dots were clicked
        let fromDotType = connectionStart.dot ? connectionStart.dot.dataset.dotType : null;
        let toDotType = targetDot ? targetDot.dataset.dotType : null;
        
        // If no specific dots, use automatic port selection
        if (!fromDotType || !toDotType) {
          const ports = findOptimalPort(connectionStart.tile, targetTile, fromDotType, toDotType);
          fromDotType = ports.fromPort.type;
          toDotType = ports.toPort.type;
        }
        
        const connection = {
          id: 'conn_' + Date.now(),
          fromTile: connectionStart.tile.dataset.tileId,
          fromDot: fromDotType,
          toTile: targetTile.dataset.tileId,
          toDot: toDotType,
          color: getRandomConnectionColor()
        };
        
        connections.push(connection);
        
        // Add to pending updates
        addPendingUpdate('connection_create', connection);
        
        // Mark as dirty
        markAsDirty();
        
        renderCanvas();
        notify('Connection created', 'success');
      }
      
      // Clean up
      const preview = document.querySelector('.connection-preview');
      if (preview) preview.remove();
      
      isConnecting = false;
      connectionStart = null;
    }

    function getRandomConnectionColor() {
      const colors = [
        '#3b82f6', // Blue
        '#ef4444', // Red
        '#10b981', // Green
        '#f59e0b', // Amber
        '#8b5cf6', // Purple
        '#ec4899', // Pink
        '#06b6d4', // Cyan
        '#84cc16', // Lime
        '#f97316', // Orange
        '#6366f1'  // Indigo
      ];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function saveRecentColor(color) {
      let recentColors = JSON.parse(localStorage.getItem('flowpad_recent_colors') || '[]');
      // Remove if already exists
      recentColors = recentColors.filter(c => c !== color);
      // Add to beginning
      recentColors.unshift(color);
      // Keep only last 10
      recentColors = recentColors.slice(0, 10);
      localStorage.setItem('flowpad_recent_colors', JSON.stringify(recentColors));
    }

    function getRecentColors() {
      return JSON.parse(localStorage.getItem('flowpad_recent_colors') || '[]');
    }

    function showRecentColorsPopup(tile, optionElement) {
      const recentColors = getRecentColors();
      
      // Create popup
      const popup = document.createElement('div');
      popup.className = 'recent-colors-popup';
      popup.style.cssText = `
        position: absolute;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 10px 25px var(--shadow-primary);
        z-index: 1000;
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 5px;
        min-width: 200px;
      `;
      
      // Position popup near the recent colors button
      const rect = optionElement.getBoundingClientRect();
      popup.style.left = (rect.left - 100) + 'px';
      popup.style.top = (rect.bottom + 5) + 'px';
      
      // Add recent colors
      recentColors.forEach(color => {
        const colorOption = document.createElement('div');
        colorOption.style.cssText = `
          width: 25px;
          height: 25px;
          background: ${color};
          border-radius: 4px;
          cursor: pointer;
          border: 2px solid transparent;
        `;
        colorOption.title = color;
        
        colorOption.addEventListener('click', () => {
          tile.style.background = color;
          tile.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
          optionElement.classList.add('selected');
          saveRecentColor(color);
          scheduleSave();
          popup.remove();
        });
        
        popup.appendChild(colorOption);
      });
      
      // Add close button
      if (recentColors.length === 0) {
        const noColors = document.createElement('div');
        noColors.textContent = 'No recent colors';
        noColors.style.cssText = `
          grid-column: 1 / -1;
          text-align: center;
          color: var(--text-secondary);
          padding: 10px;
        `;
        popup.appendChild(noColors);
      }
      
      // Close popup when clicking outside
      document.addEventListener('click', function closePopup(e) {
        if (!popup.contains(e.target) && !optionElement.contains(e.target)) {
          popup.remove();
          document.removeEventListener('click', closePopup);
        }
      });
      
      document.body.appendChild(popup);
    }

    function startPanning(e) {
      isPanning = true;
      panStart.x = e.clientX - canvasOffset.x;
      panStart.y = e.clientY - canvasOffset.y;
    }

    function startDragging(e, tile) {
      isDragging = true;
      selectedTile = tile;
      selectTile(tile);
      
      // Calculate offset relative to tile's current position
      const baseX = parseInt(tile.dataset.baseX) || 0;
      const baseY = parseInt(tile.dataset.baseY) || 0;
      dragOffset.x = e.clientX - (baseX + canvasOffset.x);
      dragOffset.y = e.clientY - (baseY + canvasOffset.y);
    }

    function updatePanning(e) {
      const deltaX = e.clientX - panStart.x;
      const deltaY = e.clientY - panStart.y;
      
      // Update pan start for next frame
      panStart.x = e.clientX;
      panStart.y = e.clientY;
      
      // Apply pan offset to canvas view (not individual tiles)
      canvasOffset.x += deltaX;
      canvasOffset.y += deltaY;
      
      // Update tile positions immediately for responsive feel
      tiles.forEach(t => {
        const baseX = parseInt(t.dataset.baseX) || parseInt(t.style.left) || 0;
        const baseY = parseInt(t.dataset.baseY) || parseInt(t.style.top) || 0;
        t.style.left = (baseX + canvasOffset.x) + 'px';
        t.style.top = (baseY + canvasOffset.y) + 'px';
      });
      
      // Update connections with new canvas offset
      renderConnections();
    }

    function updateDragging(e) {
      // More responsive dragging with direct mouse coordinates
      let x = e.clientX - dragOffset.x - canvasOffset.x;
      let y = e.clientY - dragOffset.y - canvasOffset.y;
      
      // Apply snapping
      const snapped = getSnapPosition(x, y);
      x = snapped.x;
      y = snapped.y;
      
      // Update base coordinates and current position
      selectedTile.dataset.baseX = x;
      selectedTile.dataset.baseY = y;
      selectedTile.style.left = (x + canvasOffset.x) + 'px';
      selectedTile.style.top = (y + canvasOffset.y) + 'px';
      
      // Add smooth animation class
      selectedTile.classList.add('tile-updating');
      
      // Update connections immediately when tile moves
      renderConnections();
      
      // Add to pending updates for real-time sync
      addPendingUpdate('tile_move', {
        tileId: selectedTile.dataset.tileId,
        x: x,
        y: y
      });
      
      // Mark as dirty for auto-save
      markAsDirty();
    }

    function finishDragging() {
      if (selectedTile) {
        selectedTile.classList.remove('tile-updating');
        selectedTile = null;
      }
      isDragging = false;
      
      // Clear snap indicators
      clearSnapIndicators();
    }

    function createTile(x = 100, y = 100, title = '', content = '', id = null, shape = 'rectangle', presetType = null) {
      console.log('createTile called with:', { x, y, title, content, id, shape, presetType });
      const tile = document.createElement('div');
      tile.className = `tile ${shape}`;
      tile.dataset.tileId = id || 'tile_' + Date.now();
      tile.dataset.baseX = x;
      tile.dataset.baseY = y;
      tile.dataset.shape = shape;
      tile.dataset.presetType = presetType || 'custom';
      tile.style.left = (x + canvasOffset.x) + 'px';
      tile.style.top = (y + canvasOffset.y) + 'px';
      
      // Set default color if none exists
      if (!tile.dataset.color) {
        tile.dataset.color = '#ffffff';
        tile.style.backgroundColor = '#ffffff';
      }
      
      tile.innerHTML = `
        <textarea class="tile-title" placeholder="Title">${title || ''}</textarea>
        <textarea class="tile-content" placeholder="Content">${content || ''}</textarea>
      `;
      
      // Add click handler for toolbar
      console.log('Adding click handler to tile:', tile);
      addTileClickHandler(tile);
      
      tile.querySelectorAll('textarea').forEach(t => t.addEventListener('input', scheduleSave));
      
      console.log('Tile created successfully:', tile);
        return tile;
      }

    function selectTile(tile) {
      clearSelection();
      selectedTile = tile;
      tile.classList.add('selected');
    }

    function clearSelection() {
      if (selectedTile) {
        selectedTile.classList.remove('selected');
        selectedTile = null;
      }
    }

    function addTile() {
      // Show preset selection popup
      const canvasRect = canvas.getBoundingClientRect();
      const centerX = canvasRect.width / 2;
      const centerY = canvasRect.height / 2;
      
      showPresetPopup(centerX, centerY);
    }

    function deleteSelected() {
      if (!selectedTile) return;
      
      // Remove from tiles array
      const index = tiles.indexOf(selectedTile);
      if (index > -1) {
        tiles.splice(index, 1);
      }
      
      // Remove from DOM
      selectedTile.remove();
      
      // Clear selection
      selectedTile = null;
      
      // Re-render canvas
      renderCanvas();
      
      // Mark as dirty for auto-save
      markAsDirty();
    }

    function deleteConnection(connectionId) {
      const connectionIndex = connections.findIndex(c => c.id === connectionId);
      if (connectionIndex !== -1) {
        connections.splice(connectionIndex, 1);
        renderCanvas();
      scheduleSave();
        notify('Connection deleted successfully', 'success');
      }
    }

    function centerCanvas() {
      // Reset canvas panning to center
      canvasOffset.x = 0;
      canvasOffset.y = 0;
      
      // Update tile positions to their base coordinates
      tiles.forEach(t => {
        const baseX = parseInt(t.dataset.baseX) || 0;
        const baseY = parseInt(t.dataset.baseY) || 0;
        t.style.left = baseX + 'px';
        t.style.top = baseY + 'px';
      });
      
      // Re-render connections
      renderConnections();
      
      notify('Canvas centered', 'success');
    }

    function setConnectionMode(mode) {
      connectionMode = mode;
      document.querySelectorAll('.connection-mode-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
    }

    function toggleAIPanel() {
      const panel = document.getElementById('aiPanel');
      panel.classList.toggle('show');
    }

    async function getAISuggestions() {
      if (!currentGraph || !selectedTile) {
        notify('Please select a tile first', 'error');
        return;
      }

      const aiInput = document.getElementById('aiInput').value.trim();
      if (!aiInput) {
        notify('Please describe what you want to add', 'error');
        return;
      }

      const aiBtn = document.getElementById('aiBtn');
      const aiBtnText = document.getElementById('aiBtnText');
      aiBtn.disabled = true;
      aiBtnText.innerHTML = '<span class="loading"></span>Getting suggestions...';

      try {
        const token = localStorage.getItem('flowpad_token');
        const response = await fetch('/api/ai-suggestions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            targetTile: {
              id: selectedTile.dataset.tileId,
              content: selectedTile.querySelector('.tile-content').value
            },
            existingTiles: tiles.map(t => ({
              id: t.dataset.tileId,
              content: t.querySelector('.tile-content').value
            })),
            connections: connections
          })
        });

        if (!response.ok) {
          throw new Error('Failed to get AI suggestions');
        }

        const data = await response.json();
        displayAISuggestions(data);
      } catch (error) {
        notify('Failed to get AI suggestions: ' + error.message, 'error');
      } finally {
        aiBtn.disabled = false;
        aiBtnText.textContent = 'Get Suggestions';
      }
    }

    function displayAISuggestions(suggestions) {
      const container = document.getElementById('aiSuggestions');
      container.innerHTML = '';
      
      console.log('AI Response:', suggestions); // Debug log
      
      // Handle different response formats more robustly
      let suggestionsArray = [];
      
      if (suggestions && typeof suggestions === 'object') {
        if (suggestions.suggestions && Array.isArray(suggestions.suggestions)) {
          suggestionsArray = suggestions.suggestions;
        } else if (suggestions.data && Array.isArray(suggestions.data)) {
          suggestionsArray = suggestions.data;
        } else if (suggestions.text && typeof suggestions.text === 'string') {
          suggestionsArray = [suggestions.text];
        } else if (suggestions.content && typeof suggestions.content === 'string') {
          suggestionsArray = [suggestions.content];
        } else if (suggestions.description && typeof suggestions.description === 'string') {
          suggestionsArray = [suggestions.description];
        } else if (suggestions.message && typeof suggestions.message === 'string') {
          suggestionsArray = [suggestions.message];
        } else if (suggestions.response && typeof suggestions.response === 'string') {
          suggestionsArray = [suggestions.response];
        } else if (Array.isArray(suggestions)) {
          suggestionsArray = suggestions;
        } else {
          // Try to extract any meaningful text content
          const suggestionText = extractTextFromObject(suggestions);
          if (suggestionText) {
            suggestionsArray = [suggestionText];
          }
        }
      } else if (typeof suggestions === 'string') {
        suggestionsArray = [suggestions];
      }
      
      if (suggestionsArray.length > 0) {
        suggestionsArray.forEach((suggestion, index) => {
          const div = document.createElement('div');
          div.className = 'ai-suggestion';
          
          let displayText = '';
          if (typeof suggestion === 'string') {
            displayText = suggestion;
          } else if (suggestion && typeof suggestion === 'object') {
            displayText = extractTextFromObject(suggestion);
          } else {
            displayText = String(suggestion);
          }
          
          div.textContent = displayText;
          div.addEventListener('click', () => applyAISuggestion(suggestion));
          container.appendChild(div);
        });
      } else {
        container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">No suggestions available</div>';
      }
    }

    function extractTextFromObject(obj) {
      if (!obj || typeof obj !== 'object') return null;
      
      // Try common text fields
      const textFields = ['text', 'content', 'description', 'message', 'response', 'suggestion', 'title', 'name'];
      for (const field of textFields) {
        if (obj[field] && typeof obj[field] === 'string') {
          return obj[field];
        }
      }
      
      // Try to find any string value
      for (const key in obj) {
        if (typeof obj[key] === 'string' && obj[key].length > 0) {
          return obj[key];
        }
      }
      
      // Fallback to JSON string
      try {
        return JSON.stringify(obj, null, 2);
      } catch (e) {
        return 'Unable to process suggestion';
      }
    }

    function applyAISuggestion(suggestion) {
      if (selectedTile) {
        let content = '';
        
        if (typeof suggestion === 'string') {
          content = suggestion;
        } else if (suggestion && typeof suggestion === 'object') {
          content = extractTextFromObject(suggestion);
        } else {
          content = String(suggestion);
        }
        
        if (content) {
          selectedTile.querySelector('.tile-content').value = content;
          scheduleSave();
          notify('Suggestion applied!', 'success');
        } else {
          notify('Unable to apply suggestion', 'error');
        }
      } else {
        notify('Please select a tile first', 'error');
      }
    }

    function createConnectionLine(fromX, fromY, toX, toY, isPreview = false, color = null, connectionId = null) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.style.position = 'absolute';
      svg.style.left = '0';
      svg.style.top = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';
      svg.style.zIndex = isPreview ? '15' : '5';
      
      if (!isPreview) {
        svg.style.pointerEvents = 'auto';
        svg.style.cursor = 'pointer';
        svg.dataset.connectionId = connectionId;
        
        // Add click handler for deletion
        svg.addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm('Delete this connection?')) {
            deleteConnection(connectionId);
          }
        });
        
        // Add hover effect
        svg.addEventListener('mouseenter', () => {
          path.style.strokeWidth = '4';
          path.style.filter = 'drop-shadow(0 0 3px currentColor)';
          svg.style.cursor = 'pointer';
        });
        
        svg.addEventListener('mouseleave', () => {
          path.style.strokeWidth = '3';
          path.style.filter = 'none';
          svg.style.cursor = 'pointer';
        });
      }
      
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      
      // Always use curved lines for better visual appeal
      let pathData = createSmartPath(fromX, fromY, toX, toY);
      
      path.setAttribute('d', pathData);
      path.setAttribute('stroke', isPreview ? '#888' : (color || 'var(--accent-primary)'));
      path.setAttribute('stroke-width', isPreview ? '2' : '3');
      path.setAttribute('fill', 'none');
      path.setAttribute('marker-end', isPreview ? 'none' : 'url(#arrowhead)');
      path.classList.add('connection-line');
      
      svg.appendChild(path);
      return svg;
    }

    function createSmartPath(fromX, fromY, toX, toY) {
      // Try obstacle-aware Manhattan, fall back to a smooth S-curve
      const obstacles = findObstacles(fromX, fromY, toX, toY);
      const manhattanPath = createManhattanPath(fromX, fromY, toX, toY, obstacles);
      return manhattanPath || createSimpleSCurve(fromX, fromY, toX, toY);
    }

    function createGridPath(fromX, fromY, toX, toY) {
      // Snap start and end points to grid
      const startX = Math.round(fromX / gridSize) * gridSize;
      const startY = Math.round(fromY / gridSize) * gridSize;
      const endX = Math.round(toX / gridSize) * gridSize;
      const endY = Math.round(toY / gridSize) * gridSize;
      
      // Calculate midpoints for 90-degree bends
      const midX = Math.round((startX + endX) / 2 / gridSize) * gridSize;
      const midY = Math.round((startY + endY) / 2 / gridSize) * gridSize;
      
      // Create path with 2 90-degree bends at midpoints
      const path = [];
      
      // Start point
      path.push({ x: startX, y: startY });
      
      // First bend - horizontal to midpoint
      if (startX !== midX) {
        path.push({ x: midX, y: startY });
      }
      
      // Second bend - vertical to midpoint
      if (startY !== midY) {
        path.push({ x: midX, y: midY });
      }
      
      // Third bend - horizontal to end
      if (midX !== endX) {
        path.push({ x: endX, y: midY });
      }
      
      // Fourth bend - vertical to end
      if (midY !== endY) {
        path.push({ x: endX, y: endY });
      }
      
      // End point
      path.push({ x: endX, y: endY });
      
      return path;
    }

    function findObstacles(fromX, fromY, toX, toY) {
      const obstacles = [];
      const canvasRect = canvas.getBoundingClientRect();
      
      tiles.forEach(tile => {
        const tileRect = tile.getBoundingClientRect();
        const tileX = tileRect.left - canvasRect.left;
        const tileY = tileRect.top - canvasRect.top;
        const tileWidth = tileRect.width;
        const tileHeight = tileRect.height;
        
        // Check if line intersects with tile
        if (lineIntersectsRect(fromX, fromY, toX, toY, tileX, tileY, tileWidth, tileHeight)) {
          obstacles.push({
            x: tileX,
            y: tileY,
            width: tileWidth,
            height: tileHeight
          });
        }
      });
      
      return obstacles;
    }

    function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
      // Simple line-rectangle intersection test
      const left = rx;
      const right = rx + rw;
      const top = ry;
      const bottom = ry + rh;
      
      // Check if line endpoints are inside rectangle
      if ((x1 >= left && x1 <= right && y1 >= top && y1 <= bottom) ||
          (x2 >= left && x2 <= right && y2 >= top && y2 <= bottom)) {
        return true;
      }
      
      // Check line segments against rectangle edges
      const lines = [
        [left, top, right, top],     // top edge
        [right, top, right, bottom], // right edge
        [right, bottom, left, bottom], // bottom edge
        [left, bottom, left, top]    // left edge
      ];
      
      for (const line of lines) {
        if (linesIntersect(x1, y1, x2, y2, line[0], line[1], line[2], line[3])) {
          return true;
        }
      }
      
      return false;
    }

    function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (den === 0) return false;
      
      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
      const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
      
      return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }

    function calculateWaypoints(fromX, fromY, toX, toY, obstacles) {
      const waypoints = [];
      
      // Sort obstacles by distance from start point
      obstacles.sort((a, b) => {
        const distA = Math.sqrt((a.x - fromX) ** 2 + (a.y - fromY) ** 2);
        const distB = Math.sqrt((b.x - fromX) ** 2 + (b.y - fromY) ** 2);
        return distA - distB;
      });
      
      let currentX = fromX;
      let currentY = fromY;
      
      for (const obstacle of obstacles) {
        // Find best waypoint around this obstacle
        const waypoint = findBestWaypoint(currentX, currentY, toX, toY, obstacle);
        if (waypoint) {
          waypoints.push(waypoint);
          currentX = waypoint.x;
          currentY = waypoint.y;
        }
      }
      
      return waypoints;
    }

    function findBestWaypoint(currentX, currentY, toX, toY, obstacle) {
      // Find the best waypoint around an obstacle
      const waypoints = [];
      const margin = 20;
      
      // Generate waypoints around the obstacle
      const left = obstacle.x - margin;
      const right = obstacle.x + obstacle.width + margin;
      const top = obstacle.y - margin;
      const bottom = obstacle.y + obstacle.height + margin;
      
      // Add corner waypoints
      waypoints.push({ x: left, y: top });
      waypoints.push({ x: right, y: top });
      waypoints.push({ x: left, y: bottom });
      waypoints.push({ x: right, y: bottom });
      
      // Add edge waypoints
      waypoints.push({ x: left, y: obstacle.y + obstacle.height / 2 });
      waypoints.push({ x: right, y: obstacle.y + obstacle.height / 2 });
      waypoints.push({ x: obstacle.x + obstacle.width / 2, y: top });
      waypoints.push({ x: obstacle.x + obstacle.width / 2, y: bottom });
      
      // Find the waypoint that minimizes total path length
      let bestWaypoint = null;
      let bestScore = Infinity;
      
      for (const wp of waypoints) {
        const score = calculatePathScore(currentX, currentY, wp.x, wp.y, toX, toY, obstacle);
        if (score < bestScore) {
          bestScore = score;
          bestWaypoint = wp;
        }
      }
      
      return bestWaypoint;
    }

    function createPathMap(fromX, fromY, toX, toY, obstacles) {
      // Create a path map with straight edges and max 3 bends
      const pathMap = {
        points: [{ x: fromX, y: fromY }],
        edges: []
      };
      
      if (obstacles.length === 0) {
        // Direct path
        pathMap.points.push({ x: toX, y: toY });
        pathMap.edges.push({ from: 0, to: 1 });
        return pathMap;
      }
      
      // Sort obstacles by distance from start
      obstacles.sort((a, b) => {
        const distA = Math.sqrt((a.x - fromX) ** 2 + (a.y - fromY) ** 2);
        const distB = Math.sqrt((b.x - fromX) ** 2 + (b.y - fromY) ** 2);
        return distA - distB;
      });
      
      let currentX = fromX;
      let currentY = fromY;
      let bendCount = 0;
      const maxBends = 3;
      
      for (const obstacle of obstacles) {
        if (bendCount >= maxBends) break;
        
        // Find best waypoint around this obstacle
        const waypoint = findBestWaypoint(currentX, currentY, toX, toY, obstacle);
        if (waypoint) {
          pathMap.points.push(waypoint);
          pathMap.edges.push({ 
            from: pathMap.points.length - 2, 
            to: pathMap.points.length - 1 
          });
          
          currentX = waypoint.x;
          currentY = waypoint.y;
          bendCount++;
        }
      }
      
      // Add final destination
      pathMap.points.push({ x: toX, y: toY });
      pathMap.edges.push({ 
        from: pathMap.points.length - 2, 
        to: pathMap.points.length - 1 
      });
      
      return pathMap;
    }

    function convertPathMapToCurves(pathMap) {
      if (pathMap.points.length < 2) {
        return `M ${pathMap.points[0].x} ${pathMap.points[0].y}`;
      }
      
      let path = `M ${pathMap.points[0].x} ${pathMap.points[0].y}`;
      
      for (let i = 1; i < pathMap.points.length; i++) {
        const current = pathMap.points[i];
        const previous = pathMap.points[i - 1];
        
        if (i === 1 || i === pathMap.points.length - 1) {
          // First and last segments: straight lines
          path += ` L ${current.x} ${current.y}`;
        } else {
          // Middle segments: convert bends to curves
          const next = pathMap.points[i + 1];
          const curve = convertBendToCurve(previous, current, next);
          path += ` ${curve}`;
        }
      }
      
      return path;
    }

    function convertBendToCurve(prev, current, next) {
      // Calculate the angle between the two line segments
      const angle1 = Math.atan2(current.y - prev.y, current.x - prev.x);
      const angle2 = Math.atan2(next.y - current.y, next.x - current.x);
      const angleDiff = Math.abs(angle1 - angle2);
      
      // If the angle is too sharp, create a curve
      if (angleDiff > Math.PI / 6) { // 30 degrees
        const radius = 20;
        const control1 = {
          x: current.x - Math.cos(angle1) * radius,
          y: current.y - Math.sin(angle1) * radius
        };
        const control2 = {
          x: current.x + Math.cos(angle2) * radius,
          y: current.y + Math.sin(angle2) * radius
        };
        
        return `C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${next.x} ${next.y}`;
      } else {
        // Small angle, keep it straight
        return `L ${next.x} ${next.y}`;
      }
    }

    function findOptimalPort(fromTile, toTile, fromDotType, toDotType) {
      // Find the optimal connection ports based on relative tile positions
      const fromRect = fromTile.getBoundingClientRect();
      const toRect = toTile.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      
      // Calculate relative positions
      const fromCenterX = fromRect.left + fromRect.width / 2 - canvasRect.left;
      const fromCenterY = fromRect.top + fromRect.height / 2 - canvasRect.top;
      const toCenterX = toRect.left + toRect.width / 2 - canvasRect.left;
      const toCenterY = toRect.top + toRect.height / 2 - canvasRect.top;
      
      // Determine optimal port types based on relative positions
      let optimalFromPort = fromDotType;
      let optimalToPort = toDotType;
      
      // If no specific ports specified, choose based on relative positions
      if (!fromDotType || !toDotType) {
        const dx = toCenterX - fromCenterX;
        const dy = toCenterY - fromCenterY;
        
        if (Math.abs(dx) > Math.abs(dy)) {
          // Horizontal connection
          optimalFromPort = dx > 0 ? 'output' : 'input';
          optimalToPort = dx > 0 ? 'input' : 'output';
        } else {
          // Vertical connection
          optimalFromPort = dy > 0 ? 'bottom' : 'top';
          optimalToPort = dy > 0 ? 'top' : 'bottom';
        }
      }
      
      // Calculate actual port coordinates
      const fromPort = getPortCoordinates(fromTile, optimalFromPort, canvasRect);
      const toPort = getPortCoordinates(toTile, optimalToPort, canvasRect);
      
      return {
        fromPort: { x: fromPort.x, y: fromPort.y, type: optimalFromPort },
        toPort: { x: toPort.x, y: toPort.y, type: optimalToPort }
      };
    }

    function getPortCoordinates(tile, portType, canvasRect) {
      const rect = tile.getBoundingClientRect();
      
      switch (portType) {
        case 'input':
          return { x: rect.left - canvasRect.left, y: rect.top + rect.height / 2 - canvasRect.top };
        case 'output':
          return { x: rect.right - canvasRect.left, y: rect.top + rect.height / 2 - canvasRect.top };
        case 'top':
          return { x: rect.left + rect.width / 2 - canvasRect.left, y: rect.top - canvasRect.top };
        case 'bottom':
          return { x: rect.left + rect.width / 2 - canvasRect.left, y: rect.bottom - canvasRect.top };
        default:
          return { x: rect.left + rect.width / 2 - canvasRect.left, y: rect.top + rect.height / 2 - canvasRect.top };
      }
    }

    function createManhattanPath(fromX, fromY, toX, toY, obstacles) {
      // Create a coarse grid for Manhattan routing
      const gridSize = 20;
      const grid = createRoutingGrid(fromX, fromY, toX, toY, obstacles, gridSize);
      
      // Find path using A* with Manhattan heuristic
      const path = findManhattanPath(fromX, fromY, toX, toY, grid, gridSize);
      
      if (path.length === 0) {
        // Fallback to simple S-curve if routing fails
        return createSimpleSCurve(fromX, fromY, toX, toY);
      }
      
      // Convert path to SVG with rounded corners
      return convertPathToSVG(path, gridSize);
    }

    function createRoutingGrid(fromX, fromY, toX, toY, obstacles, gridSize) {
      // Create a grid that covers the area between the two points
      const minX = Math.min(fromX, toX) - 100;
      const maxX = Math.max(fromX, toX) + 100;
      const minY = Math.min(fromY, toY) - 100;
      const maxY = Math.max(fromY, toY) + 100;
      
      const cols = Math.ceil((maxX - minX) / gridSize);
      const rows = Math.ceil((maxY - minY) / gridSize);
      
      const grid = Array(rows).fill().map(() => Array(cols).fill(0));
      
      // Mark obstacles as blocked
      obstacles.forEach(obstacle => {
        const startCol = Math.max(0, Math.floor((obstacle.x - minX) / gridSize));
        const endCol = Math.min(cols - 1, Math.ceil((obstacle.x + obstacle.width - minX) / gridSize));
        const startRow = Math.max(0, Math.floor((obstacle.y - minY) / gridSize));
        const endRow = Math.min(rows - 1, Math.ceil((obstacle.y + obstacle.height - minY) / gridSize));
        
        for (let row = startRow; row <= endRow; row++) {
          for (let col = startCol; col <= endCol; col++) {
            grid[row][col] = 1; // Blocked
          }
        }
      });
      
      return { grid, minX, minY, gridSize, cols, rows };
    }

    function findManhattanPath(fromX, fromY, toX, toY, gridInfo, gridSize) {
      const { grid, minX, minY, cols, rows } = gridInfo;
      
      // Convert world coordinates to grid coordinates
      const startCol = Math.floor((fromX - minX) / gridSize);
      const startRow = Math.floor((fromY - minY) / gridSize);
      const endCol = Math.floor((toX - minX) / gridSize);
      const endRow = Math.floor((toY - minY) / gridSize);
      
      // Clamp to grid bounds
      const clampedStartCol = Math.max(0, Math.min(cols - 1, startCol));
      const clampedStartRow = Math.max(0, Math.min(rows - 1, startRow));
      const clampedEndCol = Math.max(0, Math.min(cols - 1, endCol));
      const clampedEndRow = Math.max(0, Math.min(rows - 1, endRow));
      
      // A* pathfinding with Manhattan heuristic
      const openSet = [{ col: clampedStartCol, row: clampedStartRow, g: 0, h: 0, parent: null }];
      const closedSet = new Set();
      const cameFrom = new Map();
      const gScore = new Map();
      const fScore = new Map();
      
      gScore.set(`${clampedStartCol},${clampedStartRow}`, 0);
      fScore.set(`${clampedStartCol},${clampedStartRow}`, 0);
      
      while (openSet.length > 0) {
        // Find node with lowest f score
        openSet.sort((a, b) => a.h - b.h);
        const current = openSet.shift();
        
        if (current.col === clampedEndCol && current.row === clampedEndRow) {
          // Reconstruct path
          return reconstructPath(current, cameFrom, minX, minY, gridSize);
        }
        
        const currentKey = `${current.col},${current.row}`;
        closedSet.add(currentKey);
        
        // Check neighbors
        const neighbors = [
          { col: current.col + 1, row: current.row },
          { col: current.col - 1, row: current.row },
          { col: current.col, row: current.row + 1 },
          { col: current.col, row: current.row - 1 }
        ];
        
        for (const neighbor of neighbors) {
          if (neighbor.col < 0 || neighbor.col >= cols || neighbor.row < 0 || neighbor.row >= rows) {
            continue;
          }
          
          if (grid[neighbor.row][neighbor.col] === 1) {
            continue; // Blocked
          }
          
          const neighborKey = `${neighbor.col},${neighbor.row}`;
          if (closedSet.has(neighborKey)) {
            continue;
          }
          
          const tentativeG = current.g + 1;
          const neighborG = gScore.get(neighborKey) || Infinity;
          
          if (tentativeG < neighborG) {
            cameFrom.set(neighborKey, current);
            gScore.set(neighborKey, tentativeG);
            
            const h = Math.abs(neighbor.col - clampedEndCol) + Math.abs(neighbor.row - clampedEndRow);
            const f = tentativeG + h;
            fScore.set(neighborKey, f);
            
            // Add to open set if not already there
            if (!openSet.find(n => n.col === neighbor.col && n.row === neighbor.row)) {
              openSet.push({ col: neighbor.col, row: neighbor.row, g: tentativeG, h: h, parent: current });
            }
          }
        }
      }
      
      return []; // No path found
    }

    function reconstructPath(endNode, cameFrom, minX, minY, gridSize) {
      const path = [];
      let current = endNode;
      
      while (current) {
        const worldX = minX + current.col * gridSize + gridSize / 2;
        const worldY = minY + current.row * gridSize + gridSize / 2;
        path.unshift({ x: worldX, y: worldY });
        
        const currentKey = `${current.col},${current.row}`;
        current = cameFrom.get(currentKey);
      }
      
      return path;
    }

    function convertPathToSVG(path, gridSize) {
      if (path.length < 2) {
        return `M ${path[0].x} ${path[0].y}`;
      }
      
      let svgPath = `M ${path[0].x} ${path[0].y}`;
      
      for (let i = 1; i < path.length; i++) {
        const prev = path[i - 1];
        const curr = path[i];
        
        // Add rounded corners for Manhattan routing
        if (i < path.length - 1) {
          const next = path[i + 1];
          const cornerRadius = Math.min(gridSize / 3, 15);
          
          // Determine if this is a corner (direction change)
          const dx1 = curr.x - prev.x;
          const dy1 = curr.y - prev.y;
          const dx2 = next.x - curr.x;
          const dy2 = next.y - curr.y;
          
          if ((Math.abs(dx1) > 0.1 && Math.abs(dy2) > 0.1) || 
              (Math.abs(dy1) > 0.1 && Math.abs(dx2) > 0.1)) {
            // This is a corner, add rounded corner
            const corner = createRoundedCorner(prev, curr, next, cornerRadius);
            svgPath += corner;
          } else {
            // Straight line
            svgPath += ` L ${curr.x} ${curr.y}`;
          }
        } else {
          // Last segment
          svgPath += ` L ${curr.x} ${curr.y}`;
        }
      }
      
      return svgPath;
    }

    function createRoundedCorner(prev, curr, next, radius) {
      // Create a rounded corner between three points
      const dx1 = curr.x - prev.x;
      const dy1 = curr.y - prev.y;
      const dx2 = next.x - curr.x;
      const dy2 = next.y - curr.y;
      
      // Calculate the angle between the two segments
      const angle1 = Math.atan2(dy1, dx1);
      const angle2 = Math.atan2(dy2, dx2);
      const angleDiff = Math.abs(angle1 - angle2);
      
      if (angleDiff < Math.PI / 6) {
        // Small angle, just use straight line
        return ` L ${curr.x} ${curr.y}`;
      }
      
      // Calculate control points for the rounded corner
      const midAngle = (angle1 + angle2) / 2;
      const control1 = {
        x: curr.x - Math.cos(angle1) * radius,
        y: curr.y - Math.sin(angle1) * radius
      };
      const control2 = {
        x: curr.x + Math.cos(angle2) * radius,
        y: curr.y + Math.sin(angle2) * radius
      };
      
      return ` C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${next.x} ${next.y}`;
    }

    function createSimpleSCurve(fromX, fromY, toX, toY) {
      // Fallback to simple S-curve
      const midX = (fromX + toX) / 2;
      const midY = (fromY + toY) / 2;
      const distance = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
      const curveIntensity = Math.max(distance * 0.3, 40);
      
      const control1 = { 
        x: fromX + (midX - fromX) * 0.5, 
        y: fromY + (fromY < toY ? curveIntensity : -curveIntensity) 
      };
      const control2 = { 
        x: toX - (toX - midX) * 0.5, 
        y: toY + (toY < fromY ? curveIntensity : -curveIntensity) 
      };
      
      return `M ${fromX} ${fromY} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${toX} ${toY}`;
    }

    function renderCanvas() {
      // Clear canvas (but keep the grid overlay if present)
      const gridOverlay = document.getElementById('grid-overlay');
      canvas.innerHTML = '';
      if (gridOverlay) canvas.appendChild(gridOverlay);

      // Position tiles purely from base coords + current canvasOffset
      tiles.forEach(t=>{
        const bx = parseInt(t.dataset.baseX)||0;
        const by = parseInt(t.dataset.baseY)||0;
        t.style.left = (bx + canvasOffset.x) + 'px';
        t.style.top  = (by + canvasOffset.y) + 'px';
        t.style.position = 'absolute';
        t.style.zIndex = '10';
        canvas.appendChild(t);
      });

      renderConnections();
    }

    function renderConnections(){
      // Ensure a single svg container exists
      let svgContainer = document.querySelector('#connections-svg');
      if (!svgContainer){
        svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svgContainer.id = 'connections-svg';
        svgContainer.style.position = 'absolute';
        svgContainer.style.top = '0';
        svgContainer.style.left = '0';
        svgContainer.style.width = '100%';
        svgContainer.style.height = '100%';
        svgContainer.style.zIndex = '100';
        svgContainer.style.pointerEvents = 'auto'; // allow clicks on child paths

        // markers
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

        const mk = (id, markup) => {
          const frag = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
          Object.entries(markup.attrs).forEach(([k,v])=>frag.setAttribute(k, v));
          frag.id = id;
          frag.appendChild(markup.child);
          defs.appendChild(frag);
        };

        const arrowPoly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        arrowPoly.setAttribute('points','0 0, 10 3.5, 0 7');
        arrowPoly.setAttribute('fill','#007AFF');
        mk('arrowhead', {attrs:{markerWidth:'10',markerHeight:'7',refX:'9',refY:'3.5',orient:'auto'}, child:arrowPoly});

        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        dot.setAttribute('cx','4'); dot.setAttribute('cy','4'); dot.setAttribute('r','3'); dot.setAttribute('fill','#007AFF');
        mk('dotmarker', {attrs:{markerWidth:'8',markerHeight:'8',refX:'4',refY:'4',orient:'auto'}, child:dot});

        const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        diamond.setAttribute('points','5 0, 10 3.5, 5 7, 0 3.5'); diamond.setAttribute('fill','#007AFF');
        mk('diamondmarker', {attrs:{markerWidth:'10',markerHeight:'7',refX:'9',refY:'3.5',orient:'auto'}, child:diamond});

        svgContainer.appendChild(defs);
        canvas.appendChild(svgContainer);
      }

      // Clear previous paths only (leave defs intact)
      [...svgContainer.querySelectorAll('path.connection-line')].forEach(p => p.remove());

      // Group by pair to fan parallel edges
      const groups = {};
      connections.forEach(c => {
        const key = `${c.fromTile}__${c.toTile}`;
        (groups[key] ||= []).push(c);
      });

      Object.values(groups).forEach(group => {
        group.forEach((conn, idx) => {
          const fromTile = tiles.find(t => t.dataset.tileId === conn.fromTile);
          const toTile   = tiles.find(t => t.dataset.tileId === conn.toTile);
          if (!fromTile || !toTile) return;

          const pathEl = createConnectionLineWithSeparation(fromTile, toTile, idx, conn);
          if (pathEl) svgContainer.appendChild(pathEl);
        });
      });

      // sync viewBox
      const r = canvas.getBoundingClientRect();
      svgContainer.setAttribute('viewBox', `0 0 ${r.width} ${r.height}`);
    }

    function createConnectionLineWithSeparation(fromTile, toTile, index, connObj){
      // pick ports
      const { fromPort, toPort } = findOptimalPort(fromTile, toTile, connObj?.fromDot, connObj?.toDot);
      let fx = fromPort.x, fy = fromPort.y, tx = toPort.x, ty = toPort.y;

      // separate parallel edges slightly
      const dx = tx - fx, dy = ty - fy, len = Math.max(1, Math.hypot(dx,dy));
      const perpX = -dy / len, perpY = dx / len;
      const bump = (index ? (index-0.5) * 8 : 0);
      fx += perpX * bump; fy += perpY * bump;
      tx += perpX * bump; ty += perpY * bump;

      const d = createSmartPath(fx, fy, tx, ty);

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', d);
      path.setAttribute('fill','none');
      path.setAttribute('stroke', connObj?.color || 'var(--accent-primary)');
      path.setAttribute('stroke-width','3');
      path.setAttribute('marker-end','url(#arrowhead)');
      path.classList.add('connection-line');
      path.style.pointerEvents = 'stroke';

      // click -> delete
      path.addEventListener('click', (e)=>{
        e.stopPropagation();
        if (confirm('Delete this connection?')) deleteConnection(connObj.id);
      });
      path.addEventListener('mouseenter', ()=>{ path.style.strokeWidth='4'; path.style.filter='drop-shadow(0 0 3px currentColor)'; });
      path.addEventListener('mouseleave', ()=>{ path.style.strokeWidth='3'; path.style.filter='none'; });

      return path;
    }

    async function shareGraph() {
      if (!currentGraph) return;
      const email = document.getElementById('shareEmail').value.trim();
      if (!email) return notify('Please enter an email', 'error');
      const token = localStorage.getItem('flowpad_token');
      const res = await fetch(`/api/graphs/${currentGraph.id}/share`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ email }) });
      notify(res.ok ? 'Graph shared successfully' : 'Failed to share graph', res.ok ? 'success' : 'error');
      if (res.ok) document.getElementById('shareEmail').value = '';
    }

    function notify(msg, type = 'success', ms = 2500) {
      const n = document.getElementById('notification');
      n.textContent = msg; n.className = `notification ${type}`; n.classList.add('show');
      setTimeout(() => n.classList.remove('show'), ms);
    }

    function adjustConnectionForSeparation(connection, allConnections) {
      // Find parallel connections and adjust them to avoid overlap
      const parallelConnections = findParallelConnections(connection, allConnections);
      
      if (parallelConnections.length > 0) {
        // Apply small offsets to separate parallel edges
        const offset = 8; // pixels
        const index = parallelConnections.indexOf(connection);
        
        if (index > 0) {
          // Apply offset based on connection index
          const offsetAmount = (index * offset) / 2;
          
          // Adjust the connection path slightly
          return applyOffsetToConnection(connection, offsetAmount);
        }
      }
      
      return connection;
    }

    function findParallelConnections(connection, allConnections) {
      const parallel = [connection];
      
      allConnections.forEach(otherConn => {
        if (otherConn.id === connection.id) return;
        
        if (isParallelConnection(connection, otherConn)) {
          parallel.push(otherConn);
        }
      });
      
      return parallel;
    }

    function isParallelConnection(conn1, conn2) {
      // Check if two connections are roughly parallel
      const fromTile1 = tiles.find(t => t.dataset.tileId === conn1.fromTile);
      const toTile1 = tiles.find(t => t.dataset.tileId === conn1.toTile);
      const fromTile2 = tiles.find(t => t.dataset.tileId === conn2.fromTile);
      const toTile2 = tiles.find(t => t.dataset.tileId === conn2.toTile);
      
      if (!fromTile1 || !toTile1 || !fromTile2 || !toTile2) return false;
      
      const rect1 = fromTile1.getBoundingClientRect();
      const rect2 = toTile1.getBoundingClientRect();
      const rect3 = fromTile2.getBoundingClientRect();
      const rect4 = toTile2.getBoundingClientRect();
      
      const canvasRect = canvas.getBoundingClientRect();
      
      // Calculate connection vectors
      const vec1 = {
        x: rect2.left - rect1.left,
        y: rect2.top - rect1.top
      };
      const vec2 = {
        x: rect4.left - rect3.left,
        y: rect4.top - rect3.top
      };
      
      // Normalize vectors
      const len1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
      const len2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
      
      if (len1 === 0 || len2 === 0) return false;
      
      vec1.x /= len1;
      vec1.y /= len1;
      vec2.x /= len2;
      vec2.y /= len2;
      
      // Check if vectors are parallel (dot product close to 1 or -1)
      const dotProduct = vec1.x * vec2.x + vec1.y * vec2.y;
      return Math.abs(dotProduct) > 0.8; // 0.8 = cos(37 degrees)
    }

    function applyOffsetToConnection(connection, offset) {
      // Apply a small perpendicular offset to the connection
      const fromTile = tiles.find(t => t.dataset.tileId === connection.fromTile);
      const toTile = tiles.find(t => t.dataset.tileId === connection.toTile);
      
      if (!fromTile || !toTile) return connection;
      
      const ports = findOptimalPort(fromTile, toTile, connection.fromDot, connection.toDot);
      
      if (ports.fromPort && ports.toPort) {
        // Calculate perpendicular vector
        const dx = ports.toPort.x - ports.fromPort.x;
        const dy = ports.toPort.y - ports.fromPort.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        if (length > 0) {
          // Normalize and rotate 90 degrees
          const perpX = -dy / length;
          const perpY = dx / length;
          
          // Apply offset
          const offsetFromX = ports.fromPort.x + perpX * offset;
          const offsetFromY = ports.fromPort.y + perpY * offset;
          const offsetToX = ports.toPort.x + perpX * offset;
          const offsetToY = ports.toPort.y + perpY * offset;
          
          // Create new connection with offset
          return {
            ...connection,
            offsetFrom: { x: offsetFromX, y: offsetFromY },
            offsetTo: { x: offsetToX, y: offsetToY }
          };
        }
      }
      
      return connection;
    }

    function createNewGraph() {
      const modal = document.getElementById('newGraphModal');
      const input = document.getElementById('newGraphTitle');
      input.value = '';
      modal.classList.add('show');
      input.focus();
      
      // Handle Enter key
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          confirmNewGraph();
        } else if (e.key === 'Escape') {
          closeNewGraphModal();
        }
      };
      
      // Handle click outside to close
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeNewGraphModal();
        }
      };
    }

    function closeNewGraphModal() {
      const modal = document.getElementById('newGraphModal');
      modal.classList.remove('show');
    }

    async function confirmNewGraph() {
      const title = document.getElementById('newGraphTitle').value.trim();
      if (!title) {
        document.getElementById('newGraphTitle').focus();
        return;
      }
      
      const createBtn = document.querySelector('#newGraphModal .modal-btn.primary');
      const originalText = createBtn.textContent;
      createBtn.textContent = 'Creating...';
      createBtn.disabled = true;
      
      try {
        const token = localStorage.getItem('flowpad_token');
        const res = await fetch('/api/graphs', { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title, data: { tiles: [], connections: [] } }) });
        if (!res.ok) {
          notify('Failed to create graph', 'error');
          return;
        }
        const graph = await res.json();
      await loadGraphs();
      loadGraph(graph);
        closeNewGraphModal();
        notify('Graph created successfully!', 'success');
      } catch (error) {
        notify('Failed to create graph: ' + error.message, 'error');
      } finally {
        createBtn.textContent = originalText;
        createBtn.disabled = false;
      }
    }

    async function checkAuth() {
      const token = localStorage.getItem('flowpad_token');
      const user = localStorage.getItem('flowpad_user');
      if (!token || !user) { window.location.href = '/'; return; }
      currentUser = JSON.parse(user);
      document.getElementById('userName').textContent = currentUser.name;
      const ok = await fetch('/api/graphs', { headers: { Authorization: `Bearer ${token}` } }).then(r => r.ok).catch(() => false);
      if (!ok) { localStorage.clear(); window.location.href = '/'; }
    }

    function signOut() { localStorage.clear(); window.location.href = '/'; }

    function el(html) { const d = document.createElement('div'); d.innerHTML = html.trim(); return d.firstChild; }

    async function loadGraphs() {
      const token = localStorage.getItem('flowpad_token');
      const res = await fetch('/api/graphs', { headers: { Authorization: `Bearer ${token}` } });
      if (!res.ok) return;
      const data = await res.json();
      
      // Filter graphs by type since the API returns a flat array with type property
      const ownGraphs = data.filter(g => g.type === 'own');
      const sharedGraphs = data.filter(g => g.type === 'shared');
      
      renderGraphList(ownGraphs, 'ownGraphs');
      renderGraphList(sharedGraphs, 'sharedGraphs');
    }

    function updateTileColorsForTheme(theme) {
      // Update tile colors based on theme
      tiles.forEach(tile => {
        const currentColor = tile.style.background;
        if (currentColor) {
          const newColor = getThemeAdjustedColor(currentColor, theme);
          tile.style.background = newColor;
          
          // Update the selected color in the palette
          const colorOption = tile.querySelector(`[data-color="${currentColor}"]`);
          if (colorOption) {
            colorOption.classList.remove('selected');
          }
          
          const newColorOption = tile.querySelector(`[data-color="${newColor}"]`);
          if (newColorOption) {
            newColorOption.classList.add('selected');
          }
        }
      });
      
      // Re-render to update connections
      renderConnections();
    }

    function getThemeAdjustedColor(color, theme) {
      // Handle white and black colors - reverse them for theme
      if (color === '#ffffff' || color === 'white') {
        return theme === 'light' ? '#2d3748' : '#ffffff';
      }
      if (color === '#000000' || color === 'black' || color === '#212529') {
        return theme === 'light' ? '#ffffff' : '#2d3748';
      }
      
      // For other colors, keep them the same but adjust brightness slightly
      if (theme === 'light') {
        // Make colors slightly lighter in light mode
        return adjustColorBrightness(color, 1.1);
      } else {
        // Make colors slightly darker in dark mode
        return adjustColorBrightness(color, 0.9);
      }
    }

    function adjustColorBrightness(hex, factor) {
      // Convert hex to RGB, adjust brightness, convert back
      const r = Math.min(255, Math.round(parseInt(hex.slice(1, 3), 16) * factor));
      const g = Math.min(255, Math.round(parseInt(hex.slice(3, 5), 16) * factor));
      const b = Math.min(255, Math.round(parseInt(hex.slice(5, 7), 16) * factor));
      
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    function showColorPicker(tile, trigger) {
      const recentColors = getRecentColors();
      const palette = [
        "#ffffff","#f8f9fa","#e9ecef","#dee2e6","#ced4da",
        "#adb5bd","#6c757d","#495057","#343a40","#212529",
        "#ff6b6b","#4ecdc4","#45b7d1","#96ceb4","#feca57",
        "#ff9ff3","#54a0ff","#5f27cd","#00d2d3","#ff9f43"
      ];

      const root = document.createElement('div');
      root.innerHTML = `
        <div class="color-picker-header">
          <span class="color-picker-title">Choose Color</span>
          <button class="color-picker-close">×</button>
        </div>
        <div class="color-picker-grid"></div>
        ${recentColors.length ? `
          <div class="color-picker-recent">
            <div class="color-picker-recent-title">Recent</div>
            <div class="color-picker-recent-grid"></div>
          </div>` : '' }
      `;

      const grid = root.querySelector('.color-picker-grid');
      const push = (c, parent) => {
        const d = document.createElement('div');
        d.className = 'color-picker-option';
        d.style.background = c;
        d.dataset.color = c;
        d.onclick = ()=>{
          tile.style.background = c;
          saveRecentColor(c);
          scheduleSave();
          api.close();
        };
        parent.appendChild(d);
      };

      palette.forEach(c => push(c, grid));
      if (recentColors.length){
        const rg = root.querySelector('.color-picker-recent-grid');
        recentColors.forEach(c => push(c, rg));
      }
      root.querySelector('.color-picker-close').onclick = ()=> api.close();

      const api = openPopover(trigger, root, { prefer:'bottom', offset:10, className:'color-picker-popout', autoClose:false });
    }

    // one way to open: show the same picker
    function showRecentColorsPopup(tile, optionElement){
      showColorPicker(tile, optionElement);
    }

    function updateCollaboratorsList(users) {
      const list = document.getElementById('collaboratorsList');
      const content = document.getElementById('collaboratorsContent');
      const count = document.getElementById('collaboratorsCount');
      
      if (!users || users.length === 0) {
        list.classList.remove('show');
        return;
      }
      
      list.classList.add('show');
      count.textContent = users.length;
      
      content.innerHTML = users.map(user => `
        <div class="collaborator-item">
          <div class="collaborator-avatar">${user.name.charAt(0).toUpperCase()}</div>
          <span class="collaborator-name">${user.name}</span>
          <div class="collaborator-status ${user.status || 'online'}"></div>
        </div>
      `).join('');
    }

    function loadCollaborators() {
      if (!currentGraph) return;
      
      // Hide collaborators list by default
      const collaboratorsList = document.getElementById('collaboratorsList');
      if (collaboratorsList) {
        collaboratorsList.style.display = 'none';
      }
      
      // Only show if there are actual collaborators
      if (currentGraph.sharedUsers && currentGraph.sharedUsers.length > 0) {
        if (collaboratorsList) {
          collaboratorsList.style.display = 'block';
        }
        
        // Simulate loading collaborators (replace with actual API call)
        const collaborators = currentGraph.sharedUsers.map(user => ({
          name: user.email.split('@')[0], // Use email prefix as name
          status: 'online'
        }));
        
        updateCollaboratorsList(collaborators);
      }
    }

    async function showCacheStatus() {
      if (!currentGraph) return;
      
      try {
        const token = localStorage.getItem('flowpad_token');
        const res = await fetch(`/api/graphs/${currentGraph.id}/cache-status`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        
        if (res.ok) {
          const status = await res.json();
          if (status.cached) {
            const timeAgo = Math.round((Date.now() - status.lastModified) / 1000);
            const dirtyText = status.dirty ? ' (unsaved changes)' : ' (saved)';
            notify(`Cache: ${timeAgo}s ago${dirtyText}`, 'success');
          } else {
            notify('Graph not cached', 'error');
          }
        }
      } catch (error) {
        console.error('Failed to get cache status:', error);
      }
    }

    function forceSave() {
      if (!currentGraph) return;
      
      autoSaveGraph();
      notify('Forcing save...', 'success');
    }

    // Add cache status button to toolbar
    function addCacheStatusButton() {
      const toolbar = document.getElementById('toolbar');
      if (toolbar && !toolbar.querySelector('.cache-status-btn')) {
        const cacheBtn = document.createElement('button');
        cacheBtn.className = 'tool-btn cache-status-btn';
        cacheBtn.title = 'Cache Status';
        cacheBtn.textContent = '💾';
        cacheBtn.onclick = showCacheStatus;
        toolbar.appendChild(cacheBtn);
        
        const forceSaveBtn = document.createElement('button');
        forceSaveBtn.className = 'tool-btn force-save-btn';
        forceSaveBtn.title = 'Force Save';
        forceSaveBtn.textContent = '💾!';
        forceSaveBtn.onclick = forceSave;
        toolbar.appendChild(forceSaveBtn);
        
        // Add snap toggles
        const snapGridBtn = document.createElement('button');
        snapGridBtn.className = 'tool-btn snap-grid-btn';
        snapGridBtn.title = 'Snap to Grid';
        snapGridBtn.textContent = '⊞';
        snapGridBtn.onclick = toggleSnapToGrid;
        snapGridBtn.classList.add('active'); // Default enabled
        toolbar.appendChild(snapGridBtn);
        
        const snapTilesBtn = document.createElement('button');
        snapTilesBtn.className = 'tool-btn snap-tiles-btn';
        snapTilesBtn.title = 'Snap to Tiles';
        snapTilesBtn.textContent = '⊟';
        snapTilesBtn.onclick = toggleSnapToTiles;
        snapTilesBtn.classList.add('active'); // Default enabled
        toolbar.appendChild(snapTilesBtn);
        
        // Add grid visualization toggle
        const gridToggleBtn = document.createElement('button');
        gridToggleBtn.className = 'tool-btn grid-toggle-btn';
        gridToggleBtn.title = 'Show Grid';
        gridToggleBtn.textContent = '⊞⊞';
        gridToggleBtn.onclick = toggleGrid;
        toolbar.appendChild(gridToggleBtn);
        
        // Add preset tile buttons
        Object.entries(PRESET_TILES).forEach(([key, preset]) => {
          const presetBtn = document.createElement('button');
          presetBtn.className = 'tool-btn preset-btn';
          presetBtn.title = `Create ${preset.name}`;
          presetBtn.textContent = preset.icon;
          presetBtn.onclick = () => createPresetTile(preset);
          presetBtn.style.background = preset.color;
          presetBtn.style.color = '#fff';
          toolbar.appendChild(presetBtn);
        });
      }
    }
    
    // Update addTile to show preset selection
    function addTile() {
      // Show preset selection popup
      const canvasRect = canvas.getBoundingClientRect();
      const centerX = canvasRect.width / 2;
      const centerY = canvasRect.height / 2;
      
      showPresetPopup(centerX, centerY);
    }
    
    // Add CSS for preset buttons
    const style = document.createElement('style');
    style.textContent = `
      .tool-btn.preset-btn {
        background: var(--accent-primary);
        color: #fff;
        transition: all 0.3s ease;
      }
      .tool-btn.preset-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      }
    `;
    document.head.appendChild(style);

    function toggleSnapToGrid() {
      snapToGrid = !snapToGrid;
      const btn = document.querySelector('.snap-grid-btn');
      btn.classList.toggle('active', snapToGrid);
      btn.title = snapToGrid ? 'Snap to Grid (ON)' : 'Snap to Grid (OFF)';
      notify(`Snap to Grid: ${snapToGrid ? 'ON' : 'OFF'}`, 'success');
    }

    function toggleSnapToTiles() {
      snapToTiles = !snapToTiles;
      const btn = document.querySelector('.snap-tiles-btn');
      btn.classList.toggle('active', snapToTiles);
      btn.title = snapToTiles ? 'Snap to Tiles (ON)' : 'Snap to Tiles (OFF)';
      notify(`Snap to Tiles: ${snapToTiles ? 'ON' : 'OFF'}`, 'success');
    }

    function showAutoSaveStatus() {
      const indicator = document.getElementById('autoSaveIndicator');
      const text = document.getElementById('autoSaveText');
      
      if (isDirty) {
        const timeSinceLastSave = Math.round((Date.now() - lastSaveTime) / 1000);
        text.textContent = `Unsaved changes (${timeSinceLastSave}s ago)`;
        indicator.classList.add('show', 'saving');
      } else {
        text.textContent = `Last saved at ${new Date(lastSaveTime).toLocaleTimeString()}`;
        indicator.classList.add('show', 'saved');
      }
      
      // Hide after 3 seconds
      setTimeout(() => {
        indicator.classList.remove('show', 'saving', 'saved');
      }, 3000);
    }

    function createGridPathWithObstacles(fromX, fromY, toX, toY) {
      // Snap to grid
      const startX = Math.round(fromX / gridSize) * gridSize;
      const startY = Math.round(fromY / gridSize) * gridSize;
      const endX = Math.round(toX / gridSize) * gridSize;
      const endY = Math.round(toY / gridSize) * gridSize;
      
      // Simple 90-degree routing with basic obstacle avoidance
      const path = [];
      path.push({ x: startX, y: startY });
      
      // Calculate grid coordinates
      const startGridX = Math.round(startX / gridSize);
      const startGridY = Math.round(startY / gridSize);
      const endGridX = Math.round(endX / gridSize);
      const endGridY = Math.round(endY / gridSize);
      
      // Determine routing strategy
      const deltaX = endGridX - startGridX;
      const deltaY = endGridY - startGridY;
      
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal first routing
        if (deltaX !== 0) {
          // Move horizontally to target X
          path.push({ x: endX, y: startY });
        }
        if (deltaY !== 0) {
          // Move vertically to target Y
          path.push({ x: endX, y: endY });
        }
      } else {
        // Vertical first routing
        if (deltaY !== 0) {
          // Move vertically to target Y
          path.push({ x: startX, y: endY });
        }
        if (deltaX !== 0) {
          // Move horizontally to target X
          path.push({ x: endX, y: endY });
        }
      }
      
      // Add end point
      path.push({ x: endX, y: endY });
      
      return path;
    }

    function optimizeGridPath(path) {
      // Remove unnecessary waypoints for cleaner paths
      const optimized = [path[0]];
      
      for (let i = 1; i < path.length - 1; i++) {
        const prev = path[i - 1];
        const current = path[i];
        const next = path[i + 1];
        
        // Check if current point is necessary
        const isHorizontal = Math.abs(current.x - prev.x) > 0 && Math.abs(current.x - next.x) > 0;
        const isVertical = Math.abs(current.y - prev.y) > 0 && Math.abs(current.y - next.y) > 0;
        
        if (isHorizontal || isVertical) {
          optimized.push(current);
        }
      }
      
      optimized.push(path[path.length - 1]);
      return optimized;
    }

    function adjustGridPathForSeparation(path, connectionIndex, totalConnections) {
      if (totalConnections <= 1) return path;
      
      // Calculate separation offset based on connection index
      const separation = 8; // pixels between parallel lines
      const offset = (connectionIndex - (totalConnections - 1) / 2) * separation;
      
      // Apply offset to middle segments (avoiding start and end points)
      const adjustedPath = [...path];
      
      for (let i = 1; i < adjustedPath.length - 1; i++) {
        const segment = adjustedPath[i];
        const prevSegment = adjustedPath[i - 1];
        
        // Determine if this is a horizontal or vertical segment
        if (Math.abs(segment.x - prevSegment.x) > 0) {
          // Horizontal segment - offset vertically
          segment.y += offset;
        } else {
          // Vertical segment - offset horizontally
          segment.x += offset;
        }
      }
      
      return adjustedPath;
    }



    let selectedElement = null;
    let floatingToolbar = null;
    let secondaryPopup = null;
    let toolbarTimeout = null;
    
    // Create floating toolbar
    function createFloatingToolbar() {
      if (floatingToolbar) return floatingToolbar;
      
      floatingToolbar = document.createElement('div');
      floatingToolbar.className = 'floating-toolbar';
      floatingToolbar.innerHTML = `
        <div class="toolbar-section">
          <div class="toolbar-section-title">Type</div>
          <div class="toolbar-row">
            <button class="toolbar-button" data-action="type" data-type="general" title="Change Type">⚙️</button>
          </div>
        </div>
        <div class="toolbar-section">
          <div class="toolbar-section-title">Style</div>
          <div class="toolbar-row">
            <button class="toolbar-button" data-action="style" data-style="general" title="Change Style">🎨</button>
          </div>
        </div>
        <div class="toolbar-section">
          <div class="toolbar-section-title">Color</div>
          <div class="toolbar-row">
            <div class="toolbar-color-picker" data-action="color" title="Change Color"></div>
          </div>
        </div>
        <div class="toolbar-section">
          <div class="toolbar-row">
            <button class="toolbar-button small" data-action="delete" title="Delete">🗑️</button>
            <button class="toolbar-button small" data-action="duplicate" title="Duplicate">📋</button>
          </div>
        </div>
      `;
      
      // Add event listeners
      floatingToolbar.addEventListener('click', handleToolbarAction);
      
      document.body.appendChild(floatingToolbar);
      return floatingToolbar;
    }
    
    // Create secondary popup
    function createSecondaryPopup() {
      if (secondaryPopup) return secondaryPopup;
      
      secondaryPopup = document.createElement('div');
      secondaryPopup.className = 'secondary-popup';
      secondaryPopup.innerHTML = `
        <div class="popup-header">
          <div class="popup-title">Select Option</div>
          <button class="popup-close">×</button>
        </div>
        <div class="popup-content"></div>
      `;
      
      // Add event listeners
      secondaryPopup.querySelector('.popup-close').addEventListener('click', hideSecondaryPopup);
      
      document.body.appendChild(secondaryPopup);
      return secondaryPopup;
    }
    
    // Show floating toolbar
    function showFloatingToolbar(element, x, y) {
      const toolbar = createFloatingToolbar();
      const popup = createSecondaryPopup();
      
      // Position toolbar
      toolbar.style.left = (x + 10) + 'px';
      toolbar.style.top = (y - 10) + 'px';
      
      // Adjust position if it goes off screen
      const rect = toolbar.getBoundingClientRect();
      if (rect.right > window.innerWidth) {
        toolbar.style.left = (x - rect.width - 10) + 'px';
      }
      if (rect.bottom > window.innerHeight) {
        toolbar.style.top = (y - rect.height - 10) + 'px';
      }
      
      // Set toolbar type
      if (element.classList.contains('tile')) {
        toolbar.classList.add('tile-toolbar');
        setupTileToolbar(toolbar, element);
      } else if (element.classList.contains('connection-line')) {
        toolbar.classList.add('connection-toolbar');
        setupConnectionToolbar(toolbar, element);
      }
      
      toolbar.classList.add('show');
      selectedElement = element;
      
      // Auto-hide after delay
      clearTimeout(toolbarTimeout);
      toolbarTimeout = setTimeout(() => {
        if (!toolbar.matches(':hover') && !popup.matches(':hover')) {
          hideFloatingToolbar();
        }
      }, 3000);
    }
    
    // Hide floating toolbar
    function hideFloatingToolbar() {
      if (floatingToolbar) {
        floatingToolbar.classList.remove('show');
      }
      if (secondaryPopup) {
        secondaryPopup.classList.remove('show');
      }
      selectedElement = null;
      clearTimeout(toolbarTimeout);
    }
    
    // Setup tile toolbar
    function setupTileToolbar(toolbar, tile) {
      // Update color picker
      const colorPicker = toolbar.querySelector('.toolbar-color-picker');
      const tileColor = tile.style.backgroundColor || '#ffffff';
      colorPicker.style.setProperty('--tile-color', tileColor);
      
      // Update type button
      const typeBtn = toolbar.querySelector('[data-action="type"]');
      const currentShape = tile.dataset.shape || 'rectangle';
      typeBtn.textContent = getShapeIcon(currentShape);
      typeBtn.title = `Current: ${currentShape}`;
    }
    
    // Setup connection toolbar
    function setupConnectionToolbar(toolbar, connection) {
      // Update color picker
      const colorPicker = toolbar.querySelector('.toolbar-color-picker');
      const lineColor = connection.getAttribute('stroke') || '#007AFF';
      colorPicker.style.setProperty('--tile-color', lineColor);
      
      // Update style button
      const styleBtn = toolbar.querySelector('[data-action="style"]');
      const currentStyle = connection.dataset.style || 'solid';
      styleBtn.textContent = getStyleIcon(currentStyle);
      styleBtn.title = `Current: ${currentStyle}`;
    }
    
    // Get shape icon
    function getShapeIcon(shape) {
      const icons = {
        'rectangle': '□',
        'rounded': '◐',
        'circular': '○',
        'hexagon': '⬡',
        'diamond': '◇',
        'triangle': '△'
      };
      return icons[shape] || '□';
    }
    
    // Get style icon
    function getStyleIcon(style) {
      const icons = {
        'solid': '━',
        'dashed': '┅',
        'dotted': '┄',
        'dash-dot': '┄━'
      };
      return icons[style] || '━';
    }
    
    // Handle toolbar actions
    function handleToolbarAction(e) {
      const button = e.target.closest('[data-action]');
      if (!button) return;
      
      const action = button.dataset.action;
      
      switch (action) {
        case 'type':
          showTypePopup(button);
          break;
        case 'style':
          showStylePopup(button);
          break;
        case 'color':
          showColorPopup(button);
          break;
        case 'delete':
          deleteSelectedElement();
          break;
        case 'duplicate':
          duplicateSelectedElement();
          break;
      }
    }
    
    // Show type popup
    function showTypePopup(button) {
      const popup = createSecondaryPopup();
      const content = popup.querySelector('.popup-content');
      
      if (selectedElement.classList.contains('tile')) {
        // Tile shapes
        const shapes = ['rectangle', 'rounded', 'circular', 'hexagon', 'diamond', 'triangle'];
        content.innerHTML = shapes.map(shape => 
          `<div class="popup-option" data-type="shape" data-value="${shape}">${getShapeIcon(shape)}</div>`
        ).join('');
      } else {
        // Connection types
        const types = ['arrow', 'line', 'dot', 'diamond'];
        content.innerHTML = types.map(type => 
          `<div class="popup-option" data-type="connection" data-value="${type}">${getConnectionIcon(type)}</div>`
        ).join('');
      }
      
      // Add event listeners
      content.addEventListener('click', handlePopupSelection);
      
      // Position popup
      const buttonRect = button.getBoundingClientRect();
      popup.style.left = (buttonRect.right + 10) + 'px';
      popup.style.top = buttonRect.top + 'px';
      
      popup.classList.add('show');
    }
    
    // Show style popup
    function showStylePopup(button) {
      const popup = createSecondaryPopup();
      const content = popup.querySelector('.popup-content');
      
      const styles = ['solid', 'dashed', 'dotted', 'dash-dot'];
      content.innerHTML = styles.map(style => 
        `<div class="popup-option" data-type="style" data-value="${style}">${getStyleIcon(style)}</div>`
      ).join('');
      
      // Add event listeners
      content.addEventListener('click', handlePopupSelection);
      
      // Position popup
      const buttonRect = button.getBoundingClientRect();
      popup.style.left = (buttonRect.right + 10) + 'px';
      popup.style.top = buttonRect.top + 'px';
      
      popup.classList.add('show');
    }
    
    // Show color popup
    function showColorPopup(button) {
      const popup = createSecondaryPopup();
      const content = popup.querySelector('.popup-content');
      
      const colors = ['#ffffff', '#000000', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'];
      content.innerHTML = colors.map(color => 
        `<div class="popup-option" data-type="color" data-value="${color}" style="background-color: ${color}"></div>`
      ).join('');
      
      // Add event listeners
      content.addEventListener('click', handlePopupSelection);
      
      // Position popup
      const buttonRect = button.getBoundingClientRect();
      popup.style.left = (buttonRect.right + 10) + 'px';
      popup.style.top = buttonRect.top + 'px';
      
      popup.classList.add('show');
    }
    
    // Handle popup selection
    function handlePopupSelection(e) {
      const option = e.target.closest('.popup-option');
      if (!option) return;
      
      const type = option.dataset.type;
      const value = option.dataset.value;
      
      if (selectedElement) {
        switch (type) {
          case 'shape':
            changeTileShape(selectedElement, value);
            break;
          case 'connection':
            changeConnectionType(selectedElement, value);
            break;
          case 'style':
            changeConnectionStyle(selectedElement, value);
            break;
          case 'color':
            changeElementColor(selectedElement, value);
            break;
        }
      }
      
      hideSecondaryPopup();
      updateToolbar();
    }
    
    // Change tile shape
    function changeTileShape(tile, shape) {
      tile.className = `tile ${shape}`;
      tile.dataset.shape = shape;
      
      // Update connections
      renderConnections();
      
      // Mark as dirty
      markAsDirty();
    }
    
    // Change connection type
    function changeConnectionType(connection, type) {
      connection.dataset.connectionType = type;
      
      // Update marker
      const markerId = type === 'arrow' ? 'arrowhead' : 
                      type === 'dot' ? 'dotmarker' : 
                      type === 'diamond' ? 'diamondmarker' : null;
      
      if (markerId) {
        connection.setAttribute('marker-end', `url(#${markerId})`);
      } else {
        connection.removeAttribute('marker-end');
      }
      
      // Mark as dirty
      markAsDirty();
    }
    
    // Change connection style
    function changeConnectionStyle(connection, style) {
      connection.dataset.style = style;
      
      // Update stroke dasharray
      const dashArray = {
        'solid': 'none',
        'dashed': '5,5',
        'dotted': '2,2',
        'dash-dot': '10,2,2,2'
      };
      
      connection.setAttribute('stroke-dasharray', dashArray[style] || 'none');
      
      // Mark as dirty
      markAsDirty();
    }
    
    // Change element color
    function changeElementColor(element, color) {
      if (element.classList.contains('tile')) {
        element.style.backgroundColor = color;
        element.dataset.color = color;
      } else if (element.classList.contains('connection-line')) {
        element.setAttribute('stroke', color);
        element.dataset.color = color;
      }
      
      // Mark as dirty
      markAsDirty();
    }
    
    // Delete selected element
    function deleteSelectedElement() {
      if (selectedElement) {
        if (selectedElement.classList.contains('tile')) {
          deleteSelected();
        } else if (selectedElement.classList.contains('connection-line')) {
          const fromTile = selectedElement.dataset.fromTile;
          const toTile = selectedElement.dataset.toTile;
          deleteConnection(fromTile, toTile);
        }
        hideFloatingToolbar();
      }
    }
    
    // Duplicate selected element
    function duplicateSelectedElement() {
      if (selectedElement && selectedElement.classList.contains('tile')) {
        const rect = selectedElement.getBoundingClientRect();
        const newTile = createTile(
          rect.left + 20,
          rect.top + 20,
          selectedElement.querySelector('.tile-title').value + ' (Copy)',
          selectedElement.querySelector('.tile-content').value,
          null,
          selectedElement.dataset.shape || 'rectangle'
        );
        
        // Copy color
        if (selectedElement.dataset.color) {
          newTile.style.backgroundColor = selectedElement.dataset.color;
          newTile.dataset.color = selectedElement.dataset.color;
        }
        
        tiles.push(newTile);
        renderCanvas();
        renderConnections();
        
        // Mark as dirty
        markAsDirty();
      }
    }
    
    // Update toolbar
    function updateToolbar() {
      if (floatingToolbar && selectedElement) {
        if (selectedElement.classList.contains('tile')) {
          setupTileToolbar(floatingToolbar, selectedElement);
        } else if (selectedElement.classList.contains('connection-line')) {
          setupConnectionToolbar(floatingToolbar, selectedElement);
        }
      }
    }
    
    // Hide secondary popup
    function hideSecondaryPopup() {
      if (secondaryPopup) {
        secondaryPopup.classList.remove('show');
      }
    }

    let _tileToolbar = null;

    function addTileClickHandler(tile){
      tile.addEventListener('click',(e)=>{
        // Ignore direct edits inside textareas
        if (e.target.closest('textarea')) return;
        selectTile(tile);
        showTileToolbar(tile, e);
      });
    }

    function showTileToolbar(tile, event){
      hideFloatingToolbar();

      const wrap = document.createElement('div');
      wrap.innerHTML = `
        <div class="toolbar-section">
          <div class="toolbar-row">
            <button class="toolbar-button" title="Color" id="tb-color">🎨</button>
            <button class="toolbar-button" title="Duplicate" id="tb-dup">⎘</button>
            <button class="toolbar-button" title="Delete" id="tb-del">🗑️</button>
          </div>
        </div>
      `;

      wrap.querySelector('#tb-color').onclick = (ev)=> showColorPicker(tile, ev.currentTarget);
      wrap.querySelector('#tb-dup').onclick   = ()=>{
        const x = (parseInt(tile.dataset.baseX)||0) + 24;
        const y = (parseInt(tile.dataset.baseY)||0) + 24;
        const t2 = createTile(x, y,
          tile.querySelector('.tile-title').value,
          tile.querySelector('.tile-content').value
        );
        tiles.push(t2); canvas.appendChild(t2); scheduleSave(); renderCanvas(); selectTile(t2);
      };
      wrap.querySelector('#tb-del').onclick   = ()=> { selectedTile = tile; deleteSelected(); };

      _tileToolbar = openPopover(tile, wrap, { prefer:'top', offset:10, className:'floating-toolbar tile-toolbar', autoClose:false });
    }

    function hideFloatingToolbar(){
      if (_tileToolbar){ _tileToolbar.close(); _tileToolbar = null; }
    }

    // Get connection icon
    function getConnectionIcon(type) {
      const icons = {
        'arrow': '→',
        'line': '─',
        'dot': '●',
        'diamond': '◆'
      };
      return icons[type] || '→';
    }
    
    // Add global click handler to hide toolbars
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.floating-toolbar') && !e.target.closest('.secondary-popup')) {
        hideFloatingToolbar();
      }
    });
    
    // Add escape key handler
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideFloatingToolbar();
      }
    });

    // Preset tile types
    const PRESET_TILES = {
      title: {
        name: 'Title',
        description: 'Main heading tile',
        icon: '📝',
        shape: 'rounded',
        color: '#667eea',
        defaultContent: 'Title',
        defaultTitle: 'Main Title'
      },
      notes: {
        name: 'Notes',
        description: 'Text content tile',
        icon: '📝',
        shape: 'rectangle',
        color: '#f093fb',
        defaultContent: 'Add your notes here...',
        defaultTitle: 'Notes'
      },
      component: {
        name: 'Component',
        description: 'Functional element',
        icon: '⚙️',
        shape: 'hexagon',
        color: '#4facfe',
        defaultContent: 'Component description',
        defaultTitle: 'Component'
      },
      custom: {
        name: 'Custom',
        description: 'Create your own type',
        icon: '✨',
        shape: 'rectangle',
        color: '#43e97b',
        defaultContent: 'Custom content',
        defaultTitle: 'Custom'
      }
    };
    
    // Long press variables
    let longPressTimer = null;
    let longPressThreshold = 500; // milliseconds
    let isLongPressing = false;
    let longPressIndicator = null;
    
    // Create long press indicator
    function createLongPressIndicator() {
      if (longPressIndicator) return longPressIndicator;
      
      longPressIndicator = document.createElement('div');
      longPressIndicator.className = 'long-press-indicator';
      longPressIndicator.innerHTML = '⏱️';
      longPressIndicator.style.display = 'none';
      
      document.body.appendChild(longPressIndicator);
      return longPressIndicator;
    }
    
    // Show preset selection popup
    function showPresetPopup(viewportX, viewportY){
      const el = document.createElement('div');
      el.className = 'preset-popup';
      const grid = document.createElement('div');
      grid.className = 'preset-grid';

      Object.entries(PRESET_TILES).forEach(([key, p])=>{
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.innerHTML = `
          <div class="preset-item-icon">${p.icon}</div>
          <div class="preset-item-label">${p.label}</div>
          <div class="preset-item-desc">${p.desc}</div>`;
        item.onclick = ()=>{
          const c = canvas.getBoundingClientRect();
          const x = viewportX - c.left - canvasOffset.x;
          const y = viewportY - c.top  - canvasOffset.y;
          const t = createTile(x, y, p.initial.title, p.initial.content);
          tiles.push(t); renderCanvas(); selectTile(t); scheduleSave();
          api.close();
        };
        grid.appendChild(item);
      });
      el.appendChild(grid);

      const fakeRect = { left: viewportX-1, top: viewportY-1, width:2, height:2, bottom: viewportY+1, right: viewportX+1 };
      const api = openPopover(fakeRect, el, { prefer:'bottom', offset:12, className:'preset-popup show', autoClose:false });
    }

    // Share permission system
    let currentSharePermission = 'viewer';
    
    // Initialize permission selector
    function initializePermissionSelector() {
      const permissionOptions = document.querySelectorAll('.permission-option');
      
      permissionOptions.forEach(option => {
        option.addEventListener('click', () => {
          // Remove selected class from all options
          permissionOptions.forEach(opt => opt.classList.remove('selected'));
          
          // Add selected class to clicked option
          option.classList.add('selected');
          
          // Update current permission
          const radio = option.querySelector('input[type="radio"]');
          radio.checked = true;
          currentSharePermission = radio.value;
          
          // Update share button state
          updateShareButtonState();
        });
        
        // Set initial selected state
        if (option.querySelector('input[type="radio"]').checked) {
          option.classList.add('selected');
        }
      });
    }
    
    // Update share button state based on permission
    function updateShareButtonState() {
      const shareBtn = document.querySelector('.share-btn');
      const shareEmail = document.getElementById('shareEmail');
      
      if (shareEmail.value.trim() === '') {
        shareBtn.disabled = true;
        shareBtn.textContent = 'Enter Email';
      } else {
        shareBtn.disabled = false;
        shareBtn.textContent = `Share as ${currentSharePermission}`;
      }
    }
    
    // Enhanced share graph function with permissions
    async function shareGraph() {
      const email = document.getElementById('shareEmail').value.trim();
      if (!email) {
        notify('Please enter an email address', 'error');
        return;
      }
      
      if (!currentGraph) {
        notify('No graph selected', 'error');
        return;
      }
      
      try {
        const response = await fetch(`/api/graphs/${currentGraph}/share`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          },
          body: JSON.stringify({
            email: email,
            permission: currentSharePermission
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          notify(`Graph shared with ${email} as ${currentSharePermission}`, 'success');
          
          // Clear email input
          document.getElementById('shareEmail').value = '';
          updateShareButtonState();
          
          // Refresh shared users list
          loadSharedUsers();
          
          // Mark as dirty
          markAsDirty();
        } else {
          const error = await response.json();
          notify(`Failed to share: ${error.message}`, 'error');
        }
      } catch (error) {
        console.error('Error sharing graph:', error);
        notify('Failed to share graph', 'error');
      }
    }
    
    // Load shared users for current graph
    async function loadSharedUsers() {
      if (!currentGraph) return;
      
      try {
        const response = await fetch(`/api/graphs/${currentGraph}/shared-users`, {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          }
        });
        
        if (response.ok) {
          const sharedUsers = await response.json();
          renderSharedUsers(sharedUsers);
        }
      } catch (error) {
        console.error('Error loading shared users:', error);
      }
    }
    
    // Render shared users list
    function renderSharedUsers(sharedUsers) {
      const container = document.getElementById('sharedUsersList');
      
      if (sharedUsers.length === 0) {
        container.innerHTML = '<div style="text-align:center;color:var(--text-secondary);padding:16px;">No users shared yet</div>';
        return;
      }
      
      container.innerHTML = sharedUsers.map(user => `
        <div class="shared-user-item">
          <div class="shared-user-info">
            <div class="shared-user-email">${user.email}</div>
            <div class="shared-user-permission">${user.permission} access</div>
          </div>
          <div class="shared-user-actions">
            <button class="change-permission-btn" onclick="changeUserPermission('${user.email}')">Change</button>
            <button class="remove-user-btn" onclick="removeSharedUser('${user.email}')">Remove</button>
          </div>
        </div>
      `).join('');
    }

    // Change user permission
    async function changeUserPermission(userEmail) {
      if (!currentGraph) return;
      
      try {
        const token = localStorage.getItem('flowpad_token');
        const newPermission = prompt('Enter new permission (viewer/editor):', 'viewer');
        
        if (newPermission && ['viewer', 'editor'].includes(newPermission.toLowerCase())) {
          const response = await fetch(`/api/graphs/${currentGraph.id}/change-permission`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
              userEmail: userEmail,
              permission: newPermission.toLowerCase()
            })
          });
          
          if (response.ok) {
            notify('Permission updated successfully', 'success');
            // Refresh the shared users list
            await loadSharedUsers();
          } else {
            notify('Failed to update permission', 'error');
          }
        }
      } catch (error) {
        console.error('Error changing permission:', error);
        notify('Failed to update permission', 'error');
      }
    }

    // Remove shared user
    async function removeSharedUser(userEmail) {
      if (!currentGraph) return;
      
      if (confirm(`Are you sure you want to remove ${userEmail} from this graph?`)) {
        try {
          const token = localStorage.getItem('flowpad_token');
          const response = await fetch(`/api/graphs/${currentGraph.id}/remove-user`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ userEmail: userEmail })
          });
          
          if (response.ok) {
            notify('User removed successfully', 'success');
            // Refresh the shared users list
            await loadSharedUsers();
          } else {
            notify('Failed to remove user', 'error');
          }
        } catch (error) {
          console.error('Error removing user:', error);
          notify('Failed to remove user', 'error');
        }
      }
    }

    function addCacheStatusButton(){ /* no-op; wire up later if needed */ }

    function initializePermissionSelector(){
      const options = document.querySelectorAll('.permission-option');
      options.forEach(opt=>{
        opt.addEventListener('click', ()=>{
          options.forEach(o=>o.classList.remove('selected'));
          opt.classList.add('selected');
          const input = opt.querySelector('input[type="radio"]');
          if (input) input.checked = true;
        });
      });
    }

    function updateShareButtonState(){
      const emailEl = document.getElementById('shareEmail');
      const btn = document.querySelector('.share-btn');
      if (!emailEl || !btn) return;
      const email = emailEl.value.trim();
      const ok = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
      btn.disabled = !ok;
    }
  </script>
</body>
</html>