<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flowpad - Dashboard</title>
  <style>
    :root {
      --bg-primary: #1a1a1a;
      --bg-secondary: #2d2d2d;
      --bg-tertiary: rgba(0,0,0,0.9);
      --bg-sidebar: rgba(0,0,0,0.8);
      --bg-tile: #fff;
      --bg-tile-hover: #f8f9fa;
      --text-primary: #fff;
      --text-secondary: #ccc;
      --text-tile: #000;
      --border-primary: #333;
      --border-secondary: #555;
      --accent-primary: #4CAF50;
      --accent-secondary: #45a049;
      --shadow-primary: rgba(0,0,0,0.3);
      --shadow-secondary: rgba(0,0,0,0.2);
      --grid-color: rgba(255,255,255,0.03);
    }

    :root[data-theme="light"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9fa;
      --bg-tertiary: rgba(255,255,255,0.95);
      --bg-sidebar: rgba(255,255,255,0.95);
      --bg-tile: #ffffff;
      --bg-tile-hover: #f8f9fa;
      --text-primary: #2d3748;
      --text-secondary: #4a5568;
      --text-tile: #000000;
      --border-primary: #e2e8f0;
      --border-secondary: #cbd5e0;
      --shadow-primary: rgba(0,0,0,0.1);
      --shadow-secondary: rgba(0,0,0,0.05);
      --grid-color: rgba(0,0,0,0.03);
    }

    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;background:var(--bg-primary);background-image:linear-gradient(var(--grid-color) 1px,transparent 1px),linear-gradient(90deg,var(--grid-color) 1px,transparent 1px);background-size:20px 20px;color:var(--text-primary);overflow:hidden;transition:all 0.3s ease}
    
    .header{position:fixed;inset:0 0 auto 0;height:60px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border-bottom:1px solid var(--border-primary);display:flex;align-items:center;justify-content:space-between;padding:0 20px;z-index:1000;transition:all 0.3s ease}
    .logo{font-size:1.5rem;font-weight:700;background:linear-gradient(45deg,var(--text-primary),var(--text-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .user-info{display:flex;align-items:center;gap:15px}
    .signout-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 16px;border-radius:6px;cursor:pointer;transition:all 0.3s ease}
    .signout-btn:hover{background:var(--border-secondary)}
    
    .theme-toggle{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 12px;border-radius:6px;cursor:pointer;margin-right:10px;transition:all 0.3s ease}
    .theme-toggle:hover{background:var(--border-secondary)}
    
    .sidebar{position:fixed;left:0;top:60px;bottom:0;width:300px;background:var(--bg-sidebar);backdrop-filter:blur(20px);border-right:1px solid var(--border-primary);overflow-y:auto;transition:all 0.3s ease}
    .sidebar-content{padding:20px}
    .section-title{font-size:1.1rem;font-weight:600;margin-bottom:15px;color:var(--text-primary)}
    .new-graph-btn{background:var(--accent-primary);color:#fff;border:none;padding:12px 20px;border-radius:8px;cursor:pointer;width:100%;font-size:1rem;margin-bottom:20px;transition:all 0.3s ease}
    .new-graph-btn:hover{background:var(--accent-secondary)}
    .graph-item{background:rgba(255,255,255,0.05);border:1px solid var(--border-primary);border-radius:8px;padding:15px;margin-bottom:10px;cursor:pointer;transition:all 0.3s ease}
    .graph-item:hover{background:rgba(255,255,255,0.1)}
    .graph-title{font-weight:600;margin-bottom:5px;color:var(--text-primary)}
    .graph-meta{font-size:.8rem;color:var(--text-secondary)}
    
    .canvas-container{position:fixed;left:300px;top:60px;right:0;bottom:0;overflow:hidden}
    .canvas{width:100%;height:100%;background-image:linear-gradient(var(--grid-color) 1px,transparent 1px),linear-gradient(90deg,var(--grid-color) 1px,transparent 1px);background-size:20px 20px;position:relative;cursor:grab}

    
    .tile{position:absolute;background:var(--bg-tile);color:var(--text-tile);border:2px solid var(--border-primary);border-radius:12px;padding:20px;min-width:150px;min-height:100px;cursor:move;user-select:none;box-shadow:0 8px 25px var(--shadow-primary);transition:all 0.3s ease;resize:both;overflow:hidden}
    .tile:hover{background:var(--bg-tile-hover);box-shadow:0 12px 35px var(--shadow-secondary)}
    .tile.selected{border-color:var(--accent-primary);box-shadow:0 0 0 3px rgba(76, 175, 80, 0.3)}
    .tile-title,.tile-content{border:none;background:transparent;width:100%;outline:none;font-family:inherit;resize:none}
    .tile-title{font-weight:600;margin-bottom:12px;font-size:1rem;color:var(--text-tile)}
    .tile-content{font-size:0.9rem;line-height:1.5;min-height:50px;color:var(--text-tile)}
    
    .color-palette{position:absolute;top:10px;right:10px;display:grid;grid-template-columns:repeat(5,1fr);gap:4px;opacity:0;transition:opacity 0.3s ease;width:120px}
    .tile:hover .color-palette{opacity:1}
    .color-option{width:20px;height:20px;border-radius:50%;border:2px solid var(--border-primary);cursor:pointer;transition:all 0.3s ease}
    .color-option:hover{transform:scale(1.2);border-color:var(--accent-primary)}
    .color-option.selected{border-color:var(--accent-primary);box-shadow:0 0 0 2px var(--accent-primary)}
    
    .connection-dot{position:absolute;width:12px;height:12px;background:var(--accent-primary);border:2px solid #fff;border-radius:50%;cursor:crosshair;z-index:10;transition:all 0.3s ease}
    .connection-dot:hover{transform:scale(1.2);background:var(--accent-secondary)}
    .connection-dot.input{left:-6px;top:50%;transform:translateY(-50%)}
    .connection-dot.output{right:-6px;top:50%;transform:translateY(-50%)}
    .connection-dot.top{top:-6px;left:50%;transform:translateX(-50%)}
    .connection-dot.bottom{bottom:-6px;left:50%;transform:translateX(-50%)}
    
    .connection{position:absolute;pointer-events:none;z-index:5}
    .connection-line{stroke:var(--accent-primary);stroke-width:3;fill:none;marker-end:url(#arrowhead);filter:drop-shadow(0 2px 4px var(--shadow-primary))}
    .connection-line:hover{stroke:var(--accent-secondary);stroke-width:4}
    
    .toolbar{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:15px;z-index:1000;min-width:200px;transition:all 0.3s ease}
    .tool-label{color:var(--text-secondary);font-size:.8rem;margin-bottom:8px;text-align:center;font-weight:500}
    .tool-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px;border-radius:6px;cursor:pointer;margin:2px;width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;font-size:1rem;transition:all 0.3s ease}
    .tool-btn:hover{background:var(--border-secondary)}
    .tool-btn.active{background:var(--accent-primary);color:#fff}
    
    .ai-panel{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:20px;z-index:1000;width:300px;display:none;transition:all 0.3s ease}
    .ai-panel.show{display:block}
    .ai-title{font-size:1.1rem;font-weight:600;margin-bottom:15px;color:var(--text-primary)}
    .ai-input{width:100%;padding:10px;border:1px solid var(--border-secondary);border-radius:6px;background:var(--bg-secondary);color:var(--text-primary);margin-bottom:15px;resize:vertical;min-height:80px}
    .ai-btn{background:var(--accent-primary);color:#fff;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;width:100%;transition:all 0.3s ease}
    .ai-btn:hover{background:var(--accent-secondary)}
    .ai-btn:disabled{background:var(--border-secondary);cursor:not-allowed}
    .ai-suggestions{margin-top:15px;max-height:200px;overflow-y:auto}
    .ai-suggestion{background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;padding:10px;margin-bottom:8px;cursor:pointer;transition:all 0.3s ease}
    .ai-suggestion:hover{background:var(--border-primary)}
    
    .notification{position:fixed;top:80px;right:20px;background:var(--accent-primary);color:#fff;padding:12px 20px;border-radius:8px;box-shadow:0 4px 12px var(--shadow-primary);z-index:10000;transform:translateX(400px);transition:.3s transform;max-width:300px}
    .notification.show{transform:translateX(0)}
    .notification.error{background:#f44336}
    
    .connection-mode{position:fixed;top:70px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:15px;z-index:1000;margin-bottom:10px}
    .connection-mode-btn{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 16px;border-radius:6px;cursor:pointer;margin:2px;transition:all 0.3s ease}
    .connection-mode-btn:hover{background:var(--border-secondary)}
    .connection-mode-btn.active{background:var(--accent-primary);color:#fff}
    
    .loading{display:inline-block;width:16px;height:16px;border:2px solid transparent;border-top:2px solid currentColor;border-radius:50%;animation:spin 1s linear infinite;margin-right:8px}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
    
    .modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);backdrop-filter:blur(5px);z-index:10000;display:none;align-items:center;justify-content:center}
    .modal-overlay.show{display:flex}
    .modal{background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:12px;padding:30px;min-width:400px;max-width:600px;box-shadow:0 20px 40px var(--shadow-primary)}
    .modal-title{font-size:1.3rem;font-weight:600;margin-bottom:20px;color:var(--text-primary)}
    .modal-input{width:100%;padding:15px;border:1px solid var(--border-secondary);border-radius:8px;background:var(--bg-secondary);color:var(--text-primary);font-size:1rem;margin-bottom:20px;outline:none;transition:border-color 0.3s ease}
    .modal-input:focus{border-color:var(--accent-primary)}
    .modal-buttons{display:flex;gap:10px;justify-content:flex-end}
    .modal-btn{padding:12px 24px;border:none;border-radius:8px;cursor:pointer;font-size:1rem;transition:all 0.3s ease}
    .modal-btn.primary{background:var(--accent-primary);color:#fff}
    .modal-btn.primary:hover{background:var(--accent-secondary)}
    .modal-btn.secondary{background:var(--border-primary);color:var(--text-primary)}
    .modal-btn.secondary:hover{background:var(--border-secondary)}
    
    .recent-colors-popup{position:absolute;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:8px;padding:10px;box-shadow:0 10px 25px var(--shadow-primary);z-index:1000;display:grid;grid-template-columns:repeat(5,1fr);gap:5px;min-width:200px}
    .recent-colors-popup .color-option{width:25px;height:25px;border-radius:4px;cursor:pointer;border:2px solid transparent;transition:all 0.2s ease}
    .recent-colors-popup .color-option:hover{border-color:var(--accent-primary);transform:scale(1.1)}
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">Flowpad</div>
    <div class="user-info">
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <span id="theme-icon">🌙</span>
      </button>
      <span id="userName">User</span>
      <button class="signout-btn" onclick="signOut()">Sign Out</button>
    </div>
  </div>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-content">
      <button class="new-graph-btn" onclick="createNewGraph()">+ New Graph</button>
      <div class="section-title">My Graphs</div>
      <div id="ownGraphs"></div>
      <div class="section-title">Shared With Me</div>
      <div id="sharedGraphs"></div>
      <div class="section-title" id="shareHeader" style="display:none;">Share Current Graph</div>
      <input type="email" id="shareEmail" placeholder="Enter email address" style="display:none;width:100%;padding:8px;border-radius:6px;border:1px solid var(--border-secondary);background:var(--bg-secondary);color:var(--text-primary)"/>
      <button id="shareBtn" style="display:none;margin-top:8px" class="new-graph-btn" onclick="shareGraph()">Share</button>
    </div>
  </div>
  
  <div class="canvas-container">
    <div class="canvas" id="canvas"></div>
  </div>
  
  <div class="connection-mode" id="connectionMode" style="display:none;">
    <div style="color:var(--text-secondary);font-size:0.8rem;margin-bottom:8px;text-align:center;">Connection Mode</div>
    <button class="connection-mode-btn" onclick="setConnectionMode('none')" id="modeNone">Select</button>
    <button class="connection-mode-btn active" onclick="setConnectionMode('connect')" id="modeConnect">Connect</button>
  </div>
  
  <div class="toolbar" id="toolbar" style="display:none;">
    <div class="tool-label">Tools</div>
    <button class="tool-btn" onclick="addTile()" title="Add Tile">+</button>
    <button class="tool-btn" onclick="deleteSelected()" title="Delete Selected">DEL</button>
    <button class="tool-btn" onclick="centerCanvas()" title="Center Canvas">⌂</button>
    <button class="tool-btn" onclick="toggleAIPanel()" title="AI Suggestions">AI</button>
  </div>
  
  <div class="ai-panel" id="aiPanel">
    <div class="ai-title">AI Suggestions</div>
    <textarea class="ai-input" id="aiInput" placeholder="Describe what you want to add or connect..."></textarea>
    <button class="ai-btn" onclick="getAISuggestions()" id="aiBtn">
      <span id="aiBtnText">Get Suggestions</span>
    </button>
    <div class="ai-suggestions" id="aiSuggestions"></div>
  </div>
  
  <div id="notification" class="notification"></div>

  <!-- New Graph Modal -->
  <div class="modal-overlay" id="newGraphModal">
    <div class="modal">
      <div class="modal-title">Create New Graph</div>
      <input type="text" class="modal-input" id="newGraphTitle" placeholder="Enter graph title..." maxlength="100">
      <div class="modal-buttons">
        <button class="modal-btn secondary" onclick="closeNewGraphModal()">Cancel</button>
        <button class="modal-btn primary" onclick="confirmNewGraph()">Create</button>
      </div>
    </div>
  </div>

  <svg style="position:absolute;width:0;height:0;pointer-events:none">
        <defs>
      <marker id="arrowhead" markerWidth="12" markerHeight="8" refX="10" refY="4" orient="auto">
        <polygon points="0 0, 12 4, 0 8" fill="var(--accent-primary)"></polygon>
          </marker>
        </defs>
      </svg>

  <script>
    let currentUser = null, currentGraph = null, tiles = [], connections = [], selectedTile = null, isDragging = false, dragOffset = {x: 0, y: 0};
    let connectionMode = 'connect';
    let isConnecting = false;
    let connectionStart = null;
    let hoveredTile = null;
    let isPanning = false;
    let panStart = {x: 0, y: 0};
    let canvasOffset = {x: 0, y: 0};
    
    const canvas = document.getElementById('canvas');

    document.addEventListener('DOMContentLoaded', init);

    async function init() {
      await checkAuth();
      await loadGraphs();
      setupCanvas();
      setupTheme();
    }

    function setupTheme() {
      const savedTheme = localStorage.getItem('flowpad_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      updateThemeIcon(savedTheme);
      
      // Apply tile colors for the current theme if tiles exist
      if (tiles.length > 0) {
        updateTileColorsForTheme(savedTheme);
      }
    }

    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('flowpad_theme', newTheme);
      updateThemeIcon(newTheme);
      
      // Update tile colors for the new theme
      updateTileColorsForTheme(newTheme);
    }

    function updateThemeIcon(theme) {
      const icon = document.getElementById('theme-icon');
      icon.textContent = theme === 'dark' ? '🌙' : '☀️';
    }

    function updateTileColorsForTheme(theme) {
      // Update tile colors based on theme
      tiles.forEach(tile => {
        const currentColor = tile.style.background;
        if (currentColor) {
          const newColor = getThemeAdjustedColor(currentColor, theme);
          tile.style.background = newColor;
          
          // Update the selected color in the palette
          const colorOption = tile.querySelector(`[data-color="${currentColor}"]`);
          if (colorOption) {
            colorOption.classList.remove('selected');
          }
          
          const newColorOption = tile.querySelector(`[data-color="${newColor}"]`);
          if (newColorOption) {
            newColorOption.classList.add('selected');
          }
        }
      });
      
      // Re-render to update connections
      renderConnections();
    }

    function getThemeAdjustedColor(color, theme) {
      // Handle white and black colors - reverse them for theme
      if (color === '#ffffff' || color === 'white') {
        return theme === 'light' ? '#2d3748' : '#ffffff';
      }
      if (color === '#000000' || color === 'black' || color === '#212529') {
        return theme === 'light' ? '#ffffff' : '#2d3748';
      }
      
      // For other colors, keep them the same but adjust brightness slightly
      if (theme === 'light') {
        // Make colors slightly lighter in light mode
        return adjustColorBrightness(color, 1.1);
      } else {
        // Make colors slightly darker in dark mode
        return adjustColorBrightness(color, 0.9);
      }
    }

    function adjustColorBrightness(hex, factor) {
      // Convert hex to RGB, adjust brightness, convert back
      const r = Math.min(255, Math.round(parseInt(hex.slice(1, 3), 16) * factor));
      const g = Math.min(255, Math.round(parseInt(hex.slice(3, 5), 16) * factor));
      const b = Math.min(255, Math.round(parseInt(hex.slice(5, 7), 16) * factor));
      
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    async function checkAuth() {
      const token = localStorage.getItem('flowpad_token');
      const user = localStorage.getItem('flowpad_user');
      if (!token || !user) { window.location.href = '/'; return; }
      currentUser = JSON.parse(user);
      document.getElementById('userName').textContent = currentUser.name;
      const ok = await fetch('/api/graphs', { headers: { Authorization: `Bearer ${token}` } }).then(r => r.ok).catch(() => false);
      if (!ok) { localStorage.clear(); window.location.href = '/'; }
    }

    function signOut() { localStorage.clear(); window.location.href = '/'; }

    function el(html) { const d = document.createElement('div'); d.innerHTML = html.trim(); return d.firstChild; }

    async function loadGraphs() {
      const token = localStorage.getItem('flowpad_token');
      const res = await fetch('/api/graphs', { headers: { Authorization: `Bearer ${token}` } });
      if (!res.ok) return;
      const data = await res.json();
      renderGraphList(data.own, 'ownGraphs');
      renderGraphList(data.shared, 'sharedGraphs');
    }

    function renderGraphList(list, id) {
      const c = document.getElementById(id); c.innerHTML = '';
      list.forEach(g => {
        const item = el(`<div class="graph-item"><div class="graph-title">${g.title}</div><div class="graph-meta">Updated: ${new Date(g.updated_at).toLocaleString()}</div></div>`);
        item.addEventListener('click', () => loadGraph(g));
        c.appendChild(item);
      });
    }

    function createNewGraph() {
      const modal = document.getElementById('newGraphModal');
      const input = document.getElementById('newGraphTitle');
      input.value = '';
      modal.classList.add('show');
      input.focus();
      
      // Handle Enter key
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          confirmNewGraph();
        } else if (e.key === 'Escape') {
          closeNewGraphModal();
        }
      };
      
      // Handle click outside to close
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeNewGraphModal();
        }
      };
    }

    function closeNewGraphModal() {
      const modal = document.getElementById('newGraphModal');
      modal.classList.remove('show');
    }

    async function confirmNewGraph() {
      const title = document.getElementById('newGraphTitle').value.trim();
      if (!title) {
        document.getElementById('newGraphTitle').focus();
        return;
      }
      
      const createBtn = document.querySelector('#newGraphModal .modal-btn.primary');
      const originalText = createBtn.textContent;
      createBtn.textContent = 'Creating...';
      createBtn.disabled = true;
      
      try {
        const token = localStorage.getItem('flowpad_token');
        const res = await fetch('/api/graphs', { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title, data: { tiles: [], connections: [] } }) });
        if (!res.ok) {
          notify('Failed to create graph', 'error');
          return;
        }
        const graph = await res.json();
      await loadGraphs();
      loadGraph(graph);
        closeNewGraphModal();
        notify('Graph created successfully!', 'success');
      } catch (error) {
        notify('Failed to create graph: ' + error.message, 'error');
      } finally {
        createBtn.textContent = originalText;
        createBtn.disabled = false;
      }
    }

    function loadGraph(graph) {
      currentGraph = graph;
      tiles = (graph.data?.tiles || []).map(t => {
        const tile = createTile(t.x, t.y, t.title, t.content, t.id);
        if (t.color) {
          tile.style.background = t.color;
          // Update selected color in palette
          const colorOption = tile.querySelector(`[data-color="${t.color}"]`);
          if (colorOption) {
            colorOption.classList.add('selected');
          }
        }
        return tile;
      });
      connections = graph.data?.connections || [];
      document.getElementById('shareHeader').style.display = 'block';
      document.getElementById('shareEmail').style.display = 'block';
      document.getElementById('shareBtn').style.display = 'inline-block';
      document.getElementById('connectionMode').style.display = 'block';
      document.getElementById('toolbar').style.display = 'block';
      renderCanvas();
      
      // Apply theme colors to loaded tiles
      const currentTheme = document.documentElement.getAttribute('data-theme');
      updateTileColorsForTheme(currentTheme);
    }

    function setupCanvas() {
      canvas.addEventListener('mousedown', handleCanvasMouseDown);
      canvas.addEventListener('mousemove', handleCanvasMouseMove);
      canvas.addEventListener('mouseup', handleCanvasMouseUp);
      canvas.addEventListener('click', handleCanvasClick);
    }

    function handleCanvasMouseDown(e) {
      const tile = e.target.closest('.tile');
      const dot = e.target.closest('.connection-dot');
      
      if (dot) {
        startConnection(e, dot);
      } else if (tile && e.target.tagName !== 'TEXTAREA') {
        // Only start dragging if not clicking on textarea
        startDragging(e, tile);
      } else if (!tile) {
        // Start panning when clicking on empty canvas
        startPanning(e);
      }
    }

    function handleCanvasMouseMove(e) {
      if (isConnecting && connectionStart) {
        updateConnectionPreview(e);
      } else if (isDragging && selectedTile) {
        updateDragging(e);
      } else if (isPanning) {
        updatePanning(e);
      }
    }

    function handleCanvasMouseUp(e) {
      if (isConnecting) {
        finishConnection(e);
      }
      isDragging = false;
      isPanning = false;
      selectedTile = null;
    }

    function handleCanvasClick(e) {
      if (e.target === canvas) {
        clearSelection();
      }
    }

    function startConnection(e, dot) {
      isConnecting = true;
      connectionStart = {
        tile: dot.closest('.tile'),
        dot: dot,
        x: e.clientX,
        y: e.clientY
      };
      e.stopPropagation();
    }

    function updateConnectionPreview(e) {
      // Remove existing preview
      const existingPreview = document.querySelector('.connection-preview');
      if (existingPreview) existingPreview.remove();
      
      // Create preview line
      const rect = canvas.getBoundingClientRect();
      const startX = connectionStart.x - rect.left;
      const startY = connectionStart.y - rect.top;
      const endX = e.clientX - rect.left;
      const endY = e.clientY - rect.top;
      
      const preview = createConnectionLine(startX, startY, endX, endY, true);
      preview.classList.add('connection-preview');
      canvas.appendChild(preview);
    }

    function finishConnection(e) {
      const targetTile = e.target.closest('.tile');
      const targetDot = e.target.closest('.connection-dot');
      
      if (targetTile && targetDot && targetTile !== connectionStart.tile) {
        const connection = {
          id: 'conn_' + Date.now(),
          fromTile: connectionStart.tile.dataset.tileId,
          fromDot: connectionStart.dot.dataset.dotType,
          toTile: targetTile.dataset.tileId,
          toDot: targetDot.dataset.dotType,
          color: getRandomConnectionColor()
        };
        
        connections.push(connection);
        renderCanvas();
        scheduleSave();
      }
      
      // Clean up
      const preview = document.querySelector('.connection-preview');
      if (preview) preview.remove();
      
      isConnecting = false;
      connectionStart = null;
    }

    function getRandomConnectionColor() {
      const colors = [
        '#3b82f6', // Blue
        '#ef4444', // Red
        '#10b981', // Green
        '#f59e0b', // Amber
        '#8b5cf6', // Purple
        '#ec4899', // Pink
        '#06b6d4', // Cyan
        '#84cc16', // Lime
        '#f97316', // Orange
        '#6366f1'  // Indigo
      ];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function saveRecentColor(color) {
      let recentColors = JSON.parse(localStorage.getItem('flowpad_recent_colors') || '[]');
      // Remove if already exists
      recentColors = recentColors.filter(c => c !== color);
      // Add to beginning
      recentColors.unshift(color);
      // Keep only last 10
      recentColors = recentColors.slice(0, 10);
      localStorage.setItem('flowpad_recent_colors', JSON.stringify(recentColors));
    }

    function getRecentColors() {
      return JSON.parse(localStorage.getItem('flowpad_recent_colors') || '[]');
    }

    function showRecentColorsPopup(tile, optionElement) {
      const recentColors = getRecentColors();
      
      // Create popup
      const popup = document.createElement('div');
      popup.className = 'recent-colors-popup';
      popup.style.cssText = `
        position: absolute;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 10px 25px var(--shadow-primary);
        z-index: 1000;
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 5px;
        min-width: 200px;
      `;
      
      // Position popup near the recent colors button
      const rect = optionElement.getBoundingClientRect();
      popup.style.left = (rect.left - 100) + 'px';
      popup.style.top = (rect.bottom + 5) + 'px';
      
      // Add recent colors
      recentColors.forEach(color => {
        const colorOption = document.createElement('div');
        colorOption.style.cssText = `
          width: 25px;
          height: 25px;
          background: ${color};
          border-radius: 4px;
          cursor: pointer;
          border: 2px solid transparent;
        `;
        colorOption.title = color;
        
        colorOption.addEventListener('click', () => {
          tile.style.background = color;
          tile.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
          optionElement.classList.add('selected');
          saveRecentColor(color);
          scheduleSave();
          popup.remove();
        });
        
        popup.appendChild(colorOption);
      });
      
      // Add close button
      if (recentColors.length === 0) {
        const noColors = document.createElement('div');
        noColors.textContent = 'No recent colors';
        noColors.style.cssText = `
          grid-column: 1 / -1;
          text-align: center;
          color: var(--text-secondary);
          padding: 10px;
        `;
        popup.appendChild(noColors);
      }
      
      // Close popup when clicking outside
      document.addEventListener('click', function closePopup(e) {
        if (!popup.contains(e.target) && !optionElement.contains(e.target)) {
          popup.remove();
          document.removeEventListener('click', closePopup);
        }
      });
      
      document.body.appendChild(popup);
    }

    function startPanning(e) {
      isPanning = true;
      panStart.x = e.clientX - canvasOffset.x;
      panStart.y = e.clientY - canvasOffset.y;
    }

    function startDragging(e, tile) {
      isDragging = true;
      selectedTile = tile;
      selectTile(tile);
      
      // Calculate offset relative to tile's current position
      const baseX = parseInt(tile.dataset.baseX) || 0;
      const baseY = parseInt(tile.dataset.baseY) || 0;
      dragOffset.x = e.clientX - (baseX + canvasOffset.x);
      dragOffset.y = e.clientY - (baseY + canvasOffset.y);
    }

    function updatePanning(e) {
      const deltaX = e.clientX - panStart.x;
      const deltaY = e.clientY - panStart.y;
      
      // Update pan start for next frame
      panStart.x = e.clientX;
      panStart.y = e.clientY;
      
      // Apply pan offset to canvas view (not individual tiles)
      canvasOffset.x += deltaX;
      canvasOffset.y += deltaY;
      
      // Update tile positions immediately for responsive feel
      tiles.forEach(t => {
        const baseX = parseInt(t.dataset.baseX) || parseInt(t.style.left) || 0;
        const baseY = parseInt(t.dataset.baseY) || parseInt(t.style.top) || 0;
        t.style.left = (baseX + canvasOffset.x) + 'px';
        t.style.top = (baseY + canvasOffset.y) + 'px';
      });
      
      // Update connections with new canvas offset
      renderConnections();
    }

    function updateDragging(e) {
      // More responsive dragging with direct mouse coordinates
      const x = e.clientX - dragOffset.x - canvasOffset.x;
      const y = e.clientY - dragOffset.y - canvasOffset.y;
      
      // Update base coordinates and current position
      selectedTile.dataset.baseX = x;
      selectedTile.dataset.baseY = y;
      selectedTile.style.left = (x + canvasOffset.x) + 'px';
      selectedTile.style.top = (y + canvasOffset.y) + 'px';
      
      // Update connections immediately when tile moves
      renderConnections();
      scheduleSave();
    }

    function createTile(x = 100, y = 100, title = '', content = '', id = null) {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.tileId = id || 'tile_' + Date.now();
      tile.dataset.baseX = x;
      tile.dataset.baseY = y;
      tile.style.left = (x + canvasOffset.x) + 'px';
      tile.style.top = (y + canvasOffset.y) + 'px';
      
      tile.innerHTML = `
        <div class="color-palette">
          <div class="color-option" data-color="#ffffff" style="background:#ffffff" title="White"></div>
          <div class="color-option" data-color="#f8f9fa" style="background:#f8f9fa" title="Light Gray"></div>
          <div class="color-option" data-color="#e9ecef" style="background:#e9ecef" title="Gray"></div>
          <div class="color-option" data-color="#dee2e6" style="background:#dee2e6" title="Medium Gray"></div>
          <div class="color-option" data-color="#ced4da" style="background:#ced4da" title="Dark Gray"></div>
          <div class="color-option" data-color="#adb5bd" style="background:#adb5bd" title="Charcoal"></div>
          <div class="color-option" data-color="#6c757d" style="background:#6c757d" title="Slate"></div>
          <div class="color-option" data-color="#495057" style="background:#495057" title="Dark Slate"></div>
          <div class="color-option" data-color="#343a40" style="background:#343a40" title="Navy"></div>
          <div class="color-option" data-color="#212529" style="background:#212529" title="Black"></div>
          <div class="color-option" data-color="#ff6b6b" style="background:#ff6b6b" title="Coral"></div>
          <div class="color-option" data-color="#4ecdc4" style="background:#4ecdc4" title="Turquoise"></div>
          <div class="color-option" data-color="#45b7d1" style="background:#45b7d1" title="Sky Blue"></div>
          <div class="color-option" data-color="#96ceb4" style="background:#96ceb4" title="Mint"></div>
          <div class="color-option" data-color="#feca57" style="background:#feca57" title="Yellow"></div>
          <div class="color-option" data-color="#ff9ff3" style="background:#ff9ff3" title="Pink"></div>
          <div class="color-option" data-color="#54a0ff" style="background:#54a0ff" title="Blue"></div>
          <div class="color-option" data-color="#5f27cd" style="background:#5f27cd" title="Purple"></div>
          <div class="color-option" data-color="#00d2d3" style="background:#00d2d3" title="Teal"></div>
          <div class="color-option" data-color="#ff9f43" style="background:#ff9f43" title="Orange"></div>
          <div class="color-option recent-colors" data-color="custom" style="background:linear-gradient(45deg, #ff6b6b, #4ecdc4)" title="Recent Colors"></div>
        </div>
        <textarea class="tile-title" placeholder="Title">${title || ''}</textarea>
        <textarea class="tile-content" placeholder="Content">${content || ''}</textarea>
        <div class="connection-dot input" data-dot-type="input" title="Input connection"></div>
        <div class="connection-dot output" data-dot-type="output" title="Output connection"></div>
        <div class="connection-dot top" data-dot-type="top" title="Top connection"></div>
        <div class="connection-dot bottom" data-dot-type="bottom" title="Bottom connection"></div>
      `;
      
      tile.querySelectorAll('textarea').forEach(t => t.addEventListener('input', scheduleSave));
      
      // Add color selection functionality
      tile.querySelectorAll('.color-option').forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          
          if (option.dataset.color === 'custom') {
            // Show recent colors popup
            showRecentColorsPopup(tile, option);
          } else {
            const color = option.dataset.color;
            tile.style.background = color;
            
            // Update selected state
            tile.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            
            // Save to recent colors
            saveRecentColor(color);
            
            scheduleSave();
          }
        });
      });
      
      tile.addEventListener('click', (e) => {
        if (!isConnecting) {
          selectTile(tile);
        }
      });
      
      // Prevent tile movement when selecting text
      tile.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'TEXTAREA') {
          e.stopPropagation();
          return;
        }
        startDragging(e, tile);
      });
      
        return tile;
      }

    function selectTile(tile) {
      // Clear previous selection
      document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
      tile.classList.add('selected');
      selectedTile = tile;
    }

    function clearSelection() {
      document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
      selectedTile = null;
    }

    function addTile() {
      const rect = canvas.getBoundingClientRect();
      const x = Math.random() * (rect.width - 200) + 100;
      const y = Math.random() * (rect.height - 200) + 100;
      const tile = createTile(x, y, 'New Tile', 'Add content here...');
      tiles.push(tile);
      renderCanvas();
      scheduleSave();
    }

    function deleteSelected() {
      if (selectedTile) {
        const tileId = selectedTile.dataset.tileId;
        
        // Remove the tile from DOM
        selectedTile.remove();
        
        // Remove from tiles array
        tiles = tiles.filter(t => t !== selectedTile);
        
        // Remove all connections involving this tile
        connections = connections.filter(c => c.fromTile !== tileId && c.toTile !== tileId);
        
        // Clear selection
        selectedTile = null;
        
        // Re-render and save
        renderCanvas();
        scheduleSave();
        
        notify('Tile deleted successfully', 'success');
      } else {
        notify('No tile selected for deletion', 'error');
      }
    }

    function deleteConnection(connectionId) {
      const connectionIndex = connections.findIndex(c => c.id === connectionId);
      if (connectionIndex !== -1) {
        connections.splice(connectionIndex, 1);
        renderCanvas();
        scheduleSave();
        notify('Connection deleted successfully', 'success');
      }
    }

    function centerCanvas() {
      // Reset canvas panning to center
      canvasOffset.x = 0;
      canvasOffset.y = 0;
      
      // Update tile positions to their base coordinates
      tiles.forEach(t => {
        const baseX = parseInt(t.dataset.baseX) || 0;
        const baseY = parseInt(t.dataset.baseY) || 0;
        t.style.left = baseX + 'px';
        t.style.top = baseY + 'px';
      });
      
      // Re-render connections
      renderConnections();
      
      notify('Canvas centered', 'success');
    }

    function setConnectionMode(mode) {
      connectionMode = mode;
      document.querySelectorAll('.connection-mode-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
    }

    function toggleAIPanel() {
      const panel = document.getElementById('aiPanel');
      panel.classList.toggle('show');
    }

    async function getAISuggestions() {
      if (!currentGraph || !selectedTile) {
        notify('Please select a tile first', 'error');
        return;
      }

      const aiInput = document.getElementById('aiInput').value.trim();
      if (!aiInput) {
        notify('Please describe what you want to add', 'error');
        return;
      }

      const aiBtn = document.getElementById('aiBtn');
      const aiBtnText = document.getElementById('aiBtnText');
      aiBtn.disabled = true;
      aiBtnText.innerHTML = '<span class="loading"></span>Getting suggestions...';

      try {
        const token = localStorage.getItem('flowpad_token');
        const response = await fetch('/api/ai-suggestions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            targetTile: {
              id: selectedTile.dataset.tileId,
              content: selectedTile.querySelector('.tile-content').value
            },
            existingTiles: tiles.map(t => ({
              id: t.dataset.tileId,
              content: t.querySelector('.tile-content').value
            })),
            connections: connections
          })
        });

        if (!response.ok) {
          throw new Error('Failed to get AI suggestions');
        }

        const data = await response.json();
        displayAISuggestions(data);
      } catch (error) {
        notify('Failed to get AI suggestions: ' + error.message, 'error');
      } finally {
        aiBtn.disabled = false;
        aiBtnText.textContent = 'Get Suggestions';
      }
    }

    function displayAISuggestions(suggestions) {
      const container = document.getElementById('aiSuggestions');
      container.innerHTML = '';
      
      console.log('AI Response:', suggestions); // Debug log
      
      // Handle different response formats
      let suggestionsArray = [];
      
      if (suggestions.suggestions && Array.isArray(suggestions.suggestions)) {
        suggestionsArray = suggestions.suggestions;
      } else if (suggestions.data && Array.isArray(suggestions.data)) {
        suggestionsArray = suggestions.data;
      } else if (Array.isArray(suggestions)) {
        suggestionsArray = suggestions;
      } else if (typeof suggestions === 'string') {
        suggestionsArray = [suggestions];
      } else if (suggestions.text) {
        suggestionsArray = [suggestions.text];
      } else if (suggestions.content) {
        suggestionsArray = [suggestions.content];
      } else {
        // Fallback: try to extract any text content
        const suggestionText = JSON.stringify(suggestions, null, 2);
        suggestionsArray = [suggestionText];
      }
      
      if (suggestionsArray.length > 0) {
        suggestionsArray.forEach(suggestion => {
          const div = document.createElement('div');
          div.className = 'ai-suggestion';
          div.textContent = typeof suggestion === 'string' ? suggestion : JSON.stringify(suggestion);
          div.addEventListener('click', () => applyAISuggestion(suggestion));
          container.appendChild(div);
        });
      } else {
        container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">No suggestions available</div>';
      }
    }

    function applyAISuggestion(suggestion) {
      if (selectedTile) {
        let content = '';
        
        if (typeof suggestion === 'string') {
          content = suggestion;
        } else if (suggestion.text) {
          content = suggestion.text;
        } else if (suggestion.content) {
          content = suggestion.content;
        } else if (suggestion.description) {
          content = suggestion.description;
        } else {
          content = JSON.stringify(suggestion, null, 2);
        }
        
        selectedTile.querySelector('.tile-content').value = content;
        scheduleSave();
        notify('Suggestion applied!', 'success');
      }
    }

    function createConnectionLine(fromX, fromY, toX, toY, isPreview = false, color = null, connectionId = null) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.style.position = 'absolute';
      svg.style.left = '0';
      svg.style.top = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';
      svg.style.zIndex = isPreview ? '15' : '5';
      
      if (!isPreview) {
        svg.style.pointerEvents = 'auto';
        svg.style.cursor = 'pointer';
        svg.dataset.connectionId = connectionId;
        
        // Add click handler for deletion
        svg.addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm('Delete this connection?')) {
            deleteConnection(connectionId);
          }
        });
        
        // Add hover effect
        svg.addEventListener('mouseenter', () => {
          path.style.strokeWidth = '4';
          path.style.filter = 'drop-shadow(0 0 3px currentColor)';
          svg.style.cursor = 'pointer';
        });
        
        svg.addEventListener('mouseleave', () => {
          path.style.strokeWidth = '3';
          path.style.filter = 'none';
          svg.style.cursor = 'pointer';
        });
      }
      
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      
      // Always use curved lines for better visual appeal
      let pathData = createSmartPath(fromX, fromY, toX, toY);
      
      path.setAttribute('d', pathData);
      path.setAttribute('stroke', isPreview ? '#888' : (color || 'var(--accent-primary)'));
      path.setAttribute('stroke-width', isPreview ? '2' : '3');
      path.setAttribute('fill', 'none');
      path.setAttribute('marker-end', isPreview ? 'none' : 'url(#arrowhead)');
      path.classList.add('connection-line');
      
      svg.appendChild(path);
      return svg;
    }

    function createSmartPath(fromX, fromY, toX, toY) {
      // Find obstacles (tiles) between the connection points
      const obstacles = findObstacles(fromX, fromY, toX, toY);
      
      if (obstacles.length === 0) {
        // No obstacles, use smooth S-curve with better control points
        const midX = (fromX + toX) / 2;
        const midY = (fromY + toY) / 2;
        const distance = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
        const curveIntensity = Math.max(distance * 0.3, 40); // Minimum curve intensity
        
        // Create smooth cubic bezier curve with more pronounced curves
        const control1 = { 
          x: fromX + (midX - fromX) * 0.5, 
          y: fromY + (fromY < toY ? curveIntensity : -curveIntensity) 
        };
        const control2 = { 
          x: toX - (toX - midX) * 0.5, 
          y: toY + (toY < fromY ? curveIntensity : -curveIntensity) 
        };
        
        return `M ${fromX} ${fromY} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${toX} ${toY}`;
      }
      
      // Create path with max 3 bends using straight edges first
      const pathMap = createPathMap(fromX, fromY, toX, toY, obstacles);
      return convertPathMapToCurves(pathMap);
    }

    function findObstacles(fromX, fromY, toX, toY) {
      const obstacles = [];
      const canvasRect = canvas.getBoundingClientRect();
      
      tiles.forEach(tile => {
        const tileRect = tile.getBoundingClientRect();
        const tileX = tileRect.left - canvasRect.left;
        const tileY = tileRect.top - canvasRect.top;
        const tileWidth = tileRect.width;
        const tileHeight = tileRect.height;
        
        // Check if line intersects with tile
        if (lineIntersectsRect(fromX, fromY, toX, toY, tileX, tileY, tileWidth, tileHeight)) {
          obstacles.push({
            x: tileX,
            y: tileY,
            width: tileWidth,
            height: tileHeight
          });
        }
      });
      
      return obstacles;
    }

    function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
      // Simple line-rectangle intersection test
      const left = rx;
      const right = rx + rw;
      const top = ry;
      const bottom = ry + rh;
      
      // Check if line endpoints are inside rectangle
      if ((x1 >= left && x1 <= right && y1 >= top && y1 <= bottom) ||
          (x2 >= left && x2 <= right && y2 >= top && y2 <= bottom)) {
        return true;
      }
      
      // Check line segments against rectangle edges
      const lines = [
        [left, top, right, top],     // top edge
        [right, top, right, bottom], // right edge
        [right, bottom, left, bottom], // bottom edge
        [left, bottom, left, top]    // left edge
      ];
      
      for (const line of lines) {
        if (linesIntersect(x1, y1, x2, y2, line[0], line[1], line[2], line[3])) {
          return true;
        }
      }
      
      return false;
    }

    function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (den === 0) return false;
      
      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
      const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
      
      return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }

    function calculateWaypoints(fromX, fromY, toX, toY, obstacles) {
      const waypoints = [];
      
      // Sort obstacles by distance from start point
      obstacles.sort((a, b) => {
        const distA = Math.sqrt((a.x - fromX) ** 2 + (a.y - fromY) ** 2);
        const distB = Math.sqrt((b.x - fromX) ** 2 + (b.y - fromY) ** 2);
        return distA - distB;
      });
      
      let currentX = fromX;
      let currentY = fromY;
      
      for (const obstacle of obstacles) {
        // Find best waypoint around this obstacle
        const waypoint = findBestWaypoint(currentX, currentY, toX, toY, obstacle);
        if (waypoint) {
          waypoints.push(waypoint);
          currentX = waypoint.x;
          currentY = waypoint.y;
        }
      }
      
      return waypoints;
    }

    function findBestWaypoint(fromX, fromY, toX, toY, obstacle) {
      // Try different positions around the obstacle
      const positions = [
        { x: obstacle.x - 20, y: obstacle.y - 20 }, // top-left
        { x: obstacle.x + obstacle.width + 20, y: obstacle.y - 20 }, // top-right
        { x: obstacle.x + obstacle.width + 20, y: obstacle.y + obstacle.height + 20 }, // bottom-right
        { x: obstacle.x - 20, y: obstacle.y + obstacle.height + 20 }, // bottom-left
        { x: obstacle.x - 20, y: (obstacle.y + obstacle.y + obstacle.height) / 2 }, // left-middle
        { x: obstacle.x + obstacle.width + 20, y: (obstacle.y + obstacle.y + obstacle.height) / 2 }, // right-middle
      ];
      
      // Find position with shortest total path length
      let bestWaypoint = null;
      let bestDistance = Infinity;
      
      for (const pos of positions) {
        const distance1 = Math.sqrt((pos.x - fromX) ** 2 + (pos.y - fromY) ** 2);
        const distance2 = Math.sqrt((pos.x - toX) ** 2 + (pos.y - toY) ** 2);
        const totalDistance = distance1 + distance2;
        
        if (totalDistance < bestDistance) {
          bestDistance = totalDistance;
          bestWaypoint = pos;
        }
      }
      
      return bestWaypoint;
    }

    function createPathFromWaypoints(fromX, fromY, toX, toY, waypoints) {
      if (waypoints.length === 0) {
        // No waypoints, use smooth S-curve
        const midX = (fromX + toX) / 2;
        const midY = (fromY + toY) / 2;
        const distance = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
        const curveIntensity = Math.max(distance * 0.3, 40);
        
        const control1 = { 
          x: fromX + (midX - fromX) * 0.5, 
          y: fromY + (fromY < toY ? curveIntensity : -curveIntensity) 
        };
        const control2 = { 
          x: toX - (toX - midX) * 0.5, 
          y: toY + (toY < fromY ? curveIntensity : -curveIntensity) 
        };
        
        return `M ${fromX} ${fromY} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${toX} ${toY}`;
      }
      
      // Create smooth path through waypoints using cubic bezier curves
      let path = `M ${fromX} ${fromY}`;
      
      for (let i = 0; i < waypoints.length; i++) {
        const wp = waypoints[i];
        if (i === 0) {
          // First waypoint: smooth curve from start
          const midX = (fromX + wp.x) / 2;
          const midY = (fromY + wp.y) / 2;
          const offset = Math.min(Math.abs(wp.x - fromX) * 0.3, 50);
          path += ` C ${fromX + offset} ${fromY}, ${midX} ${midY}, ${wp.x} ${wp.y}`;
        } else {
          // Subsequent waypoints: smooth curves between them
          const prevWp = waypoints[i - 1];
          const midX = (prevWp.x + wp.x) / 2;
          const midY = (prevWp.y + wp.y) / 2;
          const offset = Math.min(Math.abs(wp.x - prevWp.x) * 0.3, 50);
          path += ` C ${prevWp.x + offset} ${prevWp.y}, ${midX} ${midY}, ${wp.x} ${wp.y}`;
        }
      }
      
      // Connect to final destination with smooth curve
      if (waypoints.length > 0) {
        const lastWp = waypoints[waypoints.length - 1];
        const midX = (lastWp.x + toX) / 2;
        const midY = (lastWp.y + toY) / 2;
        const offset = Math.min(Math.abs(toX - lastWp.x) * 0.3, 50);
        path += ` C ${lastWp.x + offset} ${lastWp.y}, ${midX} ${midY}, ${toX} ${toY}`;
      }
      
      return path;
    }

    function createPathMap(fromX, fromY, toX, toY, obstacles) {
      // Create a path map with straight edges and max 3 bends
      const pathMap = {
        points: [{ x: fromX, y: fromY }],
        edges: []
      };
      
      if (obstacles.length === 0) {
        // Direct path
        pathMap.points.push({ x: toX, y: toY });
        pathMap.edges.push({ from: 0, to: 1 });
        return pathMap;
      }
      
      // Sort obstacles by distance from start
      obstacles.sort((a, b) => {
        const distA = Math.sqrt((a.x - fromX) ** 2 + (a.y - fromY) ** 2);
        const distB = Math.sqrt((b.x - fromX) ** 2 + (b.y - fromY) ** 2);
        return distA - distB;
      });
      
      let currentX = fromX;
      let currentY = fromY;
      let bendCount = 0;
      const maxBends = 3;
      
      for (const obstacle of obstacles) {
        if (bendCount >= maxBends) break;
        
        // Find best waypoint around this obstacle
        const waypoint = findOptimalWaypoint(currentX, currentY, toX, toY, obstacle);
        if (waypoint) {
          pathMap.points.push(waypoint);
          pathMap.edges.push({ 
            from: pathMap.points.length - 2, 
            to: pathMap.points.length - 1 
          });
          
          currentX = waypoint.x;
          currentY = waypoint.y;
          bendCount++;
        }
      }
      
      // Add final destination
      pathMap.points.push({ x: toX, y: toY });
      pathMap.edges.push({ 
        from: pathMap.points.length - 2, 
        to: pathMap.points.length - 1 
      });
      
      return pathMap;
    }

    function findOptimalWaypoint(fromX, fromY, toX, toY, obstacle) {
      // Create a grid of potential waypoints around the obstacle
      const gridSize = 40;
      const waypoints = [];
      
      // Generate waypoints in a grid pattern around the obstacle
      for (let x = obstacle.x - gridSize; x <= obstacle.x + obstacle.width + gridSize; x += gridSize) {
        for (let y = obstacle.y - gridSize; y <= obstacle.y + obstacle.height + gridSize; y += gridSize) {
          // Skip waypoints inside the obstacle
          if (x >= obstacle.x && x <= obstacle.x + obstacle.width && 
              y >= obstacle.y && y <= obstacle.y + obstacle.height) {
            continue;
          }
          
          waypoints.push({ x, y });
        }
      }
      
      // Find the waypoint that minimizes total path length and avoids obstacles
      let bestWaypoint = null;
      let bestScore = Infinity;
      
      for (const wp of waypoints) {
        const score = calculatePathScore(fromX, fromY, wp.x, wp.y, toX, toY, obstacle);
        if (score < bestScore) {
          bestScore = score;
          bestWaypoint = wp;
        }
      }
      
      return bestWaypoint;
    }

    function calculatePathScore(fromX, fromY, waypointX, waypointY, toX, toY, obstacle) {
      // Calculate total path length
      const dist1 = Math.sqrt((waypointX - fromX) ** 2 + (waypointY - fromY) ** 2);
      const dist2 = Math.sqrt((toX - waypointX) ** 2 + (toY - waypointY) ** 2);
      const totalDistance = dist1 + dist2;
      
      // Penalty for being too close to obstacles
      const obstacleDistance = Math.min(
        Math.abs(waypointX - obstacle.x),
        Math.abs(waypointX - (obstacle.x + obstacle.width)),
        Math.abs(waypointY - obstacle.y),
        Math.abs(waypointY - (obstacle.y + obstacle.height))
      );
      
      const obstaclePenalty = Math.max(0, 20 - obstacleDistance) * 10;
      
      return totalDistance + obstaclePenalty;
    }

    function convertPathMapToCurves(pathMap) {
      if (pathMap.points.length < 2) {
        return `M ${pathMap.points[0].x} ${pathMap.points[0].y}`;
      }
      
      let path = `M ${pathMap.points[0].x} ${pathMap.points[0].y}`;
      
      for (let i = 1; i < pathMap.points.length; i++) {
        const current = pathMap.points[i];
        const previous = pathMap.points[i - 1];
        
        if (i === 1 || i === pathMap.points.length - 1) {
          // First and last segments: straight lines
          path += ` L ${current.x} ${current.y}`;
        } else {
          // Middle segments: convert bends to curves
          const next = pathMap.points[i + 1];
          const curve = convertBendToCurve(previous, current, next);
          path += ` ${curve}`;
        }
      }
      
      return path;
    }

    function convertBendToCurve(prev, current, next) {
      // Calculate the angle between the two line segments
      const angle1 = Math.atan2(current.y - prev.y, current.x - prev.x);
      const angle2 = Math.atan2(next.y - current.y, next.x - current.x);
      const angleDiff = Math.abs(angle1 - angle2);
      
      // If the angle is too sharp, create a curve
      if (angleDiff > Math.PI / 6) { // 30 degrees
        const radius = 20;
        const control1 = {
          x: current.x - Math.cos(angle1) * radius,
          y: current.y - Math.sin(angle1) * radius
        };
        const control2 = {
          x: current.x + Math.cos(angle2) * radius,
          y: current.y + Math.sin(angle2) * radius
        };
        
        return `C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${next.x} ${next.y}`;
      } else {
        // Small angle, keep it straight
        return `L ${next.x} ${next.y}`;
      }
    }

    function renderCanvas() {
      // Clear canvas
      canvas.innerHTML = '';
      
      // Add tiles with proper positioning
      tiles.forEach(t => {
        // Position tiles relative to viewport, not transformed canvas
        const x = parseInt(t.style.left) || 0;
        const y = parseInt(t.style.top) || 0;
        t.style.left = (x + canvasOffset.x) + 'px';
        t.style.top = (y + canvasOffset.y) + 'px';
        t.style.position = 'absolute';
        t.style.zIndex = '10';
        canvas.appendChild(t);
      });
      
      // Add connections
      renderConnections();
    }

    function renderConnections() {
      // Remove existing connections
      document.querySelectorAll('.connection-svg').forEach(svg => svg.remove());
      
      connections.forEach(conn => {
        const fromTile = tiles.find(t => t.dataset.tileId === conn.fromTile);
        const toTile = tiles.find(t => t.dataset.tileId === conn.toTile);
        
        if (fromTile && toTile) {
          const fromRect = fromTile.getBoundingClientRect();
          const toRect = toTile.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          
          let fromX, fromY, toX, toY;
          
          // Calculate connection points based on dot types
          if (conn.fromDot === 'output') {
            fromX = fromRect.right - canvasRect.left;
            fromY = fromRect.top + fromRect.height / 2 - canvasRect.top;
          } else if (conn.fromDot === 'input') {
            fromX = fromRect.left - canvasRect.left;
            fromY = fromRect.top + fromRect.height / 2 - canvasRect.top;
          } else if (conn.fromDot === 'top') {
            fromX = fromRect.left + fromRect.width / 2 - canvasRect.left;
            fromY = fromRect.top - canvasRect.top;
          } else if (conn.fromDot === 'bottom') {
            fromX = fromRect.left + fromRect.width / 2 - canvasRect.left;
            fromY = fromRect.bottom - canvasRect.top;
          }
          
          if (conn.toDot === 'input') {
            toX = toRect.left - canvasRect.left;
            toY = toRect.top + toRect.height / 2 - canvasRect.top;
          } else if (conn.toDot === 'output') {
            toX = toRect.right - canvasRect.left;
            toY = toRect.top + toRect.height / 2 - canvasRect.top;
          } else if (conn.toDot === 'top') {
            toX = toRect.left + toRect.width / 2 - canvasRect.left;
            toY = toRect.top - canvasRect.top;
          } else if (conn.toDot === 'bottom') {
            toX = toRect.left + toRect.width / 2 - canvasRect.left;
            toY = toRect.bottom - canvasRect.top;
          }
          
          if (fromX !== undefined && toX !== undefined) {
            const connectionLine = createConnectionLine(fromX, fromY, toX, toY, false, conn.color, conn.id);
            connectionLine.classList.add('connection-svg');
            canvas.appendChild(connectionLine);
          }
        }
      });
    }

    async function shareGraph() {
      if (!currentGraph) return;
      const email = document.getElementById('shareEmail').value.trim();
      if (!email) return notify('Please enter an email', 'error');
      const token = localStorage.getItem('flowpad_token');
      const res = await fetch(`/api/graphs/${currentGraph.id}/share`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ email }) });
      notify(res.ok ? 'Graph shared successfully' : 'Failed to share graph', res.ok ? 'success' : 'error');
      if (res.ok) document.getElementById('shareEmail').value = '';
    }

    let saveTimer;
    function scheduleSave() { clearTimeout(saveTimer); saveTimer = setTimeout(saveGraph, 500); }

    async function saveGraph() {
      if (!currentGraph) return;
      const token = localStorage.getItem('flowpad_token');
      const data = {
        tiles: [...canvas.querySelectorAll('.tile')].map(t => ({
          id: t.dataset.tileId,
          x: parseInt(t.style.left) || 0,
          y: parseInt(t.style.top) || 0,
          title: t.querySelector('.tile-title').value || '',
          content: t.querySelector('.tile-content').value || '',
          color: t.style.background || '#ffffff'
        })),
        connections
      };
      await fetch(`/api/graphs/${currentGraph.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }, body: JSON.stringify({ title: currentGraph.title, data }) });
    }

    function notify(msg, type = 'success', ms = 2500) {
      const n = document.getElementById('notification');
      n.textContent = msg; n.className = `notification ${type}`; n.classList.add('show');
      setTimeout(() => n.classList.remove('show'), ms);
    }
  </script>
</body>
</html>
