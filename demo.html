<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flowpad - Feature Demo</title>
  <style>
    :root {
      --bg-primary: #1a1a1a;
      --bg-secondary: #2d2d2d;
      --bg-tertiary: rgba(0,0,0,0.9);
      --bg-tile: #fff;
      --bg-tile-hover: #f8f9fa;
      --text-primary: #fff;
      --text-secondary: #ccc;
      --text-tile: #000;
      --border-primary: #333;
      --border-secondary: #555;
      --accent-primary: #4CAF50;
      --accent-secondary: #45a049;
      --shadow-primary: rgba(0,0,0,0.3);
      --shadow-secondary: rgba(0,0,0,0.2);
      --grid-color: rgba(255,255,255,0.03);
    }

    :root[data-theme="light"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9fa;
      --bg-tertiary: rgba(255,255,255,0.95);
      --bg-tile: #2d3748;
      --bg-tile-hover: #4a5568;
      --text-primary: #2d3748;
      --text-secondary: #4a5568;
      --text-tile: #fff;
      --border-primary: #e2e8f0;
      --border-secondary: #cbd5e0;
      --shadow-primary: rgba(0,0,0,0.1);
      --shadow-secondary: rgba(0,0,0,0.05);
      --grid-color: rgba(0,0,0,0.03);
    }

    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;background:var(--bg-primary);background-image:linear-gradient(var(--grid-color) 1px,transparent 1px),linear-gradient(90deg,var(--grid-color) 1px,transparent 1px);background-size:20px 20px;color:var(--text-primary);overflow:hidden;transition:all 0.3s ease}
    
    .header{position:fixed;inset:0 0 auto 0;height:60px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border-bottom:1px solid var(--border-primary);display:flex;align-items:center;justify-content:space-between;padding:0 20px;z-index:1000;transition:all 0.3s ease}
    .logo{font-size:1.5rem;font-weight:700;background:linear-gradient(45deg,var(--text-primary),var(--text-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .theme-toggle{background:var(--border-primary);color:var(--text-primary);border:none;padding:8px 12px;border-radius:6px;cursor:pointer;transition:all 0.3s ease}
    .theme-toggle:hover{background:var(--border-secondary)}
    
    .demo-container{position:fixed;top:60px;left:0;right:0;bottom:0;overflow:hidden}
    .demo-content{width:100%;height:100%;background-image:linear-gradient(var(--grid-color) 1px,transparent 1px),linear-gradient(90deg,var(--grid-color) 1px,transparent 1px);background-size:20px 20px;position:relative;transition:all 0.3s ease;padding:40px;cursor:grab}
    .demo-content.panning{cursor:grabbing}
    
    .tile{position:absolute;background:var(--bg-tile);color:var(--text-tile);border:2px solid var(--border-primary);border-radius:12px;padding:20px;min-width:150px;min-height:100px;cursor:move;user-select:none;box-shadow:0 8px 25px var(--shadow-primary);transition:all 0.3s ease;resize:both;overflow:hidden}
    .tile:hover{background:var(--bg-tile-hover);box-shadow:0 12px 35px var(--shadow-secondary)}
    .tile.selected{border-color:var(--accent-primary);box-shadow:0 0 0 3px rgba(76, 175, 80, 0.3)}
    .tile-title,.tile-content{border:none;background:transparent;width:100%;outline:none;font-family:inherit;resize:none;pointer-events:none}
    .tile-title{font-weight:600;margin-bottom:12px;font-size:1rem;color:var(--text-tile)}
    .tile-content{font-size:0.9rem;line-height:1.5;min-height:50px;color:var(--text-tile)}
    
    .color-palette{position:absolute;top:10px;right:10px;display:flex;gap:5px;opacity:0;transition:opacity 0.3s ease}
    .tile:hover .color-palette{opacity:1}
    .color-option{width:20px;height:20px;border-radius:50%;border:2px solid var(--border-primary);cursor:pointer;transition:all 0.3s ease}
    .color-option:hover{transform:scale(1.2);border-color:var(--accent-primary)}
    .color-option.selected{border-color:var(--accent-primary);box-shadow:0 0 0 2px var(--accent-primary)}
    
    .connection-dot{position:absolute;width:12px;height:12px;background:var(--accent-primary);border:2px solid #fff;border-radius:50%;cursor:crosshair;z-index:10;transition:all 0.3s ease}
    .connection-dot:hover{transform:scale(1.2);background:var(--accent-secondary)}
    .connection-dot.input{left:-6px;top:50%;transform:translateY(-50%)}
    .connection-dot.output{right:-6px;top:50%;transform:translateY(-50%)}
    .connection-dot.top{top:-6px;left:50%;transform:translateX(-50%)}
    .connection-dot.bottom{bottom:-6px;left:50%;transform:translateX(-50%)}
    
    .connection-line{stroke:var(--accent-primary);stroke-width:3;fill:none;marker-end:url(#arrowhead);filter:drop-shadow(0 2px 4px var(--shadow-primary))}
    
    .features-panel{position:fixed;top:80px;right:20px;background:var(--bg-tertiary);backdrop-filter:blur(20px);border:1px solid var(--border-primary);border-radius:12px;padding:20px;z-index:1000;width:300px}
    .feature-title{font-size:1.1rem;font-weight:600;margin-bottom:15px;color:var(--text-primary)}
    .feature-item{margin-bottom:15px;padding:10px;background:var(--bg-secondary);border-radius:8px;border:1px solid var(--border-primary)}
    .feature-name{font-weight:600;margin-bottom:5px;color:var(--text-primary)}
    .feature-desc{font-size:0.9rem;color:var(--text-secondary);line-height:1.4}
    
    .loading{display:inline-block;width:16px;height:16px;border:2px solid transparent;border-top:2px solid currentColor;border-radius:50%;animation:spin 1s linear infinite;margin-right:8px}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
    
    .modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);backdrop-filter:blur(5px);z-index:10000;display:none;align-items:center;justify-content:center}
    .modal-overlay.show{display:flex}
    .modal{background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:12px;padding:30px;min-width:400px;max-width:600px;box-shadow:0 20px 40px var(--shadow-primary)}
    .modal-title{font-size:1.3rem;font-weight:600;margin-bottom:20px;color:var(--text-primary)}
    .modal-input{width:100%;padding:15px;border:1px solid var(--border-secondary);border-radius:8px;background:var(--bg-secondary);color:var(--text-primary);font-size:1rem;margin-bottom:20px;outline:none;transition:border-color 0.3s ease}
    .modal-input:focus{border-color:var(--accent-primary)}
    .modal-buttons{display:flex;gap:10px;justify-content:flex-end}
    .modal-btn{padding:12px 24px;border:none;border-radius:8px;cursor:pointer;font-size:1rem;transition:all 0.3s ease}
    .modal-btn.primary{background:var(--accent-primary);color:#fff}
    .modal-btn.primary:hover{background:var(--accent-secondary)}
    .modal-btn.secondary{background:var(--border-primary);color:var(--text-primary)}
    .modal-btn.secondary:hover{background:var(--border-secondary)}
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">Flowpad Demo</div>
    <div style="display: flex; gap: 10px; align-items: center;">
      <button class="theme-toggle" onclick="showNewGraphModal()" title="Test Modal">Test Modal</button>
      <button class="theme-toggle" onclick="centerCanvas()" title="Center Canvas">⌂</button>
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <span id="theme-icon">🌙</span>
      </button>
    </div>
  </div>

  <div class="demo-container">
    <div class="demo-content" id="demoContent">
      <!-- Demo tiles will be added here -->
    </div>
  </div>
  
  <div class="features-panel">
    <div class="feature-title">Features Demo</div>
    
    <div class="feature-item">
      <div class="feature-name">Dark/Light Mode</div>
      <div class="feature-desc">Click the theme toggle button to switch between dark and light themes. The theme preference is automatically saved.</div>
    </div>
    
    <div class="feature-item">
      <div class="feature-name">Enhanced Tiles</div>
      <div class="feature-desc">Beautiful tiles with connection dots on all sides. Hover over tiles to see smooth animations and effects.</div>
    </div>
    
    <div class="feature-item">
      <div class="feature-name">Smart Connections</div>
      <div class="feature-desc">SVG-based connections that automatically switch between straight lines (when aligned) and S-curves (when out of sync).</div>
    </div>
    
    <div class="feature-item">
      <div class="feature-name">Responsive Design</div>
      <div class="feature-desc">All components automatically adapt to the selected theme with smooth transitions and consistent styling.</div>
    </div>
    
    <div class="feature-item">
      <div class="feature-name">Modern UI</div>
      <div class="feature-desc">Glassmorphism effects, backdrop filters, and modern CSS features for a premium user experience.</div>
    </div>
  </div>

  <!-- New Graph Modal -->
  <div class="modal-overlay" id="newGraphModal">
    <div class="modal">
      <div class="modal-title">Create New Graph</div>
      <input type="text" class="modal-input" id="newGraphTitle" placeholder="Enter graph title..." maxlength="100">
      <div class="modal-buttons">
        <button class="modal-btn secondary" onclick="closeNewGraphModal()">Cancel</button>
        <button class="modal-btn primary" onclick="confirmNewGraph()">Create</button>
      </div>
    </div>
  </div>

  <svg style="position:absolute;width:0;height:0;pointer-events:none">
    <defs>
      <marker id="arrowhead" markerWidth="12" markerHeight="8" refX="10" refY="4" orient="auto">
        <polygon points="0 0, 12 4, 0 8" fill="var(--accent-primary)"></polygon>
      </marker>
    </defs>
  </svg>

  <script>
    let tiles = [];
    let connections = [];
    let selectedTile = null;
    let isDragging = false;
    let dragOffset = {x: 0, y: 0};
    let isPanning = false;
    let panStart = {x: 0, y: 0};
    let canvasOffset = {x: 0, y: 0};
    
    const demoContent = document.getElementById('demoContent');

    document.addEventListener('DOMContentLoaded', init);

    function init() {
      setupTheme();
      createDemoTiles();
      createDemoConnections();
      setupCanvas();
    }

    function setupTheme() {
      const savedTheme = localStorage.getItem('flowpad_theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      updateThemeIcon(savedTheme);
    }

    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('flowpad_theme', newTheme);
      updateThemeIcon(newTheme);
    }

    function updateThemeIcon(theme) {
      const icon = document.getElementById('theme-icon');
      icon.textContent = theme === 'dark' ? '🌙' : '☀️';
    }

    function showNewGraphModal() {
      const modal = document.getElementById('newGraphModal');
      const input = document.getElementById('newGraphTitle');
      input.value = '';
      modal.classList.add('show');
      input.focus();
      
      // Handle Enter key
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          confirmNewGraph();
        } else if (e.key === 'Escape') {
          closeNewGraphModal();
        }
      };
      
      // Handle click outside to close
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeNewGraphModal();
        }
      };
    }

    function closeNewGraphModal() {
      const modal = document.getElementById('newGraphModal');
      modal.classList.remove('show');
    }

    function confirmNewGraph() {
      const title = document.getElementById('newGraphTitle').value.trim();
      if (!title) {
        document.getElementById('newGraphTitle').focus();
        return;
      }
      
      // For demo purposes, just close the modal and show a message
      closeNewGraphModal();
      alert('Demo: Graph "' + title + '" would be created!');
    }

    function centerCanvas() {
      // Reset canvas panning to center
      canvasOffset.x = 0;
      canvasOffset.y = 0;
      canvas.style.transform = 'translate(0px, 0px)';
      
      // Re-render connections
      renderConnections();
      
      alert('Demo: Canvas centered!');
    }

    function createDemoTiles() {
      const tileData = [
        { x: 100, y: 100, title: 'Start Project', content: 'Define project scope and objectives' },
        { x: 400, y: 100, title: 'Planning', content: 'Create project timeline and milestones' },
        { x: 700, y: 100, title: 'Development', content: 'Build and implement features' },
        { x: 100, y: 300, title: 'Testing', content: 'Quality assurance and bug fixes' },
        { x: 400, y: 300, title: 'Deployment', content: 'Release to production environment' },
        { x: 700, y: 300, title: 'Maintenance', content: 'Ongoing support and updates' }
      ];

      tileData.forEach(data => {
        const tile = createTile(data.x, data.y, data.title, data.content);
        tiles.push(tile);
        demoContent.appendChild(tile);
      });
    }

    function createDemoConnections() {
      const connectionData = [
        { from: 0, fromDot: 'output', to: 1, toDot: 'input' },
        { from: 1, fromDot: 'output', to: 2, toDot: 'input' },
        { from: 0, fromDot: 'bottom', to: 3, toDot: 'top' },
        { from: 3, fromDot: 'output', to: 4, toDot: 'input' },
        { from: 4, fromDot: 'output', to: 5, toDot: 'input' },
        { from: 2, fromDot: 'bottom', to: 4, toDot: 'top' }
      ];

      connectionData.forEach(conn => {
        connections.push({
          fromTile: tiles[conn.from].dataset.tileId,
          fromDot: conn.fromDot,
          toTile: tiles[conn.to].dataset.tileId,
          toDot: conn.toDot
        });
      });

      renderConnections();
    }

    function createTile(x, y, title, content) {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.tileId = 'tile_' + Date.now() + Math.random().toString(36).substr(2, 9);
      tile.style.left = x + 'px';
      tile.style.top = y + 'px';
      
      tile.innerHTML = `
        <div class="color-palette">
          <div class="color-option" data-color="#ffffff" style="background:#ffffff" title="White"></div>
          <div class="color-option" data-color="#f8f9fa" style="background:#f8f9fa" title="Light Gray"></div>
          <div class="color-option" data-color="#e9ecef" style="background:#e9ecef" title="Gray"></div>
          <div class="color-option" data-color="#dee2e6" style="background:#dee2e6" title="Medium Gray"></div>
          <div class="color-option" data-color="#ced4da" style="background:#ced4da" title="Dark Gray"></div>
          <div class="color-option" data-color="#adb5bd" style="background:#adb5bd" title="Charcoal"></div>
          <div class="color-option" data-color="#6c757d" style="background:#6c757d" title="Slate"></div>
          <div class="color-option" data-color="#495057" style="background:#495057" title="Dark Slate"></div>
          <div class="color-option" data-color="#343a40" style="background:#343a40" title="Navy"></div>
          <div class="color-option" data-color="#212529" style="background:#212529" title="Black"></div>
        </div>
        <div class="tile-title">${title}</div>
        <div class="tile-content">${content}</div>
        <div class="connection-dot input" data-dot-type="input" title="Input connection"></div>
        <div class="connection-dot output" data-dot-type="output" title="Output connection"></div>
        <div class="connection-dot top" data-dot-type="top" title="Top connection"></div>
        <div class="connection-dot bottom" data-dot-type="bottom" title="Bottom connection"></div>
      `;
      
      // Add color selection functionality
      tile.querySelectorAll('.color-option').forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          const color = option.dataset.color;
          tile.style.background = color;
          
          // Update selected state
          tile.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');
        });
      });
      
      tile.addEventListener('click', () => selectTile(tile));
      
      return tile;
    }

    function selectTile(tile) {
      document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
      tile.classList.add('selected');
      selectedTile = tile;
    }

    function setupCanvas() {
      demoContent.addEventListener('mousedown', e => {
        const tile = e.target.closest('.tile');
        if (tile) {
          startDragging(e, tile);
        } else {
          // Start panning when clicking on empty canvas
          startPanning(e);
        }
      });
      
      demoContent.addEventListener('mousemove', handleMouseMove);
      demoContent.addEventListener('mouseup', () => {
        isDragging = false;
        isPanning = false;
        selectedTile = null;
        demoContent.classList.remove('panning');
      });
    }

    function startPanning(e) {
      isPanning = true;
      demoContent.classList.add('panning');
      panStart.x = e.clientX - canvasOffset.x;
      panStart.y = e.clientY - canvasOffset.y;
    }

    function startDragging(e, tile) {
      isDragging = true;
      selectedTile = tile;
      selectTile(tile);
      const r = tile.getBoundingClientRect();
      dragOffset.x = e.clientX - r.left;
      dragOffset.y = e.clientY - r.top;
    }

    function handleMouseMove(e) {
      if (isDragging && selectedTile) {
        const rect = demoContent.getBoundingClientRect();
        const x = e.clientX - rect.left - dragOffset.x;
        const y = e.clientY - rect.top - dragOffset.y;
        selectedTile.style.left = x + 'px';
        selectedTile.style.top = y + 'px';
        
        // Update connections immediately when tile moves
        renderConnections();
      } else if (isPanning) {
        updatePanning(e);
      }
    }

    function updatePanning(e) {
      canvasOffset.x = e.clientX - panStart.x;
      canvasOffset.y = e.clientY - panStart.y;
      
      // Apply pan offset to all tiles
      tiles.forEach(tile => {
        const currentX = parseInt(tile.style.left) || 0;
        const currentY = parseInt(tile.style.top) || 0;
        tile.style.left = (currentX + canvasOffset.x) + 'px';
        tile.style.top = (currentY + canvasOffset.y) + 'px';
      });
      
      // Reset offset for next pan
      canvasOffset.x = 0;
      canvasOffset.y = 0;
      
      // Update connections
      renderConnections();
    }

    function createConnectionLine(fromX, fromY, toX, toY) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.style.position = 'absolute';
      svg.style.left = '0';
      svg.style.top = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';
      svg.style.pointerEvents = 'none';
      svg.style.zIndex = '5';
      
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      
      // Always use smooth curves for better visual appeal
      const midX = (fromX + toX) / 2;
      const midY = (fromY + toY) / 2;
      const distance = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
      const curveIntensity = Math.max(distance * 0.3, 40);
      
      // Create smooth cubic bezier curve with more pronounced curves
      const control1 = { 
        x: fromX + (midX - fromX) * 0.5, 
        y: fromY + (fromY < toY ? curveIntensity : -curveIntensity) 
      };
      const control2 = { 
        x: toX - (toX - midX) * 0.5, 
        y: toY + (toY < fromY ? curveIntensity : -curveIntensity) 
      };
      
      const pathData = `M ${fromX} ${fromY} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${toX} ${toY}`;
      
      path.setAttribute('d', pathData);
      path.setAttribute('stroke', 'var(--accent-primary)');
      path.setAttribute('stroke-width', '3');
      path.setAttribute('fill', 'none');
      path.setAttribute('marker-end', 'url(#arrowhead)');
      path.classList.add('connection-line');
      
      svg.appendChild(path);
      return svg;
    }

    function renderConnections() {
      // Remove existing connections
      document.querySelectorAll('.connection-svg').forEach(svg => svg.remove());
      
      // Add connections
      connections.forEach(conn => {
        const fromTile = tiles.find(t => t.dataset.tileId === conn.fromTile);
        const toTile = tiles.find(t => t.dataset.tileId === conn.toTile);
        
        if (fromTile && toTile) {
          const fromRect = fromTile.getBoundingClientRect();
          const toRect = toTile.getBoundingClientRect();
          const canvasRect = demoContent.getBoundingClientRect();
          
          let fromX, fromY, toX, toY;
          
          // Calculate connection points based on dot types
          if (conn.fromDot === 'output') {
            fromX = fromRect.right - canvasRect.left;
            fromY = fromRect.top + fromRect.height / 2 - canvasRect.top;
          } else if (conn.fromDot === 'input') {
            fromX = fromRect.left - canvasRect.left;
            fromY = fromRect.top + fromRect.height / 2 - canvasRect.top;
          } else if (conn.fromDot === 'top') {
            fromX = fromRect.left + fromRect.width / 2 - canvasRect.left;
            fromY = fromRect.top - canvasRect.top;
          } else if (conn.fromDot === 'bottom') {
            fromX = fromRect.left + fromRect.width / 2 - canvasRect.left;
            fromY = fromRect.bottom - canvasRect.top;
          }
          
          if (conn.toDot === 'input') {
            toX = toRect.left - canvasRect.left;
            toY = toRect.top + toRect.height / 2 - canvasRect.top;
          } else if (conn.toDot === 'output') {
            toX = toRect.right - canvasRect.left;
            toY = toRect.top + toRect.height / 2 - canvasRect.top;
          } else if (conn.toDot === 'top') {
            toX = toRect.left + toRect.width / 2 - canvasRect.left;
            toY = toRect.top - canvasRect.top;
          } else if (conn.toDot === 'bottom') {
            toX = toRect.left + toRect.width / 2 - canvasRect.left;
            toY = toRect.bottom - canvasRect.top;
          }
          
          if (fromX !== undefined && toX !== undefined) {
            const connectionLine = createConnectionLine(fromX, fromY, toX, toY);
            connectionLine.classList.add('connection-svg');
            demoContent.appendChild(connectionLine);
          }
        }
      });
    }
  </script>
</body>
</html>
