<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mind Map | Interactive Planning Canvas</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style id="app-style">
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
    }
    .canvas.html2canvas-container {
      width: 5000px !important;
      height: 3000px !important;
    }
    .canvas-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 60px);
      overflow: hidden;
    }
    .canvas {
      position: relative;
      width: 5000px;
      height: 3000px;
      transform-origin: 0 0;
      background-color: #f8fafc;
      background-image:
        linear-gradient(rgba(59, 130, 246, 0.15) 1px, transparent 1px),
        linear-gradient(90deg, rgba(59, 130, 246, 0.15) 1px, transparent 1px);
      background-size: 20px 20px;
    }
         .tile {
       position: absolute;
       width: 250px;
       border-radius: 8px;
       background: white;
       box-shadow: rgba(0, 0, 0, 0.08) 0px 4px 12px;
       user-select: none;
       overflow: hidden;
       transition: box-shadow 0.2s ease, transform 0.1s ease, width 0.3s ease, height 0.3s ease;
       padding: 10px;
       border: 2px solid transparent;
       min-height: 100px;
       max-height: 500px;
       overflow-y: auto;
     }
     .tile:hover {
       border-color: #3b82f6;
       box-shadow: rgba(59, 130, 246, 0.15) 0px 4px 12px;
     }
     .tile.dragging {
       border-color: #3b82f6;
       box-shadow: rgba(59, 130, 246, 0.3) 0px 8px 24px;
       transform: scale(1.02);
       z-index: 1000;
     }
    .tile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
    }
    .tile-content {
      min-height: 50px;
      word-wrap: break-word;
      white-space: pre-line;
      padding: 5px;
      border: 1px solid transparent;
      border-radius: 4px;
    }
    .tile-content:focus, [contenteditable]:focus {
      outline: none;
      border-color: #3b82f6;
      background-color: #f8fafc;
    }
    .edit-bar {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      margin-bottom: 10px;
    }
    .toolbar {
      display: flex;
      justify-content: space-between;
      padding: 10px 20px;
      background-color: #e2e8f0;
      border-bottom: 1px solid #ccc;
    }
    
    /* AI Assistant Panel */
    .ai-assistant-panel {
      position: fixed;
      right: 20px;
      top: 80px;
      width: 300px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      overflow: hidden;
      transition: transform 0.3s ease, opacity 0.3s ease;
      transform: translateX(320px);
      opacity: 0;
    }
    .ai-assistant-panel.visible {
      transform: translateX(0);
      opacity: 1;
    }
    .ai-assistant-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background-color: #3b82f6;
      color: white;
      font-weight: 500;
    }
    .ai-assistant-content {
      padding: 16px;
      max-height: 400px;
      overflow-y: auto;
    }
    .ai-assistant-footer {
      padding: 12px 16px;
      border-top: 1px solid #e2e8f0;
      display: flex;
    }
    .ai-assistant-input {
      flex-grow: 1;
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 14px;
    }
    .ai-assistant-send {
      margin-left: 8px;
      background-color: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
    }
    .ai-toggle-button {
      position: fixed;
      right: 20px;
      top: 20px;
      background-color: #3b82f6;
      color: white;
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1001;
    }
    .project-title {
      font-size: 18px;
      font-weight: 600;
      color: #1f2937;
      margin-right: 20px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 300px;
    }
    
    /* AI Assistant Message Styling */
    .message {
      margin-bottom: 12px;
      display: flex;
    }
    .user-message {
      justify-content: flex-end;
    }
    .ai-message {
      justify-content: flex-start;
    }
    .toolbar-button {
      display: flex;
      align-items: center;
      padding: 5px 10px;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
    .zoom-controls {
      position: absolute;
      bottom: 10px;
      right: 10px;
      display: flex;
      gap: 5px;
    }
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #34d399;
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      display: none;
    }
    .toast.show {
      display: flex;
      align-items: center;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }
    .modal.show {
      display: block;
    }
    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 500px;
    }
    .connector-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #94a3b8;
      border-radius: 50%;
      cursor: pointer;
    }
    .input {
      top: 0;
      left: 50%;
      transform: translateX(-50%);
    }
    .output {
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
    }
         .loader {
       border: 2px solid #f3f3f3;
       border-top: 2px solid #3498db;
       border-radius: 50%;
       width: 12px;
       height: 12px;
       animation: spin 1s linear infinite;
     }
     @keyframes spin {
       0% { transform: rotate(0deg); }
       100% { transform: rotate(360deg); }
     }
     .connections-layer {
       position: absolute;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       pointer-events: none;
       z-index: 10;
     }
     .connection-line {
       stroke: #94a3b8;
       stroke-width: 2;
       fill: none;
       marker-end: url(#arrowhead);
       filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
       cursor: pointer;
     }
     .connection-line.active {
       stroke: #3b82f6;
       stroke-width: 3;
       filter: drop-shadow(0 2px 4px rgba(59, 130, 246, 0.3));
     }
     .connection-label {
       position: absolute;
       background-color: white;
       border: 1px solid #e2e8f0;
       border-radius: 4px;
       padding: 4px 8px;
       font-size: 12px;
       box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
       z-index: 15;
       cursor: text;
       max-width: 150px;
       word-wrap: break-word;
       pointer-events: auto;
     }
     .connection-label:empty:before {
       content: 'Click to add label';
       color: #94a3b8;
     }
     .connector-handle {
       position: absolute;
       width: 16px;
       height: 16px;
       background-color: #3b82f6;
       border-radius: 50%;
       cursor: pointer;
       border: 2px solid white;
       box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
       transition: all 0.2s ease;
       z-index: 20; /* Ensure handles are above other elements */
     }
     .connector-handle:hover {
       background-color: #2563eb;
       transform: scale(1.3);
       box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.3);
     }
     .connector-handle.input {
       top: -8px;
     }
     .connector-handle.output {
       bottom: -8px;
     }
  </style>
</head>
<body class="bg-slate-50">
  <div class="toolbar">
    <div class="flex items-center">
      <div id="project-title" class="project-title">Mind Map</div>
      <button id="add-tile" class="toolbar-button primary">
        <i class="fa-solid fa-plus"></i> Add Tile
      </button>
      <button id="export-json" class="toolbar-button">
        <i class="fa-solid fa-file-export"></i> Export JSON
      </button>
      <button id="export-png" class="toolbar-button">
        <i class="fa-solid fa-image"></i> Export PNG
      </button>
    </div>
    <div>
      <button id="clear-all" class="toolbar-button text-red-600 hover:bg-red-50">
        <i class="fa-solid fa-trash-can"></i> Clear All
      </button>
    </div>
  </div>
  
  <!-- AI Assistant Button and Panel -->
  <button id="ai-toggle" class="ai-toggle-button">
    <i class="fa-solid fa-robot"></i>
  </button>
  
  <div id="ai-assistant" class="ai-assistant-panel">
    <div class="ai-assistant-header">
      <div>AI Assistant</div>
      <button id="ai-close" class="text-white">
        <i class="fa-solid fa-times"></i>
      </button>
    </div>
    <div id="ai-content" class="ai-assistant-content">
      <p>Hello! I'm your AI assistant. I can help you with your mind mapping project based on the information you provided in the setup.</p>
    </div>
    <div class="ai-assistant-footer">
      <input type="text" id="ai-input" class="ai-assistant-input" placeholder="Ask me anything...">
      <button id="ai-send" class="ai-assistant-send">
        <i class="fa-solid fa-paper-plane"></i>
      </button>
    </div>
  </div>
  
  <div class="canvas-container">
     <div id="canvas" class="canvas html2canvas-container">
       <svg class="connections-layer" id="connections-svg">
         <defs>
           <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                   refX="10" refY="3.5" orient="auto">
             <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
           </marker>
         </defs>
       </svg>
     </div>
   </div>

  <div class="zoom-controls" style="display: none;">
    <button id="zoom-in"><i class="fa-solid fa-plus"></i></button>
    <button id="zoom-out"><i class="fa-solid fa-minus"></i></button>
    <button id="zoom-reset"><i class="fa-solid fa-arrows-to-dot"></i></button>
  </div>

  <div id="toast" class="toast">
    <i class="fa-solid fa-circle-check"></i>
    <span id="toast-message"></span>
  </div>

  <div id="export-area" class="p-4" style="display: none;">
    <div class="bg-white p-4 rounded-md shadow-md">
      <h3 class="text-xl font-semibold text-slate-800 mb-4">Export JSON</h3>
      <div class="mb-4">
        <textarea id="json-content" class="w-full h-64 p-3 border border-slate-300 rounded-md font-mono text-sm" readonly></textarea>
      </div>
      <div class="flex justify-end">
        <button id="copy-json" class="toolbar-button mr-2">
          <i class="fa-solid fa-copy"></i> Copy
        </button>
        <button id="close-export" class="toolbar-button">
          Close
        </button>
      </div>
    </div>
  </div>

  <script id="app-script">
              // Custom connection system to replace LeaderLine
     class ConnectionManager {
       constructor(svgElement) {
         this.svg = svgElement;
         this.connections = [];
         this.activeLabel = null;
       }
       
       createConnection(fromTileId, toTileId, label = '') {
         const fromHandle = document.querySelector(`.connector-handle.output[data-tile="${fromTileId}"]`);
         const toHandle = document.querySelector(`.connector-handle.input[data-tile="${toTileId}"]`);
         
         if (!fromHandle || !toHandle) return null;
         
         const connection = {
           id: `conn-${fromTileId}-${toTileId}`,
           from: fromTileId,
           to: toTileId,
           label: label,
           element: this.createSVGLine(fromHandle, toHandle),
           labelElement: this.createLabelElement(label)
         };
         
         // Add click event to the line
         connection.element.addEventListener('click', (e) => {
           e.stopPropagation();
           this.showLabel(connection);
         });
         
         this.connections.push(connection);
         this.svg.appendChild(connection.element);
         document.querySelector('.canvas-container').appendChild(connection.labelElement);
         this.updateLabelPosition(connection);
         
         return connection;
       }
       
       createLabelElement(text = '') {
         const label = document.createElement('div');
         label.className = 'connection-label';
         label.contentEditable = true;
         label.textContent = text;
         label.style.display = 'none';
         
         label.addEventListener('blur', () => {
           const connection = this.connections.find(c => c.labelElement === label);
           if (connection) {
             connection.label = label.textContent;
             if (!label.textContent.trim()) {
               label.style.display = 'none';
             }
             saveState();
           }
         });
         
         label.addEventListener('keydown', (e) => {
           if (e.key === 'Enter' && !e.shiftKey) {
             e.preventDefault();
             label.blur();
           }
         });
         
         return label;
       }
       
       showLabel(connection) {
         // Hide any previously active label
         if (this.activeLabel) {
           this.activeLabel.style.display = 'none';
         }
         
         connection.labelElement.style.display = 'block';
         this.updateLabelPosition(connection);
         connection.labelElement.focus();
         this.activeLabel = connection.labelElement;
       }
       
               createSVGLine(fromHandle, toHandle) {
         const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
         path.classList.add('connection-line');
         path.setAttribute('stroke', '#3b82f6');
         path.setAttribute('stroke-width', '2.5');
         path.setAttribute('marker-end', 'url(#arrowhead)');
         this.updateLinePosition(path, fromHandle, toHandle);
         return path;
       }
        
        updateLinePosition(path, fromHandle, toHandle) {
          const fromRect = fromHandle.getBoundingClientRect();
          const toRect = toHandle.getBoundingClientRect();
          const svgRect = this.svg.getBoundingClientRect();
          
          const fromX = fromRect.left + fromRect.width / 2 - svgRect.left;
          const fromY = fromRect.top + fromRect.height / 2 - svgRect.top;
          const toX = toRect.left + toRect.width / 2 - svgRect.left;
          const toY = toRect.top + toRect.height / 2 - svgRect.top;
          
          // Calculate control points for curved path
          const dx = toX - fromX;
          const dy = toY - fromY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const controlOffset = Math.min(distance * 0.3, 100); // Curvature factor
          
          const controlX1 = fromX + controlOffset;
          const controlY1 = fromY;
          const controlX2 = toX - controlOffset;
          const controlY2 = toY;
          
          const pathData = `M ${fromX} ${fromY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${toX} ${toY}`;
          path.setAttribute('d', pathData);
        }
       
       updateConnection(connection) {
        const fromHandle = document.querySelector(`.connector-handle.output[data-tile="${connection.from}"]`);
        const toHandle = document.querySelector(`.connector-handle.input[data-tile="${connection.to}"]`);
        
        if (fromHandle && toHandle) {
          this.updateLinePosition(connection.element, fromHandle, toHandle);
          if (connection.labelElement) {
            this.updateLabelPosition(connection);
          }
        }
      }
      
      updateLabelPosition(connection) {
        if (!connection.element || !connection.labelElement) return;
        
        const path = connection.element;
        const pathLength = path.getTotalLength();
        
        // Position the label at the middle of the path
        const midPoint = path.getPointAtLength(pathLength / 2);
        
        // Get the SVG's position relative to the viewport
        const svgRect = this.svg.getBoundingClientRect();
        const canvasRect = document.querySelector('.canvas-container').getBoundingClientRect();
        
        // Calculate the absolute position
        const x = midPoint.x + svgRect.left - canvasRect.left;
        const y = midPoint.y + svgRect.top - canvasRect.top;
        
        // Position the label
        connection.labelElement.style.left = `${x}px`;
        connection.labelElement.style.top = `${y}px`;
        connection.labelElement.style.transform = 'translate(-50%, -50%)';
      }
       
       updateAllConnections() {
         this.connections.forEach(conn => this.updateConnection(conn));
       }
       
       removeConnection(connection) {
         if (connection.element) {
           connection.element.remove();
         }
         const index = this.connections.findIndex(c => c.id === connection.id);
         if (index !== -1) {
           this.connections.splice(index, 1);
         }
       }
       
       removeConnectionsForTile(tileId) {
         this.connections
           .filter(conn => conn.from === tileId || conn.to === tileId)
           .forEach(conn => this.removeConnection(conn));
       }
       
               createTemporaryLine(fromHandle, startX, startY) {
         const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
         path.classList.add('connection-line', 'active');
         path.setAttribute('stroke', '#3b82f6');
         path.setAttribute('stroke-width', '3');
         path.setAttribute('stroke-dasharray', '5,3');
         path.setAttribute('marker-end', 'url(#arrowhead)');
         
         // Initial path with just the starting point
         const pathData = `M ${startX} ${startY}`;
         path.setAttribute('d', pathData);
         
         this.svg.appendChild(path);
         return path;
        }
     }

     function initApp() {
             const state = {
         tiles: [],
         connections: [],
         activeConnection: null,
         activeTile: null,
         nextId: 1,
         zoomLevel: 1
       };
       
       const connectionManager = new ConnectionManager(document.getElementById('connections-svg'));
      const canvas = document.getElementById('canvas');
      const container = document.querySelector('.canvas-container');
      const addTileBtn = document.getElementById('add-tile');
      const exportJsonBtn = document.getElementById('export-json');
      const exportPngBtn = document.getElementById('export-png');
      const clearAllBtn = document.getElementById('clear-all');
      const zoomInBtn = document.getElementById('zoom-in');
      const zoomOutBtn = document.getElementById('zoom-out');
      const zoomResetBtn = document.getElementById('zoom-reset');
      const toast = document.getElementById('toast');
      const toastMessage = document.getElementById('toast-message');
      const exportArea = document.getElementById('export-area');
      const jsonContent = document.getElementById('json-content');
      const copyJsonBtn = document.getElementById('copy-json');
      const closeExportBtn = document.getElementById('close-export');

             const panzoomInstance = Panzoom(canvas, {
         maxZoom: 4,
         minZoom: 0.1,
         zoomDoubleClickSpeed: 1,
         smoothScroll: false,
         exclude: ['.tile']
       });
       let currentTransform = { x: 0, y: 0, scale: 1 };
       
       // Update transform on pan/zoom using the newer API
       canvas.addEventListener('panzoom', (e) => {
         currentTransform = panzoomInstance.getTransform();
         connectionManager.updateAllConnections();
       });
       
       // Enable mouse wheel zooming
       container.addEventListener('wheel', (e) => {
         if (e.target.closest('.tile')) return; // Don't zoom when scrolling on tiles
         e.preventDefault();
         const delta = e.deltaY;
         const { scale } = panzoomInstance.getTransform();
         const newScale = delta > 0 ? scale / 1.1 : scale * 1.1;
         panzoomInstance.zoomTo(e.clientX, e.clientY, newScale);
       }, { passive: false });

      function showToast(message, type = 'success') {
        toastMessage.textContent = message;
        toast.className = `toast ${type} show`;
        if (type === 'error') {
          toast.style.backgroundColor = '#ef4444';
        } else {
          toast.style.backgroundColor = '#34d399';
        }
        setTimeout(() => {
          toast.classList.remove('show');
        }, 3000);
      }

      function createTile(id, x, y, title = 'New Task', content = 'Click to edit description') {
        const gridSize = 20;
        const snappedX = Math.round(x / gridSize) * gridSize;
        const snappedY = Math.round(y / gridSize) * gridSize;
        const tileElement = document.createElement('div');
        tileElement.className = 'tile';
        tileElement.id = `tile-${id}`;
        tileElement.dataset.id = id;
        tileElement.style.left = `${snappedX}px`;
        tileElement.style.top = `${snappedY}px`;
        tileElement.innerHTML = `
          <div class="tile-header" draggable="true">
            <div class="font-medium text-slate-700" contenteditable="true">${title}</div>
            <div class="flex">
              <button class="text-slate-400 hover:text-slate-700 tile-ai-suggest ml-2">
                <i class="fa-solid fa-wand-magic-sparkles"></i>
              </button>
              <button class="text-slate-400 hover:text-red-500 tile-delete ml-2">
                <i class="fa-solid fa-xmark"></i>
              </button>
            </div>
          </div>
          <input type="text" class="edit-bar" placeholder="Type here and press Enter to add text...">
          <div class="tile-content" contenteditable="true">${content}</div>
          <div class="connector-handle input" data-tile="${id}"></div>
          <div class="connector-handle output" data-tile="${id}"></div>
        `;
        canvas.appendChild(tileElement);
        const tile = { id, element: tileElement, x: snappedX, y: snappedY, title, content };
        state.tiles.push(tile);
        makeElementDraggable(tileElement);
        return tile;
      }

             function makeElementDraggable(element) {
         let startX, startY, startMouseX, startMouseY, isDragging = false;
 
         // Make entire tile draggable, not just header
         element.addEventListener('mousedown', startDrag);
         element.addEventListener('touchstart', startDrag, { passive: false });
 
         function startDrag(e) {
           // Don't start drag if clicking on buttons, contenteditable elements, or edit bar
           if (e.target.closest('button') || e.target.getAttribute('contenteditable') === 'true' || e.target.classList.contains('edit-bar')) {
             return;
           }
           
           e.preventDefault();
           startX = parseFloat(element.style.left) || 0;
           startY = parseFloat(element.style.top) || 0;
           startMouseX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
           startMouseY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
           isDragging = true;
           
           element.classList.add('dragging');
           setActiveTile(element);
           document.addEventListener('mousemove', drag);
           document.addEventListener('touchmove', drag, { passive: false });
           document.addEventListener('mouseup', endDrag);
           document.addEventListener('touchend', endDrag);
         }
         
         // Auto-resize based on content
         const content = element.querySelector('.tile-content');
         const resizeObserver = new ResizeObserver(() => {
           adjustTileSize(element);
         });
         
         resizeObserver.observe(content);
         content.addEventListener('input', () => adjustTileSize(element));

        function drag(e) {
          if (!isDragging) return;
          e.preventDefault();
          const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
          const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
          const deltaX = (clientX - startMouseX) / currentTransform.scale;
          const deltaY = (clientY - startMouseY) / currentTransform.scale;
          const newX = startX + deltaX;
          const newY = startY + deltaY;
          element.style.left = `${newX}px`;
          element.style.top = `${newY}px`;
          const tileId = parseInt(element.dataset.id);
          const tile = state.tiles.find(t => t.id === tileId);
          if (tile) {
            tile.x = newX;
            tile.y = newY;
          }
          updateConnections(tileId);
        }

                 function endDrag() {
           isDragging = false;
           document.removeEventListener('mousemove', drag);
           document.removeEventListener('touchmove', drag);
           document.removeEventListener('mouseup', endDrag);
           document.removeEventListener('touchend', endDrag);
           
           element.classList.remove('dragging');
           
           const tileId = parseInt(element.dataset.id);
           const tile = state.tiles.find(t => t.id === tileId);
           const gridSize = 20;
           tile.x = Math.round(tile.x / gridSize) * gridSize;
           tile.y = Math.round(tile.y / gridSize) * gridSize;
           element.style.left = `${tile.x}px`;
           element.style.top = `${tile.y}px`;
           updateConnections(tileId);
           saveState();
         }
      }

      function setActiveTile(element) {
        document.querySelectorAll('.tile.active').forEach(t => t.classList.remove('active'));
        if (element) {
          element.classList.add('active');
          state.activeTile = parseInt(element.dataset.id);
        } else {
          state.activeTile = null;
        }
      }

             function createConnection(fromTileId, toTileId, label = '') {
         if (state.connections.some(conn => conn.from === fromTileId && conn.to === toTileId)) return null;
         const connection = connectionManager.createConnection(fromTileId, toTileId, label);
         if (connection) {
           // Set the marker-end attribute to use the arrowhead marker
           connection.element.setAttribute('marker-end', 'url(#arrowhead)');
           state.connections.push(connection);
         }
         return connection;
       }

       function updateConnections(tileId) {
         state.connections
           .filter(conn => conn.from === tileId || conn.to === tileId)
           .forEach(conn => connectionManager.updateConnection(conn));
       }

       function removeTile(tileId) {
         connectionManager.removeConnectionsForTile(tileId);
         state.connections = state.connections.filter(conn => conn.from !== tileId && conn.to !== tileId);

         const tileIndex = state.tiles.findIndex(t => t.id === tileId);
         if (tileIndex !== -1) {
           state.tiles[tileIndex].element.remove();
           state.tiles.splice(tileIndex, 1);
         }
         saveState();
       }

      function adjustTileSize(element) {
        const content = element.querySelector('.tile-content');
        const contentLength = content.textContent.length;
        
        // Base width calculation
        let newWidth = 250; // Default width
        
        if (contentLength > 100) {
          newWidth = Math.min(400, 250 + (contentLength - 100) / 3);
        }
        
        // Set the new width
        element.style.width = `${newWidth}px`;
        
        // Update connections after resize
        const tileId = parseInt(element.dataset.id);
        updateConnections(tileId);
      }

      function saveState() {
        const dataToSave = {
          tiles: state.tiles.map(tile => ({
            id: tile.id,
            x: tile.x,
            y: tile.y,
            title: tile.element.querySelector('.tile-header div[contenteditable]').textContent,
            content: tile.element.querySelector('.tile-content').textContent
          })),
          connections: state.connections.map(conn => ({ 
            from: conn.from, 
            to: conn.to, 
            label: conn.label || ''
          })),
          nextId: state.nextId
        };
        localStorage.setItem('Flowpad-state', JSON.stringify(dataToSave));
      }

             function loadState() {
         try {
           const savedData = localStorage.getItem('Flowpad-state');
           if (!savedData) return false;
           const parsedData = JSON.parse(savedData);
           canvas.innerHTML = `
             <svg class="connections-layer" id="connections-svg">
               <defs>
                 <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                         refX="9" refY="3.5" orient="auto">
                   <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8" />
                 </marker>
               </defs>
             </svg>
           `;
           state.tiles = [];
           state.connections.forEach(conn => connectionManager.removeConnection(conn));
           state.connections = [];
           parsedData.tiles.forEach(tileData => {
             const tile = createTile(tileData.id, tileData.x, tileData.y, tileData.title, tileData.content);
             // Apply custom width if available
             if (tileData.width && tileData.width !== 250) {
               tile.element.style.width = `${tileData.width}px`;
             }
           });
           parsedData.connections.forEach(conn => {
             // Create connection with label directly
             const connection = createConnection(conn.from, conn.to, conn.label || '');
             if (connection && conn.label && conn.label.trim()) {
               // Make sure label is visible if it has content
               connection.labelElement.style.display = 'block';
               connectionManager.updateLabelPosition(connection);
             }
           });
           state.nextId = parsedData.nextId;
           return true;
         } catch (err) {
           console.error('Failed to load saved state:', err);
           return false;
         }
       }

      function exportAsJson() {
        const dataToExport = {
          tiles: state.tiles.map(tile => ({
            id: tile.id,
            x: tile.x,
            y: tile.y,
            title: tile.element.querySelector('.tile-header div[contenteditable]').textContent,
            content: tile.element.querySelector('.tile-content').textContent
          })),
          connections: state.connections.map(conn => ({
            from: conn.from,
            to: conn.to
          }))
        };
        jsonContent.value = JSON.stringify(dataToExport, null, 2);
        exportArea.style.display = 'block';
      }

      async function exportAsPng() {
        try {
          showToast('Preparing export...', 'success');
          const zoomControls = document.querySelector('.zoom-controls');
          zoomControls.style.display = 'none';

                     const originalTransform = canvas.style.transform;
           canvas.style.transform = 'translate(0px, 0px) scale(1)';
           connectionManager.updateAllConnections();

          const originalContainerStyle = {
            overflow: container.style.overflow,
            height: container.style.height,
            width: container.style.width
          };
          container.style.overflow = 'visible';

          let minX = 0, minY = 0, maxX = 0, maxY = 0;
          state.tiles.forEach(tile => {
            const x = tile.x;
            const y = tile.y;
            const w = tile.element.offsetWidth;
            const h = tile.element.offsetHeight;
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x + w);
            maxY = Math.max(maxY, y + h);
          });
          const margin = 50;
          const exportWidth = maxX - minX + margin * 2;
          const exportHeight = maxY - minY + margin * 2;

          const originalPositions = state.tiles.map(tile => ({ x: tile.x, y: tile.y }));
          state.tiles.forEach(tile => {
            tile.x = tile.x - minX + margin;
            tile.y = tile.y - minY + margin;
            tile.element.style.left = `${tile.x}px`;
            tile.element.style.top = `${tile.y}px`;
          });
          connectionManager.updateAllConnections();

          const originalCanvasWidth = canvas.style.width;
          const originalCanvasHeight = canvas.style.height;
          canvas.style.width = `${exportWidth}px`;
          canvas.style.height = `${exportHeight}px`;
          container.style.width = `${exportWidth}px`;
          container.style.height = `${exportHeight}px`;

          const screenshot = await html2canvas(canvas, {
            useCORS: true,
            allowTaint: false,
            scale: 2
          });

          canvas.style.width = originalCanvasWidth;
          canvas.style.height = originalCanvasHeight;
          state.tiles.forEach((tile, index) => {
            tile.x = originalPositions[index].x;
            tile.y = originalPositions[index].y;
            tile.element.style.left = `${tile.x}px`;
            tile.element.style.top = `${tile.y}px`;
          });
          connectionManager.updateAllConnections();

          container.style.overflow = originalContainerStyle.overflow;
          container.style.height = originalContainerStyle.height;
          container.style.width = originalContainerStyle.width;

          canvas.style.transform = originalTransform;
          connectionManager.updateAllConnections();

          zoomControls.style.display = 'flex';

          const link = document.createElement('a');
          link.download = 'Flowpad-canvas.png';
          link.href = screenshot.toDataURL('image/png');
          link.click();

          showToast('Export successful!', 'success');
        } catch (err) {
          console.error('Failed to export as PNG:', err);
          // Basic restore in case of error
          canvas.style.transform = originalTransform || '';
          container.style.overflow = originalContainerStyle.overflow || '';
          container.style.height = originalContainerStyle.height || '';
          container.style.width = originalContainerStyle.width || '';
          zoomControls.style.display = 'flex';
          showToast('Export failed. Please try again.', 'error');
        }
      }

      function requestAISuggestions(tileId) {
        const tileElement = document.getElementById(`tile-${tileId}`);
        const aiButton = tileElement.querySelector('.tile-ai-suggest');
        const title = tileElement.querySelector('.tile-header div[contenteditable]').textContent;

        aiButton.innerHTML = `<div class="loader"></div>`;
        setTimeout(() => {
          aiButton.innerHTML = `<i class="fa-solid fa-wand-magic-sparkles"></i>`;
          let suggestionsContainer = tileElement.querySelector('.suggestions-container');
          if (!suggestionsContainer) {
            suggestionsContainer = document.createElement('div');
            suggestionsContainer.className = 'suggestions-container p-3 bg-blue-50 mt-2 rounded-md';
            suggestionsContainer.innerHTML = `
              <div class="text-sm font-medium mb-2 text-blue-700">AI Suggestions</div>
              <div class="suggestions-list"></div>
            `;
            tileElement.querySelector('.tile-content').after(suggestionsContainer);
          }
          const suggestionsList = suggestionsContainer.querySelector('.suggestions-list');
          suggestionsList.innerHTML = '';
          const suggestions = generateFakeSuggestions(title);
          suggestions.forEach((suggestion, index) => {
            const suggestionEl = document.createElement('div');
            suggestionEl.className = 'suggestion';
            suggestionEl.innerHTML = `
              <div class="flex items-center justify-between">
                <div>${suggestion}</div>
                <button class="text-blue-500 hover:text-blue-700 add-suggestion" data-suggestion="${index}">
                  <i class="fa-solid fa-plus"></i>
                </button>
              </div>`;
            suggestionsList.appendChild(suggestionEl);
          });
          suggestionsContainer.querySelectorAll('.add-suggestion').forEach(btn => {
            btn.addEventListener('click', (e) => {
              const suggestionIndex = parseInt(e.currentTarget.dataset.suggestion);
              const suggestionText = suggestions[suggestionIndex];
              const newX = parseInt(tileElement.style.left) + 250;
              const newY = parseInt(tileElement.style.top) + 50;
              const gridSize = 20;
              const snappedNewX = Math.round(newX / gridSize) * gridSize;
              const snappedNewY = Math.round(newY / gridSize) * gridSize;
              const newTile = createTile(state.nextId++, snappedNewX, snappedNewY, suggestionText, 'Generated from AI suggestion');
              createConnection(tileId, newTile.id);
              saveState();
              showToast('Added suggested task!', 'success');
              e.currentTarget.closest('.suggestion').remove();
            });
          });
        }, 1500);
      }

      function generateFakeSuggestions(title) {
        return [
          `Research ${title} options`,
          `Create ${title} plan`,
          `Schedule ${title} meeting`
        ];
      }

      addTileBtn.addEventListener('click', () => {
        const centerX = (container.clientWidth / 2 - currentTransform.x) / currentTransform.scale;
        const centerY = (container.clientHeight / 2 - currentTransform.y) / currentTransform.scale;
        createTile(state.nextId++, centerX, centerY);
        saveState();
        showToast('New tile added!');
      });
      exportJsonBtn.addEventListener('click', exportAsJson);
      exportPngBtn.addEventListener('click', exportAsPng);
             clearAllBtn.addEventListener('click', () => {
           state.connections.forEach(conn => connectionManager.removeConnection(conn));
           canvas.innerHTML = `
             <svg class="connections-layer" id="connections-svg">
               <defs>
                 <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                         refX="9" refY="3.5" orient="auto">
                   <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8" />
                 </marker>
               </defs>
             </svg>
           `;
           state.tiles = [];
           state.connections = [];
           state.nextId = 1;
           panzoomInstance.moveTo(0, 0);
           panzoomInstance.zoomAbs(0, 0, 1);
           localStorage.removeItem('Flowpad-state');
           showToast('All content cleared!');
       });
      zoomInBtn.addEventListener('click', () => {
        const { scale } = panzoomInstance.getTransform();
        panzoomInstance.zoomTo(container.clientWidth / 2, container.clientHeight / 2, scale * 1.2);
      });
      zoomOutBtn.addEventListener('click', () => {
        const { scale } = panzoomInstance.getTransform();
        panzoomInstance.zoomTo(container.clientWidth / 2, container.clientHeight / 2, scale / 1.2);
      });
      zoomResetBtn.addEventListener('click', () => {
        panzoomInstance.moveTo(0, 0);
        panzoomInstance.zoomAbs(0, 0, 1);
      });
      copyJsonBtn.addEventListener('click', () => {
        const text = jsonContent.value;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text)
            .then(() => showToast('JSON copied to clipboard!', 'success'))
            .catch(() => showToast('Copy failed.', 'error'));
        } else {
          jsonContent.select();
          try {
            document.execCommand('copy');
            showToast('JSON copied (legacy fallback)!', 'success');
          } catch {
            showToast('Copy not supported.', 'error');
          }
        }
      });
      closeExportBtn.addEventListener('click', () => exportArea.style.display = 'none');
      canvas.addEventListener('click', (e) => {
        if (e.target.closest('.tile-delete')) {
          removeTile(parseInt(e.target.closest('.tile').dataset.id));
          return;
        }
        if (e.target.closest('.tile-ai-suggest')) {
          requestAISuggestions(parseInt(e.target.closest('.tile').dataset.id));
          return;
        }
        const tile = e.target.closest('.tile');
        tile ? setActiveTile(tile) : setActiveTile(null);
      });
             canvas.addEventListener('mousedown', (e) => {
        const handle = e.target.closest('.connector-handle');
        if (!handle) return;
        e.preventDefault();
        e.stopPropagation(); // Prevent panzoom from handling this event
        const tileId = parseInt(handle.dataset.tile);
        if (handle.classList.contains('output')) {
          state.activeConnection = { from: tileId, startElement: handle };
          
          // Get SVG coordinates for initial position
          const svgRect = document.getElementById('connections-svg').getBoundingClientRect();
          const handleRect = handle.getBoundingClientRect();
          const startX = handleRect.left + handleRect.width / 2 - svgRect.left;
          const startY = handleRect.top + handleRect.height / 2 - svgRect.top;
          
          state.activeConnection.tempLine = connectionManager.createTemporaryLine(handle, startX, startY);
          
          // Add visual feedback
          handle.style.backgroundColor = '#2563eb';
          handle.style.transform = 'scale(1.3)';
        }
      });
               document.addEventListener('mousemove', (e) => {
         if (!state.activeConnection || !state.activeConnection.tempLine) return;
         
         const fromHandle = state.activeConnection.startElement;
         const svgRect = document.getElementById('connections-svg').getBoundingClientRect();
         const fromRect = fromHandle.getBoundingClientRect();
         
         const fromX = fromRect.left + fromRect.width / 2 - svgRect.left;
         const fromY = fromRect.top + fromRect.height / 2 - svgRect.top;
         const targetX = e.clientX - svgRect.left;
         const targetY = e.clientY - svgRect.top;
         
         // Calculate control points for curved path
         const dx = targetX - fromX;
         const dy = targetY - fromY;
         const distance = Math.sqrt(dx * dx + dy * dy);
         const controlOffset = Math.min(distance * 0.3, 100);
         
         const controlX1 = fromX + controlOffset;
         const controlY1 = fromY;
         const controlX2 = targetX - controlOffset;
         const controlY2 = targetY;
         
         const pathData = `M ${fromX} ${fromY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${targetX} ${targetY}`;
         state.activeConnection.tempLine.setAttribute('d', pathData);
         
         // Highlight potential target handles
         document.querySelectorAll('.connector-handle.input').forEach(handle => {
           const handleRect = handle.getBoundingClientRect();
           const centerX = handleRect.left + handleRect.width / 2;
           const centerY = handleRect.top + handleRect.height / 2;
           const distance = Math.sqrt(
             Math.pow(e.clientX - centerX, 2) + 
             Math.pow(e.clientY - centerY, 2)
           );
           
           if (distance < 50) {
             handle.style.backgroundColor = '#2563eb';
             handle.style.transform = 'scale(1.3)';
           } else {
             handle.style.backgroundColor = '';
             handle.style.transform = '';
           }
         });
       });
       document.addEventListener('mouseup', (e) => {
        if (!state.activeConnection) return;
        
        // Reset visual feedback on the starting handle
        if (state.activeConnection.startElement) {
          state.activeConnection.startElement.style.backgroundColor = '';
          state.activeConnection.startElement.style.transform = '';
        }
        
        const handle = e.target.closest('.connector-handle');
        if (handle && handle.classList.contains('input')) {
          const toTileId = parseInt(handle.dataset.tile);
          if (state.activeConnection.from !== toTileId) {
            // Add visual feedback to target handle
            handle.style.backgroundColor = '#2563eb';
            handle.style.transform = 'scale(1.3)';
            setTimeout(() => {
              handle.style.backgroundColor = '';
              handle.style.transform = '';
            }, 300);
            
            // Create the connection and show label editor
            const connection = createConnection(state.activeConnection.from, toTileId, '');
            if (connection) {
              setTimeout(() => {
                connectionManager.showLabel(connection);
              }, 300);
            }
            saveState();
            showToast('Connection created');
          }
        }
        
        if (state.activeConnection.tempLine) {
          state.activeConnection.tempLine.remove();
        }
        state.activeConnection = null;
      });
      canvas.addEventListener('blur', (e) => {
        if (e.target.getAttribute('contenteditable') === 'true') saveState();
      }, true);
      
      // Add event listener for edit bars in tiles
      canvas.addEventListener('keydown', (e) => {
        if (e.target.classList.contains('edit-bar') && e.key === 'Enter') {
          e.preventDefault();
          const text = e.target.value.trim();
          if (text) {
            const tile = e.target.closest('.tile');
            const contentArea = tile.querySelector('.tile-content');
            contentArea.textContent += (contentArea.textContent ? '\n' : '') + text;
            e.target.value = '';
            saveState();
          }
        }
      });

             // AI Assistant functionality
     function initAIAssistant() {
       const aiToggle = document.getElementById('ai-toggle');
       const aiPanel = document.getElementById('ai-assistant');
       const aiClose = document.getElementById('ai-close');
       const aiInput = document.getElementById('ai-input');
       const aiSend = document.getElementById('ai-send');
       const aiContent = document.getElementById('ai-content');
       
       // Load setup data from localStorage
       const setupData = JSON.parse(localStorage.getItem('mindMapSetup') || '{}');
       const projectTitle = document.getElementById('project-title');
       
       // Update project title if available
       if (setupData.title) {
         projectTitle.textContent = setupData.title;
         document.title = `${setupData.title} | Mind Map`;
       }
       
       // Toggle AI panel visibility
       aiToggle.addEventListener('click', () => {
         aiPanel.classList.toggle('visible');
       });
       
       // Close AI panel
       aiClose.addEventListener('click', () => {
         aiPanel.classList.remove('visible');
       });
       
       // Send message to AI
       function sendMessage() {
         const message = aiInput.value.trim();
         if (!message) return;
         
         // Add user message to chat
         appendMessage('user', message);
         aiInput.value = '';
         
         // Generate AI response based on setup data and message
         const response = generateAIResponse(message, setupData);
         setTimeout(() => {
           appendMessage('ai', response);
         }, 500);
       }
       
       // Send message on button click
       aiSend.addEventListener('click', sendMessage);
       
       // Send message on Enter key
       aiInput.addEventListener('keydown', (e) => {
         if (e.key === 'Enter') {
           e.preventDefault();
           sendMessage();
         }
       });
       
       // Append message to chat
       function appendMessage(sender, text) {
         const messageEl = document.createElement('div');
         messageEl.className = `message ${sender}-message mb-3`;
         
         const contentEl = document.createElement('div');
         contentEl.className = sender === 'user' ? 'bg-blue-100 p-2 rounded-lg inline-block' : 'bg-gray-100 p-2 rounded-lg inline-block';
         contentEl.textContent = text;
         
         messageEl.appendChild(contentEl);
         aiContent.appendChild(messageEl);
         aiContent.scrollTop = aiContent.scrollHeight;
       }
       
       // Generate AI response based on setup data and user message
       function generateAIResponse(message, setupData) {
         // If no setup data is available, provide a generic response
         if (!setupData.title && !setupData.description && (!setupData.questions || setupData.questions.length === 0)) {
           return "I don't have any specific information about your project. You can go back to the setup page to provide more details.";
         }
         
         // Check if message contains keywords related to the project
         const lowerMessage = message.toLowerCase();
         
         // If asking about the project
         if (lowerMessage.includes('project') || lowerMessage.includes('about') || lowerMessage.includes('what') || lowerMessage.includes('purpose')) {
           return `This project is about "${setupData.title}". ${setupData.description || ''}`;
         }
         
         // If asking for suggestions
         if (lowerMessage.includes('suggest') || lowerMessage.includes('idea') || lowerMessage.includes('help')) {
           // Create a suggestion based on the project description
           return `Based on your project "${setupData.title}", you might want to create a mind map that includes the main concept in the center, with branches for key aspects. Try adding a central tile with the title, then connect related concepts around it.`;
         }
         
         // If asking about a specific question from setup
         if (setupData.questions && setupData.questions.length > 0) {
           for (const question of setupData.questions) {
             if (lowerMessage.includes(question.toLowerCase())) {
               return `Regarding "${question}", I suggest creating a dedicated branch in your mind map to explore this aspect of your project.`;
             }
           }
         }
         
         // Default response
         return `I'm here to help with your "${setupData.title}" mind map. You can ask me about the project, request suggestions, or get help with specific aspects of your mind mapping.`;
       }
       
       // Show welcome message with project info if available
       if (setupData.title || setupData.description) {
         const welcomeMessage = `Welcome to your "${setupData.title || 'Mind Map'}" project! ${setupData.description ? '\n\n' + setupData.description : ''}`;
         appendMessage('ai', welcomeMessage);
       }
     }
     
     if (!loadState()) {
       // Check if we have setup data
       const setupData = JSON.parse(localStorage.getItem('mindMapSetup') || '{}');
       if (setupData.title) {
         createTile(state.nextId++, 100, 100, setupData.title, setupData.description || 'Start your mind map here!');
         
         // If we have questions, create tiles for them
         if (setupData.questions && setupData.questions.length > 0) {
           const centerX = 400;
           const centerY = 100;
           const radius = 300;
           const angleStep = (2 * Math.PI) / setupData.questions.length;
           
           setupData.questions.forEach((question, index) => {
             const angle = index * angleStep;
             const x = centerX + radius * Math.cos(angle);
             const y = centerY + radius * Math.sin(angle);
             const tile = createTile(state.nextId++, x, y, question, '');
             createConnection(1, tile.id);
           });
         }
       } else {
         createTile(state.nextId++, 100, 100, 'Welcome to Mind Map!', 'This is your planning canvas. Add tiles, connect them, and organize your thoughts!');
       }
       saveState();
     }
     
     connectionManager.updateAllConnections();
     panzoomInstance.moveTo(container.clientWidth / 2 - 200, container.clientHeight / 2 - 200);
     
     // Initialize AI Assistant
     initAIAssistant();
   }
   
   // Initialize the app when the page loads
   // Note: Tailwind CSS CDN warning is expected in development
   // For production, consider installing Tailwind CSS locally
   if (document.readyState === 'loading') {
     document.addEventListener('DOMContentLoaded', initApp);
   } else {
     // Add a small delay to ensure all scripts are loaded
     setTimeout(initApp, 100);
   }
   </script>
</body>
</html>
